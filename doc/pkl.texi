\input texinfo
@comment %**start of header
@setfilename pkl.info
@settitle The Poke Language
@afourpaper
@comment %**end of header

@copying
Copyright @copyright{} 2018 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Languages
@direntry
* pkl: (pkl). The Poke Language specification
@end direntry

@titlepage
@title The Poke Language
@subtitle Version 1
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Poke Language

@insertcopying
@end ifnottex

@menu
* Introduction::
* Lexical::
@c * Literals
@c * Variables
@c * Functions
* The PKL Type System::
@c * Grammar
* Future Extensions::

* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@c XXX add a rule index.
@end menu

@node Introduction
@chapter Introduction


@section What is PKL

@dfn{PKL} is a domain-specific programming language whose main purpose
is to be used in
@code{poke}@footnote{@url{http://www.gnu.org/s/poke}}, the GNU
interactive editor for binary files.  The name PKL stands for ``Poke
Language'', and it is pronounced (and informally referred to) as
``pickle''.

@section About this Document

This document contains a complete and semi-formal specification of
PKL, describing all the aspects of the language.  The main purpose of
the specification is to serve as a reference for implementations,
notably GNU poke.

This document is not intended to be a tutorial for learning how to
write PKL programs.  For that purpose, please read the Poke Book. XXX:
xref to the poke book.

@node Lexical
@chapter Lexical

The fundamental pieces on which PKL programs are built are called
@dfn{lexical tokens}.  The tokens themselves are built from a stream
of characters provided by the user: the source program.

Some lexical tokens carry over a @dfn{semantic payload}.  This is the
case of numeric literals for example.

In this chapter, the term @dfn{text} is used to refer to a sequence of
@dfn{characters}, where characters are codes of a Character Set
described below.

@section Source Encoding and Character Set

PKL source text shall be encoded in @acronym{ASCII} (ISO-646) and
covers the @acronym{ASCII} character set.

@section Newline Character

Source code lines are separated by the @dfn{newline character},
@acronym{ASCII} code @code{012}.

@section Comments

PKL supports two different kind of comments: multi-line non-nestable
comments and partial-line stackable comments.  Both flavors of
comments are usually processed and removed by the lexical analyzer, as
these are not intended to be preserved for subsequent
processing@footnote{Some implementations may find it suitable to
encode certain meta-information in comments however.}.

Text enclosed between @code{/*} and @code{*/} sequences conforms a
possibly multi-line comment, and is usually processed and removed by
the lexical analyzer, as it isn't intended to be preserved for
subsequent processing.

@b{R-LEX-00}: Multi-line comments can't be nested.

Characters following @code{//}, up to the next newline character or
end of file, conform a partial line comment.

@b{R-LEX-01}: Partial-line comments can be stacked.

@section Identifiers

@section Reserved Words

Certain character sequences look like identifiers, but they conform
other tokens.  These sequences are known as @dfn{reserved words}, and
can't be used as identifiers in any context.

@b{R-LEX-01}: The PKL reserved words are @code{struct}, @code{else},
@code{while}, @code{if}, @code{sizeof}, @code{defun}, @code{deftype},
@code{defvar}, @code{return}, @code{string}, @code{as} and
@code{__builtin_print__}.

@node The PKL Type System
@chapter The PKL Type System

Static.  (XXX: rationale on why static.)

Probably sound, but not proven (yet).  The proof should be done by
induction, on the poke expressions tree.

Not complete.  Three possibilities: a) sound type system, b) complete
type system or c) both sound and complete and the type checker many
never terminate.  We choose a).

The PKL type system establishes the rules to be applied in order to
determine the type of many different language constructs.  This
chapter contains an exhaustive relation of these rules.  A conforming
implementation should check for all of these, emitting errors in case
some rule is violated.

@section Type Expressions and Type Specifiers

While discussing the type system, we will be using two different but
certainly related concepts: @dfn{type expressions} and @dfn{type
specifiers}.

A @dfn{type expression} is an abstract representation of a type, such
as @code{integer (32, 0)}, that denotes an unsigned 32-bit integral
type.  The syntax we use for type expressions doesn't equal the
concrete syntax of PKL, and is often more general.

A @dfn{type specifier} is the PKL concrete syntactic construction to
denote a type, such as @code{int<32>}, which is a type specifier
denoting an unsigned 32-bit integral type.

As we shall see, type specifiers sometimes contain additional
information that is not kept in the corresponding type expression.
For example, @code{int[3]} is a valid array type specifier in certain
contexts, but the corresponding type expression is @code{array
(integer (3,1))}.  In this case, the @code{3} in the type specifier,
that denotes the number of elements of the array, is not part of the
type expression.

Type expressions are useful to reason about types and their
properties, such as type equivalence.  However, it is important to
keep in mind that they are not language constructions.

@section Type Expressions

PKL type expressions are structured, and are defined as follows.

A @dfn{basic type constructor}, maybe applied to some arguments, is a
type expression, and constructs basic types.  Basic type constructors
include:

@itemize @bullet
@item Integers.

If @var{size} is a constant expression evaluating to a positive
integer and @var{sign} is a constant expression evaluating to a
boolean, then:

@example
integer (@var{size}, @var{sign})
@end example

is a type expression denoting an integer of width @var{size} bits and
signedness @var{sign}.

Examples:

@itemize
@item @code{integer (32, 1)} denotes a signed 32-bit integer type.
@item @code{integer (13, 1)} denotes a signed 13-bit integer type.
@item @code{integer (64, 0)} denotes an unsigned 64-bit integer type.
@item @code{integer (4, 0)} denotes an unsigned 4-bit integer ("nibble").
@end itemize

@item Strings.

@code{string} is a type expression denoting a NULL-terminated string.

@item The @code{void} type.

@code{void} is a type expression denoting the absence of a type.  It
is used for functions that do not return a value.
@end itemize

A @dfn{type constructor}, applied to type expressions, is a type
expression.  Type constructors include:

@itemize
@item Offsets.

If @var{t} is a basic integral type expression and @var{u} is a constant
expression evaluating to a non-negative integer, then @code{offset (@var{t},@var{u})}
denotes an "united" magnitude having type @var{t} and multiple of the basic
unit @var{u}.

Examples:

@itemize
@item
@code{offset (integer (32, 1), 8)} denotes a signed 32-bit offset with
unit 8 (bytes).
@item
@code {offset (integer (32, 1), 7 + 1)} denotes the same type.
@item
@code{offset (integer (64, 0), 1)} denotes an unsigned 64-bit offset
with unit 1 (bits).
@end itemize

@item Arrays.

If @var{t} is a type expression, @code{array (@var{t})} is a type
expression denoting the type of an array with zero or more elements of
type @var{t}.

Examples:

@example
array (integer (32, 1))  -> Array of signed 32-bit integrals.
array (offset (integer (32, 1) ,8))
                               -> Array of signed 32-bit offsets with
                                  unit bytes.
@end example

Note that array types do not include a number of elements.  When
something like this is found in a struct type definition:

@example
struct
@{
   int num;
   Packet[num] packets;
@};
@end example

the type of @code{packets} is @code{array (Packet)}, and @code{num} is
used in the struct constructor to create the @emph{value} of the
array.  Likewise, in:

@example
defvar a = [1,2,3];
@end example

the type of @code{a} is @code{array (integer (32, 1))}, and it's size
is @code{3}.
 
In function definitions, it is not allowed to specify a size for an
array argument, thus, this is @emph{not} allowed:

@example
defun foo = (int[3] a) @{ ... @}
@end example

Ditto for casts to arrays.  The following is @emph{not} allowed:

@example
array as int[32]
@end example

@item Structs.

If @var{n} is a string, @var{ln} are strings, @var{tn} are type
expressions, and @var{field} is an expression like:

@example
field (@var{l1}, @var{t1})
@end example

then

@example
struct (@var{n}, @var{field1}, ..., @var{fieldm})
@end example

is a type expression denoting a struct type having name @var{n} and @var{m}
fields, each featuring a field name @var{li} and a type @var{ti}.
  
The strings @var{n} and @var{li} can be @code{NULL}, meaning the
structure type is anonymous and that the corresponding struct fields
are anonymous, respectively.

@item Unions.

      XXX

@item Functions.

If @var{tn} are type expressions, `function (@var{t0}, @var{t1},
@var{t2},..., @var{tm})' is a type expression denoting the type of a
function getting @var{m} arguments of the given types, and returning a
value of type @var{t0}.

Note that @var{t0} should be @code{void} for functions that do not
return a value.

@end itemize

Poke uses graphs (XXX: trees or dags?) to represent type expressions,
where interior nodes are type constructors, and leaves are basic type
constructors.

Note that type names, by themselves, do not constitute type
expressions.  However they can be part of some type constructor, like
in structs and unions.

@section Cycles in Type Expressions

PKL imposes the restriction that no type can be referred by name
before it is declared.  Therefore, it is not possible to define
recursive types and the graphs used to implement type expressions
can't have cycles.

@section Type Equivalence

The checking rules described below uses the notion of equality among
type expressions: "if T1 and T2 are equal".

@b{R-TYPE-00}: PKL uses structural equivalence for all types, but for
struct and union types, which are compared by name.

Note however that not all the components of the type expressions are
used in the equivalence rules.  The structural equivalence algorithm
implements some modified notions of equivalence.  For example, two
array types are equivalent even if they have a different number of
elements defined in their type expression.

Structural equivalence rules:

@example
IF T1.type = string AND T2.type = string
   RETURN true;
IF T1.type = int<s1> AND T2.type = int<s2>
   RETURN s1 == s2;
ELIF T1.type = uint<s1> AND T2.type = uint<s2>
   RETURN s1 == s2;
ELIF T1.type = offset<t1,u1> AND T2.type = offset<t2,u2>
   RETURN t1 EQUAL t2 AND u1 == u2
ELIF T1.type = t11 x t12 AND T2.type = t21 x t22
   RETURN t11 EQUAL t21 AND t12 EQUAL t22
ELIF T1.type = t1[] AND T2.type = t2[]
   RETURN t1 EQUAL t2
ELIF T1.type = struct @{name=n1@} AND T2.type = struct @{name=n2@}
   RETURN n1 == n2
ELIF T1.type = union @{name=n1@} AND T2.type = union @{name=n2@}
   RETURN n1 == n2
ELIF T1.type = (T11, ..., T1n) : T10 AND T2.type = (T21, .., T2n) : T20
   RETURN T10 EQUAL T20 AND (T11 EQUAL T21 AND ... T1n EQUAL T2n)
@end example
    
The PKL compiler function @code{pkl_ast_type_equal} implements the
equivalence rules described above.

Anonymous struct and union types are never equivalent to any union type,
not even to themselves, thus:

@example
defvar s = @{.foo=10,.bar=20@};
s = @{.foo=30,.bar=40@};  /* Type error.  */
@end example

@section Overloading of Operators

Certain PKL operators are overloaded.  Example, addition.

However, the overloading of operators in PKL are carefully designed
in a way it is always possible to infer the type of the result of the
operator (maybe a partial type) based on the types of the arguments.
This means no additional top-down pass to narrow types is ever
necessary.  For example:

@example
int<N> + int<N> -> int<N>          @r{is defined}.
int<N> + int<N> -> int<N*2>        @r{is NOT defined}.
@end example

@section Type Checking of Expressions

@noindent
R-TYPE-02: The type of the Nth actual parameter passed in a function
call should match the type of the Nth formal argument defined in the
function type of the function being called.

@section Type Checking of Statements

In PKL statements do not have types, but expressions can appear in
certain statements, and the types of these expressions are checked
according to the following rules.

@b{R-TYPE-01}: The type of the expression in the right-hand side of an
assignment statement should match the type of the variable in the
left-hand side.

@b{R-TYPE-03}: Record and union type specifiers are only allowed in
deftype constructions and embedded in other struct and union type
specifiers.  In particular, these specifiers are not allowed in
function argument lists and casts.

@b{R-TYPE-04}: The type of the expression in the condition part of a
conditional statement should be an integral type, suitable to be
promoted to a signed 32-bit integer.

@b{R-TYPE-05}: The type of the expression in the condition part of a
while statement should be an integral type, suitable to be promoted to
a signed 32-bit integer.

@b{R-TYPE-06}: The type of the expression in an expression statement
should be @code{void}, i.e. a call to a function that doesn't return
any value.

@section Type Checking of Type Specifiers

As described above, type constructors may contain other types, either
directly or indirecly.

An example of a direct type inclusion is the type of the elements
specified in an array type constructor.  An example of an indirect
type is the type of the constant expression denoting the units in an
offset type constructor.

Thus the PKL type system also includes checks for these contained
types and are listed below.

@b{R-TYPE-07}: An array type specifier may contain an expression
denoting the number of elements it contains, but only when it appears
in a field in a struct type.  Thus, @code{struct @{int[10] foo;@}} is
valid, but @code{defun foo = (int[10] a) @{...@}} isn't.

@b{R-TYPE-08}: The type of the expression denoting the number of
elements in an array type constructor should be suitable to be
promoted to an @code{uint<64>}.  (See promotion rules in XXX xref).

@b{R-TYPE-09}: The expression denoting the number of elements in an
array should be constant.

@b{R-TYPE-10}: The base type of an offset type should be an integral
type.  Thus, @code{offset<string,1>} is not valid.

@b{R-TYPE-11}: The type of the expression denoting the unit of an
offset type specifier should be suitable to be promoted to an
@code{uint<64>}.

@b{R-TYPE-12}: The type of the expression denoting the unit of an
offset type specifier should be constant.

@section Type Promotion

XXX document promotion rules here.

@node Future Extensions
@chapter Future Extensions

@section Future Extensions to the Type System

The idea is to evolve the type system, in subsequent versions, in a
backwards-compatible way:

@itemize @bullet
@item
Support for recursive types.  It may be useful, although binary file
formats are seldom defined in a recursive way.

@item
Variable types, eg. @code{int<@var{exp}>} where @var{exp} is not constant.

@item
Evolve into a kind of gradual typing, to provide more dynamism while
keeping the control and efficiency associated with static typing.
@end itemize

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
