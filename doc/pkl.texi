\input texinfo
@comment %**start of header
@setfilename pkl.info
@settitle Pkl: The Poke Language
@afourpaper
@comment %**end of header

@copying
Copyright @copyright{} 2018 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Languages
@direntry
* pkl: (pkl). The Poke Language specification
@end direntry

@titlepage
@title Pkl: The Poke Language
@subtitle Version 1
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Pkl: The Poke Language

@insertcopying
@end ifnottex

@c   Introduction
@c       About this Document
@c       Source Encoding and Character Set
@c       Comments
@c   Data Types
@c       Type Specifiers
@c       Integer Type
@c       String Type
@c       Struct Type
@c       Union Type
@c       Array Type
@c       Type Equivalence
@c       Type Attributes
@c       Declaration of Types
@c   Integers
@c       Integer Literals
@c       Comparison of Integers
@c       Arithmetic Operations
@c       Bitwise Operations
@c       Integer Attributes
@c   Strings
@c       String Literals
@c       Comparison of Strings
@c       String Formatting
@c       String Attributes
@c   Structs and Unions
@c       Fields
@c       Anonymous Fields
@c       Flattening
@c       Unions
@c       Conditional Fields
@c       Field Constraints
@c       Struct Literals
@c       Struct and Union Arguments
@c       Struct and Union Attributes
@c   Arrays
@c       Array Literals
@c       Array Attributes
@c   Sets
@c       Enumerations
@c       Bitmasks
@c       Set Attributes
@c   Control Structures  (Conditionals and loops)
@c       Statements
@c       Conditionals
@c       Iteration
@c   Variables
@c       Variable Scope
@c       Declaration of Variables
@c   Functions
@c       Declaration of Functions
@c   Mapping  (Accessing the IO space)
@c   Searching and Patterns
@c   Modules and Files
@c   The Pkl Standard Library
@c       Standard Types

@menu
* Introduction::	Introduction and conventions used.
* Data Types::
* Structs and Unions::
@c * Grammar
* Future Extensions::

* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@c XXX add a rule index.
@end menu

@node Introduction
@chapter Introduction

@dfn{Pkl} is a domain-specific programming language whose main purpose
is to manipulate structured binary data.  It is used in @code{poke},
the GNU interactive editor for binary files.  The name Pkl standas for
``Poke Language'' and it is pronounced ``pickle''@footnote{Much like
Tcl is pronounced ``tickle'' ;)}.

@menu
* About this Document::		What this document is and what it isn't.
* Source Files::                Source Encoding and Character Set.
* Comments::			Comments and their formatting conventions.
@end menu

@node About this Document
@section About this Document

This document contains a complete and semi-formal specification of
Pkl, describing all the aspects of the language.  The main purpose of
the specification is to serve as a reference for both users and
implementors.

This document is not intended to be a tutorial for learning how to
write Pkl programs.  For that purpose, please read the Poke Book. XXX:
xref to the poke book.

@node Source Files
@section Source Files

Pkl source text shall be encoded in @acronym{ASCII} (ISO-646) and
covers the @acronym{ASCII} character set.

Source code lines are separated by the @dfn{newline character},
@acronym{ASCII} code @code{012}.

@node Comments
@section Comments

Pkl supports two different kind of comments: multi-line non-nestable
comments and partial-line stackable comments.

Text enclosed between @code{/*} and @code{*/} sequences conforms a
possibly multi-line comment.  This is an example:

@example
/* This is a comment that spans
   through several lines.  */
@end example

Multi-line comments can't be nested.  Thus, the following is not
syntactically correct:

@example
/* This is /* not */ correct!  */
@end example

Characters following @code{//}, up to the next newline character or
end of file, conform a partial line comment.  These kind of comments
can be stacked.  The following are valid comments:

@example
// This is a one line comment.
// This is a stacked // comment.
@end example

Both nestable and non-nestable comments comments are usually processed
and removed by the lexical analyzer, as these are not intended to be
preserved for subsequent processing@footnote{Some implementations may
find it suitable to encode certain meta-information in comments
however.}.

@section Identifiers

@b{R-LEX-02}: A letter (uppercase or lowercase) or an underscore
(@acronym{ASCII} code 137) followed by zero or more letters (uppercase
or lowercase), underscore characters, or digits conform an
@dfn{identifier}.

The semantic payload of identifiers is the sequence of characters
conforming the token.

@section Reserved Words

Certain character sequences look like identifiers, but they conform
other tokens.  These sequences are known as @dfn{reserved words}, and
can't be used as identifiers in any context.

@b{R-LEX-01}: The Pkl reserved words are @code{struct}, @code{else},
@code{while}, @code{if}, @code{sizeof}, @code{defun}, @code{deftype},
@code{defvar}, @code{return}, @code{string}, @code{as} and
@code{__builtin_print__}.

@section Numeric Literals

Numeric literals allow to express numbers of several characteristics,
like width and numeration base.

@b{R-LEX-02}: @dfn{Decimal numeric literals} are denoted by a digit
followed by zero or more digits or underscores (@acronym{ASCII} code
137), followed by an optional suffix string.

@b{R-LEX-03}: @dfn{Hexadecimal numeric literals} are denoted by the
sequence @code{0x} or @code{0X} followed by an @dfn{hexadecimal digit}
(@code{[0-9fA-F]}), followed by zero or more hexadecimal digits or
underscores, followed by an optional suffix string.

@b{R-LEX-04}: @dfn{Octal numeric literals} are denoted by the sequence
@code{0o} or @code{0O} followed by an @dfn{octal digit} (@code{[0-7]}),
followed by zero or more octal digits or underscores, followed by an
optional suffix string.

@b{R-LEX-05}: @dfn{Binary numeric literals} are denoted by the
sequence @code{0b} or @code{0B} folloed by a @dfn{binary digit}
(@code{[01]}), followed by zero or more binary digits or underscores,
followed by an optional suffix argument.

The underscores in numeric literals are intended to increase
readability, and do not contribute to the semantic value of the token.

The optional suffix allowed in numeric literals are composed by
sequences of characters, which characterize the number. The allowed
characters are:

@table @code
@item u
@itemx U
The numeric literal is unsigned.
@item n
@item N
The numeric literal is a @dfn{nibble}, i.e. it is 4-bit long.
@item B
The numeric literal is a @dfn{byte}, i.e. it is 8-bit long.
@item h
@itemx H
The numeric literal is a @dfn{half}, i.e. it is 16-bit long.
@item l
@item L
The numeric literal is a @dfn{long}, i.e. it is 64-bit long.
@end table

Not every combination of suffix characters makes sense.  Well-formed
numeric literal suffixes are characterized by the regular expression
@code{((u|U)|(u|U)?(l|L|B|h|H|n|N)|(l|L|B|h|H|n|N)(u|U))}.

If not explicitly specified with one of the @code{l}, @code{L},
@code{B}, @code{h} or @code{H} suffixes, the width of an integer
constant is the smallest signed or unsigned integer capable of holding
it, starting with 32 bits, in steps of power of two and up to 64 bits.

@section Character Literals

There is another way to express unsigned 8-bit integers, which is to
use a @dfn{character literal}.  Character literals are delimited by
@code{'} characters, and contain a representation of an
@acronym{ASCII} character.  The value of the resulting integer is the
code of the represented @acronym{ASCII} character in the
@acronym{ASCII}s 7-bit encoding.

The representation of a printable character is the printable
representation of the character itself.  For example, @code{'a'}
represents the integer @code{97}.

The representation of non-printable characters use escape sequences
instead, which are listed in the following table.

@table @code
@item '\NNN'
Character with octal code @code{NNN}.  The number can feature one, two
or three digits, but no more.  Example: @code{\0} is the @code{NULL}
character.
@item '\t'
Tab (@acronym{ASCII} @code{0x9}).
@item '\n'
Newline character (@acronym{ASCII} @code{0xa}).
@end table

@section String Literals

String literals allow to express sequences of characters, implicitly
finished by the @dfn{NULL character} or @code{'\0'}.  The contents of
a string literal are enclosed between @code{"} characters.

The @dfn{empty string}, which features only the implicit finishing
@code{'\0'}, is denoted as @code{""}.

The representation of printable ASCII characters in a string is the
printable representation of the characters themselves.  For example,
@code{"abc"} is a string composed by the characters @code{'a'},
@code{'b'}, @code{'c'} and @code{'\0'}.

The representation of non-printable characters within the string use
escape sequences instead, which are listed in the following table.

@table @code
@item \\
Represents the @code{\} character.
@item \n
Newline character (@acronym{ASCII} @code{0xa}).
@item \t
Tab (@acronym{ASCII} @code{0x9}).
@end table

@c XXX @section Formatted String Literals

@node Data Types
@chapter Data Types

Static.  (XXX: rationale on why static.)

Probably sound, but not proven (yet).  The proof should be done by
induction, on the poke expressions tree.

Not complete.  Three possibilities: a) sound type system, b) complete
type system or c) both sound and complete and the type checker many
never terminate.  We choose a).

The Pkl type system establishes the rules to be applied in order to
determine the type of many different language constructs.  This
chapter contains an exhaustive relation of these rules.  A conforming
implementation should check for all of these, emitting errors in case
some rule is violated.

@section Type Expressions and Type Specifiers

While discussing the type system, we will be using two different but
certainly related concepts: @dfn{type expressions} and @dfn{type
specifiers}.

A @dfn{type expression} is an abstract representation of a type, such
as @code{integer (32, 0)}, that denotes an unsigned 32-bit integral
type.  The syntax we use for type expressions doesn't equal the
concrete syntax of Pkl, and is often more general.

A @dfn{type specifier} is the Pkl concrete syntactic construction to
denote a type, such as @code{int<32>}, which is a type specifier
denoting an unsigned 32-bit integral type.

As we shall see, type specifiers sometimes contain additional
information that is not kept in the corresponding type expression.
For example, @code{int[3]} is a valid array type specifier in certain
contexts, but the corresponding type expression is @code{array
(integer (3,1))}.  In this case, the @code{3} in the type specifier,
that denotes the number of elements of the array, is not part of the
type expression.

Type expressions are useful to reason about types and their
properties, such as type equivalence.  However, it is important to
keep in mind that they are not language constructions.

@section Type Expressions

Pkl type expressions are structured, and are defined as follows.

A @dfn{basic type constructor}, maybe applied to some arguments, is a
type expression, and constructs basic types.  Basic type constructors
include:

@itemize @bullet
@item Integers.

If @var{size} is a constant expression evaluating to a positive
integer and @var{sign} is a constant expression evaluating to a
boolean, then:

@example
integer (@var{size}, @var{sign})
@end example

is a type expression denoting an integer of width @var{size} bits and
signedness @var{sign}.

Examples:

@itemize
@item @code{integer (32, 1)} denotes a signed 32-bit integer type.
@item @code{integer (13, 1)} denotes a signed 13-bit integer type.
@item @code{integer (64, 0)} denotes an unsigned 64-bit integer type.
@item @code{integer (4, 0)} denotes an unsigned 4-bit integer ("nibble").
@end itemize

@item Strings.

@code{string} is a type expression denoting a NULL-terminated string.

@item The @code{void} type.

@code{void} is a type expression denoting the absence of a type.  It
is used for functions that do not return a value.
@end itemize

A @dfn{type constructor}, applied to type expressions, is a type
expression.  Type constructors include:

@itemize
@item Offsets.

If @var{t} is a basic integral type expression and @var{u} is a constant
expression evaluating to a non-negative integer, then @code{offset (@var{t},@var{u})}
denotes an "united" magnitude having type @var{t} and multiple of the basic
unit @var{u}.

Examples:

@itemize
@item
@code{offset (integer (32, 1), 8)} denotes a signed 32-bit offset with
unit 8 (bytes).
@item
@code {offset (integer (32, 1), 7 + 1)} denotes the same type.
@item
@code{offset (integer (64, 0), 1)} denotes an unsigned 64-bit offset
with unit 1 (bits).
@end itemize

@item Arrays.

If @var{t} is a type expression, @code{array (@var{t})} is a type
expression denoting the type of an array with zero or more elements of
type @var{t}.

Examples:

@example
array (integer (32, 1))  -> Array of signed 32-bit integrals.
array (offset (integer (32, 1) ,8))
                               -> Array of signed 32-bit offsets with
                                  unit bytes.
@end example

Note that array types do not include a number of elements.  When
something like this is found in a struct type definition:

@example
struct
@{
   int num;
   Packet[num] packets;
@};
@end example

the type of @code{packets} is @code{array (Packet)}, and @code{num} is
used in the struct constructor to create the @emph{value} of the
array.  Likewise, in:

@example
defvar a = [1,2,3];
@end example

the type of @code{a} is @code{array (integer (32, 1))}, and it's size
is @code{3}.
 
In function definitions, it is not allowed to specify a size for an
array argument, thus, this is @emph{not} allowed:

@example
defun foo = (int[3] a) @{ ... @}
@end example

Ditto for casts to arrays.  The following is @emph{not} allowed:

@example
array as int[32]
@end example

@item Structs.

If @var{n} is a string, @var{ln} are strings, @var{tn} are type
expressions, and @var{field} is an expression like:

@example
field (@var{l1}, @var{t1})
@end example

then

@example
struct (@var{n}, @var{field1}, ..., @var{fieldm})
@end example

is a type expression denoting a struct type having name @var{n} and @var{m}
fields, each featuring a field name @var{li} and a type @var{ti}.
  
The strings @var{n} and @var{li} can be @code{NULL}, meaning the
structure type is anonymous and that the corresponding struct fields
are anonymous, respectively.

@item Unions.

      XXX

@item Functions.

If @var{tn} are type expressions, `function (@var{t0}, @var{t1},
@var{t2},..., @var{tm})' is a type expression denoting the type of a
function getting @var{m} arguments of the given types, and returning a
value of type @var{t0}.

Note that @var{t0} should be @code{void} for functions that do not
return a value.

@end itemize

Poke uses graphs (XXX: trees or dags?) to represent type expressions,
where interior nodes are type constructors, and leaves are basic type
constructors.

Note that type names, by themselves, do not constitute type
expressions.  However they can be part of some type constructor, like
in structs and unions.

@section Cycles in Type Expressions

Pkl imposes the restriction that no type can be referred by name
before it is declared.  Therefore, it is not possible to define
recursive types and the graphs used to implement type expressions
can't have cycles.

@section Type Equivalence

The checking rules described below uses the notion of equality among
type expressions: "if T1 and T2 are equal".

@b{R-TYPE-00}: Pkl uses structural equivalence for all types, but for
struct and union types, which are compared by name.

Note however that not all the components of the type expressions are
used in the equivalence rules.  The structural equivalence algorithm
implements some modified notions of equivalence.  For example, two
array types are equivalent even if they have a different number of
elements defined in their type expression.

Structural equivalence rules:

@example
IF T1.type = string AND T2.type = string
   RETURN true;
IF T1.type = int<s1> AND T2.type = int<s2>
   RETURN s1 == s2;
ELIF T1.type = uint<s1> AND T2.type = uint<s2>
   RETURN s1 == s2;
ELIF T1.type = offset<t1,u1> AND T2.type = offset<t2,u2>
   RETURN t1 EQUAL t2 AND u1 == u2
ELIF T1.type = t11 x t12 AND T2.type = t21 x t22
   RETURN t11 EQUAL t21 AND t12 EQUAL t22
ELIF T1.type = t1[] AND T2.type = t2[]
   RETURN t1 EQUAL t2
ELIF T1.type = struct @{name=n1@} AND T2.type = struct @{name=n2@}
   RETURN n1 == n2
ELIF T1.type = union @{name=n1@} AND T2.type = union @{name=n2@}
   RETURN n1 == n2
ELIF T1.type = (T11, ..., T1n) : T10 AND T2.type = (T21, .., T2n) : T20
   RETURN T10 EQUAL T20 AND (T11 EQUAL T21 AND ... T1n EQUAL T2n)
@end example

@c XXX move this paragraph to the pokeint manual.
The Pkl compiler function @code{pkl_ast_type_equal} implements the
equivalence rules described above.

Anonymous struct and union types are never equivalent to any union type,
not even to themselves, thus:

@example
defvar s = @{.foo=10,.bar=20@};
s = @{.foo=30,.bar=40@};  /* Type error.  */
@end example

@section Overloading of Operators

Certain Pkl operators are overloaded.  For example, addition is
supported for integer types of any type, and also for strings.

However, the overloading of operators in Pkl are carefully designed in
a way it is always possible to infer the type of the result of the
operator based on the types of the arguments.

This means it is possible for an implementation to perform type
checking of expressions in a single pass, using synthetized attributes
only.  No second top-down pass to narrow types is ever necessary.

For example:

@example
int<N> + int<N> -> int<N>          @r{is defined}.
int<N> + int<N> -> int<N*2>        @r{is NOT defined}.
@end example

@section Type Checking of Expressions

R-TYPE-02: The type of the Nth actual parameter passed in a function
call should match the type of the Nth formal argument defined in the
function type of the function being called.

@section Type Checking of Statements

In Pkl statements do not have types, but expressions can appear in
certain statements, and the types of these expressions are checked
according to the following rules.

@b{R-TYPE-01}: The type of the expression in the right-hand side of an
assignment statement should match the type of the variable in the
left-hand side.

@b{R-TYPE-03}: Record and union type specifiers are only allowed in
deftype constructions and embedded in other struct and union type
specifiers.  In particular, these specifiers are not allowed in
function argument lists and casts.

@b{R-TYPE-04}: The type of the expression in the condition part of a
conditional statement should be an integral type, suitable to be
promoted to a signed 32-bit integer.

@b{R-TYPE-05}: The type of the expression in the condition part of a
while statement should be an integral type, suitable to be promoted to
a signed 32-bit integer.

@b{R-TYPE-06}: The type of the expression in an expression statement
should be @code{void}, i.e. a call to a function that doesn't return
any value.

@section Type Checking of Type Specifiers

As described above, type constructors may contain other types, either
directly or indirecly.

An example of a direct type inclusion is the type of the elements
specified in an array type constructor.  An example of an indirect
type inclusion is the type of the constant expression denoting the
units in an offset type constructor.

Thus the Pkl type system also includes checks for types contained in
type expressions, and these are listed below.

@b{R-TYPE-07}: An array type specifier may contain an expression
denoting the number of elements it contains, but only when it appears
in a field in a struct type.  Thus, @code{struct @{int[10] foo;@}} is
valid, but @code{defun foo = (int[10] a) @{...@}} isn't.

@b{R-TYPE-08}: The type of the expression denoting the number of
elements in an array type constructor should be suitable to be
promoted to an @code{uint<64>}.  (See promotion rules in XXX xref).

@b{R-TYPE-09}: The expression denoting the number of elements in an
array should be constant.  (See constant expressions in XXX xref).

@b{R-TYPE-10}: The base type of an offset type should be an integral
type.  For example, @code{offset<string,1>} is not valid.

@b{R-TYPE-11}: The type of the expression denoting the unit of an
offset type specifier should be suitable to be promoted to an
@code{uint<64>}.

@b{R-TYPE-12}: The type of the expression denoting the unit of an
offset type specifier should be constant.

@section Type Promotion

XXX document promotion rules here.

@node Structs and Unions
@chapter Structs and Unions

@section Flattening

Useful idiom: a struct containing common fields can be defined and
used as a flattening inside the union alternatives.  The type
@code{packet_epilogue} is not visible from outside the union.

@example
deftype Packet =
  union
  @{
    deftype PacketEpilogue = struct @{ uint32 quux; @};

    struct
    @{
      uint32 type = 0x0;
      byte[1024] data;
      PacketEpilogue;
    @} audio;

    struct
    @{
      uint32 type = 0x1;
      byte[2048] data;
      PacketEpilogue;
    @} video;
  @};
@end example

The desugared version of a conditional struct field is a flattened
union with an empty alternative.

@example
deftype foo =
  struct
  @{
    int f1;
    int f2 if f1 > 0;
  @};
@end example

@noindent
is equivalent to

@example
deftype foo =
  struct
  @{
    int f1;
    union
    @{
      int f2 : f1 > 0;
      struct @{@};
    @};
  @};
@end example

@noindent
Flattened structs can also be conditional:

@example
deftype foo =
  struct
  @{
    int f1;
    struct
    @{
      int f2;
      int f3;
    @} if f1 > 0;
  @};
@end example

@noindent
is equivalent to

@example
deftype foo =
  struct
  @{
    int f1;
    union
    @{
      struct @{ int f2; int f3; @} : f1 > 0;
      struct @{@};
    @};
  @};
@end example

@noindent
Video file example.

@example
deftype vfile = tag [];

deftype Tag =
  union
  @{
    deftype TagCommon =
      struct
      @{
        int flags;
        int reserved;
      @};
    
    struct
    @{
      int tag_type = TAG_VIDEO;
      TagCommon;
      uint64 time;
      byte[1024] data;
    @} video;

    struct
    @{
      int tag_type = TAG_SCRIPT;
      TagCommon;
      string code;
    @} script;

    struct
    @{
      int tag_type = TAG_NULL;
      TagCommon = @{ .flags = 0, .reserved = 0 @};
    @} null;
  @};
@end example
  
Compare the above with the following version where flattening is not
used at all.  The type `tag' is changed to a struct and an additional
union is nested, very C-like.

@example
deftype Tag =
  struct
  @{
    int tag_type;
    int flags;
    int reserved;

    union
    @{
      struct
      @{
        uint64 time;
        byte[1024] data;
      @} video : tag_type == TAG_VIDEO;

      struct
      @{
        string code;
      @} script : tag_type == TAG_SCRIPT;

      struct
      @{
      @} null : tag_type = TAG_NULL;
      
    @} data;
  @};
@end example

@c XXX
@noindent
Flattening also works with enums.

@example
deftype relocs =
  enum <int> (int mach)
  @{
    enum <int>
    @{
      R_SPARC_FOO = 1,
      R_SPARC_BAR = 2
    @} if mach == SPARC;

    enum <int>
    @{
      R_ALPHA_FOO = 1,
      R_ALPHA_BAR = 2
    @} if mach == ALPHA;
  @};
@end example

@node Future Extensions
@chapter Future Extensions

@section Future Extensions to the Type System

The idea is to evolve the type system, in subsequent versions, in a
backwards-compatible way:

@itemize @bullet
@item
Support for recursive types.  It may be useful, although binary file
formats are seldom defined in a recursive way.

@item
Variable types, eg. @code{int<@var{exp}>} where @var{exp} is not constant.

@item
Evolve into a kind of gradual typing, to provide more dynamism while
keeping the control and efficiency associated with static typing.
@end itemize

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
