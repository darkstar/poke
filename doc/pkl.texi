\input texinfo
@comment %**start of header
@setfilename pkl.info
@settitle Pkl Reference Manual
@afourpaper
@comment %**end of header

@copying
Copyright @copyright{} 2019 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Languages
@direntry
* pkl: (pkl). Pkl Reference Manual
@end direntry

@titlepage
@title Pkl Reference manual
@subtitle Version 1
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Pkl Reference Manual

@insertcopying
@end ifnottex

@c   Introduction
@c       About this Document
@c       Source Encoding and Character Set
@c       Comments
@c   Data Types (XXX: in this chapter literals are used, but are explained in detail later)
@c       Type Constructors
@c       Declaration of Types
@c       Integer Type
@c       String Type
@c       Struct and Union Types
@c       Array Type
@c       Type Equivalence
@c       Type Attributes
@c   Integers
@c       Integer Literals
@c       Comparison of Integers
@c       Arithmetic Operations
@c       Bitwise Operations
@c       Integer Attributes
@c   Strings
@c       String Literals
@c       Comparison of Strings
@c       String Formatting
@c       String Attributes
@c   Structs and Unions
@c       Fields
@c       Anonymous Fields
@c       Flattening
@c       Unions
@c       Conditional Fields
@c       Field Constraints
@c       Struct Literals
@c       Struct and Union Arguments
@c       Struct and Union Attributes
@c   Arrays
@c       Array Literals
@c       Array Attributes
@c   Sets
@c       Enumerations
@c       Bitmasks
@c       Set Attributes
@c   Control Structures  (Conditionals and loops)
@c       Statements
@c       Conditionals
@c       Iteration
@c   Variables
@c       Variable Scope
@c       Declaration of Variables
@c   Functions
@c       Declaration of Functions
@c   Mapping  (Accessing the IO space)
@c   Searching and Patterns
@c   Modules and Files
@c   The Pkl Standard Library
@c       Standard Types

@menu
* Introduction::	Introduction and conventions used.
* Data Types::		Data types of values.
* Structs and Unions::
@c * Grammar
* Future Extensions::

* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@c XXX add a rule index.
@end menu

@node Introduction
@chapter Introduction

@dfn{Pkl} is a domain-specific programming language whose main purpose
is to manipulate structured binary data.  It is used in @code{poke},
the GNU interactive editor for binary files.  The name Pkl stands for
``Poke Language'' and it is pronounced ``pickle''@footnote{Much like
Tcl is pronounced ``tickle'' ;)}.

@menu
* About this Document::		What this document is and what it isn't.
* Source Files::                Source Encoding and Character Set.
* Comments::			Comments and their formatting conventions.
@end menu

@node About this Document
@section About this Document

This document contains a complete and semi-formal specification of
Pkl, describing all the aspects of the language.  The main purpose of
the specification is to serve as a reference for both users and
implementors.

This document is not intended to be a tutorial for learning how to
write Pkl programs.  For that purpose, please read the Poke Book. XXX:
xref to the poke book.

@node Source Files
@section Source Files

Pkl source text shall be encoded in @acronym{ASCII} (ISO-646) and
covers the @acronym{ASCII} character set.

Source code lines are separated by the @dfn{newline character},
@acronym{ASCII} code @code{012}.

@node Comments
@section Comments

Pkl supports two different kind of comments: multi-line non-nestable
comments and partial-line stackable comments.

Text enclosed between @code{/*} and @code{*/} sequences conforms a
possibly multi-line comment.  This is an example:

@example
/* This is a comment that spans
   through several lines.  */
@end example

Multi-line comments can't be nested.  Thus, the following is not
syntactically correct:

@example
/* This is /* not */ correct!  */
@end example

Characters following @code{//}, up to the next newline character or
end of file, conform a partial line comment.  These kind of comments
can be stacked.  The following are valid comments:

@example
// This is a one line comment.
// This is a stacked // comment.
@end example

Both stackable and non-nestable comments are usually processed and
removed by the lexical analyzer, as these are not intended to be
preserved for subsequent processing@footnote{Some implementations may
find it suitable to encode certain meta-information in comments
however.}.

@c @section Identifiers

@c @b{R-LEX-02}: A letter (uppercase or lowercase) or an underscore
@c (@acronym{ASCII} code 137) followed by zero or more letters (uppercase
@c or lowercase), underscore characters, or digits conform an
@c @dfn{identifier}.

@c The semantic payload of identifiers is the sequence of characters
@c conforming the token.

@c @section Reserved Words

@c Certain character sequences look like identifiers, but they conform
@c other tokens.  These sequences are known as @dfn{reserved words}, and
@c can't be used as identifiers in any context.

@c @b{R-LEX-01}: The Pkl reserved words are @code{struct}, @code{else},
@c @code{while}, @code{if}, @code{sizeof}, @code{defun}, @code{deftype},
@c @code{defvar}, @code{return}, @code{string}, @code{as} and
@c @code{__builtin_print__}.

@c @section Numeric Literals

@c Numeric literals allow to express numbers of several characteristics,
@c like width and numeration base.

@c @b{R-LEX-02}: @dfn{Decimal numeric literals} are denoted by a digit
@c followed by zero or more digits or underscores (@acronym{ASCII} code
@c 137), followed by an optional suffix string.

@c @b{R-LEX-03}: @dfn{Hexadecimal numeric literals} are denoted by the
@c sequence @code{0x} or @code{0X} followed by an @dfn{hexadecimal digit}
@c (@code{[0-9fA-F]}), followed by zero or more hexadecimal digits or
@c underscores, followed by an optional suffix string.

@c @b{R-LEX-04}: @dfn{Octal numeric literals} are denoted by the sequence
@c @code{0o} or @code{0O} followed by an @dfn{octal digit} (@code{[0-7]}),
@c followed by zero or more octal digits or underscores, followed by an
@c optional suffix string.

@c @b{R-LEX-05}: @dfn{Binary numeric literals} are denoted by the
@c sequence @code{0b} or @code{0B} folloed by a @dfn{binary digit}
@c (@code{[01]}), followed by zero or more binary digits or underscores,
@c followed by an optional suffix argument.

@c The underscores in numeric literals are intended to increase
@c readability, and do not contribute to the semantic value of the token.

@c The optional suffix allowed in numeric literals are composed by
@c sequences of characters, which characterize the number. The allowed
@c characters are:

@c @table @code
@c @item u
@c @itemx U
@c The numeric literal is unsigned.
@c @item n
@c @item N
@c The numeric literal is a @dfn{nibble}, i.e. it is 4-bit long.
@c @item B
@c The numeric literal is a @dfn{byte}, i.e. it is 8-bit long.
@c @item h
@c @itemx H
@c The numeric literal is a @dfn{half}, i.e. it is 16-bit long.
@c @item l
@c @item L
@c The numeric literal is a @dfn{long}, i.e. it is 64-bit long.
@c @end table

@c Not every combination of suffix characters makes sense.  Well-formed
@c numeric literal suffixes are characterized by the regular expression
@c @code{((u|U)|(u|U)?(l|L|B|h|H|n|N)|(l|L|B|h|H|n|N)(u|U))}.

@c If not explicitly specified with one of the @code{l}, @code{L},
@c @code{B}, @code{h} or @code{H} suffixes, the width of an integer
@c constant is the smallest signed or unsigned integer capable of holding
@c it, starting with 32 bits, in steps of power of two and up to 64 bits.

@c @section Character Literals

@c There is another way to express unsigned 8-bit integers, which is to
@c use a @dfn{character literal}.  Character literals are delimited by
@c @code{'} characters, and contain a representation of an
@c @acronym{ASCII} character.  The value of the resulting integer is the
@c code of the represented @acronym{ASCII} character in the
@c @acronym{ASCII}s 7-bit encoding.

@c The representation of a printable character is the printable
@c representation of the character itself.  For example, @code{'a'}
@c represents the integer @code{97}.

@c The representation of non-printable characters use escape sequences
@c instead, which are listed in the following table.

@c @table @code
@c @item '\NNN'
@c Character with octal code @code{NNN}.  The number can feature one, two
@c or three digits, but no more.  Example: @code{\0} is the @code{NULL}
@c character.
@c @item '\t'
@c Tab (@acronym{ASCII} @code{0x9}).
@c @item '\n'
@c Newline character (@acronym{ASCII} @code{0xa}).
@c @end table

@c @section String Literals

@c String literals allow to express sequences of characters, implicitly
@c finished by the @dfn{NULL character} or @code{'\0'}.  The contents of
@c a string literal are enclosed between @code{"} characters.

@c The @dfn{empty string}, which features only the implicit finishing
@c @code{'\0'}, is denoted as @code{""}.

@c The representation of printable ASCII characters in a string is the
@c printable representation of the characters themselves.  For example,
@c @code{"abc"} is a string composed by the characters @code{'a'},
@c @code{'b'}, @code{'c'} and @code{'\0'}.

@c The representation of non-printable characters within the string use
@c escape sequences instead, which are listed in the following table.

@c @table @code
@c @item \\
@c Represents the @code{\} character.
@c @item \n
@c Newline character (@acronym{ASCII} @code{0xa}).
@c @item \t
@c Tab (@acronym{ASCII} @code{0x9}).
@c @end table

@c XXX @section Formatted String Literals

@node Data Types
@chapter Data Types

@dfn{Values} are the data objects manipulated by Pkl programs.  They
include numbers, offsets, character strings, structs, arrays, etc.

Every value belongs to one, and only one, type.  Values of the same
type have similar characteristics and may usually be used in the same
contexts.  The type corresponding to a value is unambiguous and well
defined, even if the value is denoted as a literal.  This suites well
the purpose of the language, since the programmer should always be
aware of the storage characteristics of the data being manipulated.

Pkl provides a set of predefined type constructors that the programmer
can use directly.  This includes whole numbers of several different
bit lengths and signedness, and strings.  Also, constructs are
provided to allow the declaration of user-defined types, like structs,
unions and arrays.

This chapter describes generalities about types, an exhaustive list of
supported types, and also elaborates on how to define new types.

@c Static.  (XXX: rationale on why static.)

@c Probably sound, but not proven (yet).  The proof should be done by
@c induction, on the poke expressions tree.

@c The Pkl type system establishes the rules to be applied in order to
@c determine the type of many different language constructs.  This
@c chapter contains an exhaustive relation of these rules.  A conforming
@c implementation should check for all of these, emitting errors in case
@c some rule is violated.

@menu
* Type Constructors::		Defining types.
* Declaration of Types::	Defining named types.
* Integer Types::		Whole numbers.
* Offset Types::                File offsets with units.
* String Type::			Character strings.
* Struct and Union Types::	Collections of Fields.
* Array Types::			Sequences of objects.
* Type Equivalence::		What types are considered equal.
* Type Attributes::		Querying properties of types.
@end menu

@node Type Constructors
@section Type Constructors

A @dfn{type constructor} is a syntax that denotes a type and its
properties.  Depending on the type being denoted, constructors can be
as simple as a single keyword, or be rather complex like a structure
definition spawning several program pages.  Consider for example the
following type constructors:

@example
string
int<32>
offset<uint<16>,8>
struct @{int<32> foo; int<64> bar;@}
uint<8>[]
@end example

The first line in the example above denotes the @dfn{string type}.
Since there is only one string type in Pkl, this constructor doesn't
take any parameter.  Very simple.

The second line denotes the signed 32-bit integer type.  In this case,
a parameter should be passed to the type constructor in order to
specify the number of bits.  Note how @code{<} and @code{>} characters
are used to enclose type constructor parameters.

The third line denotes the offset type with base type unsigned 16-bit
integer and unit 8 bits.  Note how commas (@code{,}) are used to
separate parameters, and how a type (in this case the integer type)
can be passed as a parameter to a constructor.

The fourth line denotes a struct type.  In this case, the constructor
uses a more elaborated syntax, even if this example is actually a
rather simple struct type.

The fifth line denotes an array type, whose elements (values) are of
the unsigned 8-bit integer type.

The following sections discuss type constructors in great detail, for
the several types supported in Pkl.

@node Declaration of Types
@section Declaration of Types

Types can be given names using the @code{deftype} construct:

@example
deftype @var{name} = @var{type_constructor};
@end example

@noindent
declares a new named type with name @var{name}, described by
@var{type_constructor}.  Type names are conformed by a letter or an
underscore character (@code{_}) followed by zero or more letters,
underscore characters or digits.  The type names are case-sensitive.

For example, consider the type declaration:

@example
deftype int = int<32>;
@end example

@noindent
which declares a type named @code{int} as a signed 32-bit integer
type.

Once a named type is declared, it is visible until the end of the
current lexical block (XXX xref see lexical blocks).  It is an error
to declare two types with the same name in the same lexical block.
Types declared in inner lexical blocks can ghost types declared in
outer blocks.

Once a type is declared, its name can be used everywhere a type is
expected.  This includes another @code{deftype}:

@example
deftype another_int = int;
@end example

Note that, whereas a type name can appear everywhere a type
constructor is expected, the inverse is not true: there are places
where a type name is accepted but not a type constructor.  The
following sections identify these contexts.

By convention, CamelCase is used for @code{struct} and @code{union}
types.

@c While discussing the type system, we will be using two different but
@c certainly related concepts: @dfn{type expressions} and @dfn{type
@c specifiers}.

@c A @dfn{type expression} is an abstract representation of a type, such
@c as @code{integer (32, 0)}, that denotes an unsigned 32-bit integral
@c type.  The syntax we use for type expressions doesn't equal the
@c concrete syntax of Pkl, and is often more general.

@c As we shall see, type specifiers sometimes contain additional
@c information that is not kept in the corresponding type expression.
@c For example, @code{int[3]} is a valid array type specifier in certain
@c contexts, but the corresponding type expression is @code{array
@c (integer (3,1))}.  In this case, the @code{3} in the type specifier,
@c that denotes the number of elements of the array, is not part of the
@c type expression.

@c Type expressions are useful to reason about types and their
@c properties, such as type equivalence.  However, it is important to
@c keep in mind that they are not language constructions.

@c @section Type Expressions

@c Pkl type expressions are structured, and are defined as follows.

@c A @dfn{basic type constructor}, maybe applied to some arguments, is a
@c type expression, and constructs basic types.  Basic type constructors
@c include:

@c @itemize @bullet
@c @item Integers.

@c If @var{size} is a constant expression evaluating to a positive
@c integer and @var{sign} is a constant expression evaluating to a
@c boolean, then:

@c @example
@c integer (@var{size}, @var{sign})
@c @end example

@c is a type expression denoting an integer of width @var{size} bits and
@c signedness @var{sign}.

@c Examples:

@c @itemize
@c @item @code{integer (32, 1)} denotes a signed 32-bit integer type.
@c @item @code{integer (13, 1)} denotes a signed 13-bit integer type.
@c @item @code{integer (64, 0)} denotes an unsigned 64-bit integer type.
@c @item @code{integer (4, 0)} denotes an unsigned 4-bit integer ("nibble").
@c @end itemize

@c @item Strings.

@c @code{string} is a type expression denoting a NULL-terminated string.

@c @item The @code{void} type.

@c @code{void} is a type expression denoting the absence of a type.  It
@c is used for functions that do not return a value.
@c @end itemize

@c A @dfn{type constructor}, applied to type expressions, is a type
@c expression.  Type constructors include:

@c @itemize
@c @item Offsets.

@c If @var{t} is a basic integral type expression and @var{u} is a constant
@c expression evaluating to a non-negative integer, then @code{offset (@var{t},@var{u})}
@c denotes an "united" magnitude having type @var{t} and multiple of the basic
@c unit @var{u}.

@c Examples:

@c @itemize
@c @item
@c @code{offset (integer (32, 1), 8)} denotes a signed 32-bit offset with
@c unit 8 (bytes).
@c @item
@c @code {offset (integer (32, 1), 7 + 1)} denotes the same type.
@c @item
@c @code{offset (integer (64, 0), 1)} denotes an unsigned 64-bit offset
@c with unit 1 (bits).
@c @end itemize

@c @item Arrays.

@c If @var{t} is a type expression, @code{array (@var{t})} is a type
@c expression denoting the type of an array with zero or more elements of
@c type @var{t}.

@c Examples:

@c @example
@c array (integer (32, 1))  -> Array of signed 32-bit integrals.
@c array (offset (integer (32, 1) ,8))
@c                                -> Array of signed 32-bit offsets with
@c                                   unit bytes.
@c @end example

@c Note that array types do not include a number of elements.  When
@c something like this is found in a struct type definition:

@c @example
@c struct
@c @{
@c    int num;
@c    Packet[num] packets;
@c @};
@c @end example

@c the type of @code{packets} is @code{array (Packet)}, and @code{num} is
@c used in the struct constructor to create the @emph{value} of the
@c array.  Likewise, in:

@c @example
@c defvar a = [1,2,3];
@c @end example

@c the type of @code{a} is @code{array (integer (32, 1))}, and it's size
@c is @code{3}.
 
@c In function definitions, it is not allowed to specify a size for an
@c array argument, thus, this is @emph{not} allowed:

@c @example
@c defun foo = (int[3] a) @{ ... @}
@c @end example

@c Ditto for casts to arrays.  The following is @emph{not} allowed:

@c @example
@c array as int[32]
@c @end example

@c @item Structs.

@c If @var{n} is a string, @var{ln} are strings, @var{tn} are type
@c expressions, and @var{field} is an expression like:

@c @example
@c field (@var{l1}, @var{t1})
@c @end example

@c then

@c @example
@c struct (@var{n}, @var{field1}, ..., @var{fieldm})
@c @end example

@c is a type expression denoting a struct type having name @var{n} and @var{m}
@c fields, each featuring a field name @var{li} and a type @var{ti}.
  
@c The strings @var{n} and @var{li} can be @code{NULL}, meaning the
@c structure type is anonymous and that the corresponding struct fields
@c are anonymous, respectively.

@c @item Unions.

@c       XXX

@c @item Functions.

@c If @var{tn} are type expressions, `function (@var{t0}, @var{t1},
@c @var{t2},..., @var{tm})' is a type expression denoting the type of a
@c function getting @var{m} arguments of the given types, and returning a
@c value of type @var{t0}.

@c Note that @var{t0} should be @code{void} for functions that do not
@c return a value.

@c @end itemize

@c Poke uses graphs (XXX: trees or dags?) to represent type expressions,
@c where interior nodes are type constructors, and leaves are basic type
@c constructors.

@c Note that type names, by themselves, do not constitute type
@c expressions.  However they can be part of some type constructor, like
@c in structs and unions.

@c @section Cycles in Type Expressions

@c Pkl imposes the restriction that no type can be referred by name
@c before it is declared.  Therefore, it is not possible to define
@c recursive types and the graphs used to implement type expressions
@c can't have cycles.

@node Integer Types
@section Integer Types

Most of the values manipulated in Pkl programs are whole numbers, also
typically known as @dfn{integers} in computing parlance.  This is
because integers are pervasive in binary formats.

Most general-purpose programming languages provide a small set of
integer types, each featuring a range corresponding to strategic
storage sizes: basically, signed and unsigned variants of 8, 16, 32,
64 bits.  When integers having an ``odd'' width (like 13 bits, for
example) get into play for whatever reason, the programmer is required
to use the integer arithmetic operators (and sometimes bit-wise
operators) herself, in a clever way, in order to achieve the desired
results.

Pkl, on the contrary, provides a rich set of integer types featuring
different widths, in both signed and unsigned variants.  The language
operators are aware of these types, and will do the right thing when
operating on integer values having different widths.  XXX xref: see
arithmetic operators.

Unsigned integer types are created using the type constructor
@code{uint<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{(0,64]}.

Similarly, signed integer types are created using the type constructor
@var{int<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{(0,64]}.

Note that expressions are not allowed in the type integral constructor
parameters.  Not even constant expressions.  Thus, things like
@code{int<foo>} and @code{uint<2+3>} are not allowed.

@node Offset Types
@section Offset Types

@node String Type
@section String Type

Pkl supports a notion of @dfn{strings} which is very similar to the C
programming language: a string value is a sequence of characters that
is terminated by the so-called @dfn{null character}.  String values,
and the operations allowed on them, are described in detail in later
chapters.

There is only one type for Pkl string values (the lenght of the string
is not part of its type) and the type constructor is simply the
reserved word @code{string}.

@node Struct and Union Types
@section Struct and Union Types

@c XXX: in this section we use struct literals, which are described
@c later in @xref.

@node Array Types
@section Array Types

@node Type Equivalence
@section Type Equivalence

The checking rules described below uses the notion of equality among
type expressions: "if T1 and T2 are equal".

@b{R-TYPE-00}: Pkl uses structural equivalence for all types, but for
struct and union types, which are compared by name.

Note however that not all the components of the type expressions are
used in the equivalence rules.  The structural equivalence algorithm
implements some modified notions of equivalence.  For example, two
array types are equivalent even if they have a different number of
elements defined in their type expression.

Structural equivalence rules:

@example
IF T1.type = string AND T2.type = string
   RETURN true;
IF T1.type = int<s1> AND T2.type = int<s2>
   RETURN s1 == s2;
ELIF T1.type = uint<s1> AND T2.type = uint<s2>
   RETURN s1 == s2;
ELIF T1.type = offset<t1,u1> AND T2.type = offset<t2,u2>
   RETURN t1 EQUAL t2 AND u1 == u2
ELIF T1.type = t11 x t12 AND T2.type = t21 x t22
   RETURN t11 EQUAL t21 AND t12 EQUAL t22
ELIF T1.type = t1[] AND T2.type = t2[]
   RETURN t1 EQUAL t2
ELIF T1.type = struct @{name=n1@} AND T2.type = struct @{name=n2@}
   RETURN n1 == n2
ELIF T1.type = union @{name=n1@} AND T2.type = union @{name=n2@}
   RETURN n1 == n2
ELIF T1.type = (T11, ..., T1n) : T10 AND T2.type = (T21, .., T2n) : T20
   RETURN T10 EQUAL T20 AND (T11 EQUAL T21 AND ... T1n EQUAL T2n)
@end example

@c XXX move this paragraph to the pokeint manual.
The Pkl compiler function @code{pkl_ast_type_equal} implements the
equivalence rules described above.

Anonymous struct and union types are never equivalent to any union type,
not even to themselves, thus:

@example
defvar s = @{.foo=10,.bar=20@};
s = @{.foo=30,.bar=40@};  /* Type error.  */
@end example

@node Type Attributes
@section Type Attributes

@c @section Overloading of Operators

@c Certain Pkl operators are overloaded.  For example, addition is
@c supported for integer types of any type, and also for strings.

@c However, the overloading of operators in Pkl are carefully designed in
@c a way it is always possible to infer the type of the result of the
@c operator based on the types of the arguments.

@c This means it is possible for an implementation to perform type
@c checking of expressions in a single pass, using synthetized attributes
@c only.  No second top-down pass to narrow types is ever necessary.

@c For example:

@c @example
@c int<N> + int<N> -> int<N>          @r{is defined}.
@c int<N> + int<N> -> int<N*2>        @r{is NOT defined}.
@c @end example

@c @section Type Checking of Expressions

@c R-TYPE-02: The type of the Nth actual parameter passed in a function
@c call should match the type of the Nth formal argument defined in the
@c function type of the function being called.

@c @section Type Checking of Statements

@c In Pkl statements do not have types, but expressions can appear in
@c certain statements, and the types of these expressions are checked
@c according to the following rules.

@c @b{R-TYPE-01}: The type of the expression in the right-hand side of an
@c assignment statement should match the type of the variable in the
@c left-hand side.

@c @b{R-TYPE-03}: Record and union type specifiers are only allowed in
@c deftype constructions and embedded in other struct and union type
@c specifiers.  In particular, these specifiers are not allowed in
@c function argument lists and casts.

@c @b{R-TYPE-04}: The type of the expression in the condition part of a
@c conditional statement should be an integral type, suitable to be
@c promoted to a signed 32-bit integer.

@c @b{R-TYPE-05}: The type of the expression in the condition part of a
@c while statement should be an integral type, suitable to be promoted to
@c a signed 32-bit integer.

@c @b{R-TYPE-06}: The type of the expression in an expression statement
@c should be @code{void}, i.e. a call to a function that doesn't return
@c any value.

@c @section Type Checking of Type Specifiers

@c As described above, type constructors may contain other types, either
@c directly or indirecly.

@c An example of a direct type inclusion is the type of the elements
@c specified in an array type constructor.  An example of an indirect
@c type inclusion is the type of the constant expression denoting the
@c units in an offset type constructor.

@c Thus the Pkl type system also includes checks for types contained in
@c type expressions, and these are listed below.

@c @b{R-TYPE-07}: An array type specifier may contain an expression
@c denoting the number of elements it contains, but only when it appears
@c in a field in a struct type.  Thus, @code{struct @{int[10] foo;@}} is
@c valid, but @code{defun foo = (int[10] a) @{...@}} isn't.

@c @b{R-TYPE-08}: The type of the expression denoting the number of
@c elements in an array type constructor should be suitable to be
@c promoted to an @code{uint<64>}.  (See promotion rules in XXX xref).

@c @b{R-TYPE-09}: The expression denoting the number of elements in an
@c array should be constant.  (See constant expressions in XXX xref).

@c @b{R-TYPE-10}: The base type of an offset type should be an integral
@c type.  For example, @code{offset<string,1>} is not valid.

@c @b{R-TYPE-11}: The type of the expression denoting the unit of an
@c offset type specifier should be suitable to be promoted to an
@c @code{uint<64>}.

@c @b{R-TYPE-12}: The type of the expression denoting the unit of an
@c offset type specifier should be constant.

@c @section Type Promotion

@c XXX document promotion rules here.

@node Structs and Unions
@chapter Structs and Unions

@section Flattening

Useful idiom: a struct containing common fields can be defined and
used as a flattening inside the union alternatives.  The type
@code{packet_epilogue} is not visible from outside the union.

@example
deftype Packet =
  union
  @{
    deftype PacketEpilogue = struct @{ uint32 quux; @};

    struct
    @{
      uint32 type = 0x0;
      byte[1024] data;
      PacketEpilogue;
    @} audio;

    struct
    @{
      uint32 type = 0x1;
      byte[2048] data;
      PacketEpilogue;
    @} video;
  @};
@end example

The desugared version of a conditional struct field is a flattened
union with an empty alternative.

@example
deftype foo =
  struct
  @{
    int f1;
    int f2 if f1 > 0;
  @};
@end example

@noindent
is equivalent to

@example
deftype foo =
  struct
  @{
    int f1;
    union
    @{
      int f2 : f1 > 0;
      struct @{@};
    @};
  @};
@end example

@noindent
Flattened structs can also be conditional:

@example
deftype foo =
  struct
  @{
    int f1;
    struct
    @{
      int f2;
      int f3;
    @} if f1 > 0;
  @};
@end example

@noindent
is equivalent to

@example
deftype foo =
  struct
  @{
    int f1;
    union
    @{
      struct @{ int f2; int f3; @} : f1 > 0;
      struct @{@};
    @};
  @};
@end example

@noindent
Video file example.

@example
deftype vfile = tag [];

deftype Tag =
  union
  @{
    deftype TagCommon =
      struct
      @{
        int flags;
        int reserved;
      @};
    
    struct
    @{
      int tag_type = TAG_VIDEO;
      TagCommon;
      uint64 time;
      byte[1024] data;
    @} video;

    struct
    @{
      int tag_type = TAG_SCRIPT;
      TagCommon;
      string code;
    @} script;

    struct
    @{
      int tag_type = TAG_NULL;
      TagCommon = @{ .flags = 0, .reserved = 0 @};
    @} null;
  @};
@end example
  
Compare the above with the following version where flattening is not
used at all.  The type `tag' is changed to a struct and an additional
union is nested, very C-like.

@example
deftype Tag =
  struct
  @{
    int tag_type;
    int flags;
    int reserved;

    union
    @{
      struct
      @{
        uint64 time;
        byte[1024] data;
      @} video : tag_type == TAG_VIDEO;

      struct
      @{
        string code;
      @} script : tag_type == TAG_SCRIPT;

      struct
      @{
      @} null : tag_type = TAG_NULL;
      
    @} data;
  @};
@end example

@c XXX
@noindent
Flattening also works with enums.

@example
deftype relocs =
  enum <int> (int mach)
  @{
    enum <int>
    @{
      R_SPARC_FOO = 1,
      R_SPARC_BAR = 2
    @} if mach == SPARC;

    enum <int>
    @{
      R_ALPHA_FOO = 1,
      R_ALPHA_BAR = 2
    @} if mach == ALPHA;
  @};
@end example

@node Future Extensions
@chapter Future Extensions

@section Future Extensions to the Type System

The idea is to evolve the type system, in subsequent versions, in a
backwards-compatible way:

@itemize @bullet
@item
Support for recursive types.  It may be useful, although binary file
formats are seldom defined in a recursive way.

@item
Variable types, eg. @code{int<@var{exp}>} where @var{exp} is not constant.

@item
Evolve into a kind of gradual typing, to provide more dynamism while
keeping the control and efficiency associated with static typing.
@end itemize

@section Other future extensions

@itemize
@item
Allow constant expressions in integral type constructors, like
@code{uint<2+3>}.
@end itemize


@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
