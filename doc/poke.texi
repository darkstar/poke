\input texinfo
@comment %**start of header
@setfilename poke.info
@include version.texi
@settitle The Poke Book
@afourpaper
@comment %**end of header

@copying
This book describes GNU poke (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2019 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Editors
@direntry
* poke: (poke). Interactive editor for binary files.
@end direntry

@titlepage
@title The Poke Book
@subtitle for version @value{VERSION}, @value{UPDATED}
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Poke Book

@insertcopying
@end ifnottex

@c Introduction
@c
@c - Motivation, and history (first part of talk)
@c - Nomenclature
@c - The program
@c - Demo: poking a relocation
@c
@c The Language
@c
@c Values
@c Types
@c Structs
@c Arrays
@c
@c The Program
@c
@c Dump
@c Files
@c Settings
@c pokerc
@c Styling poke's output
@c
@c Hacking poke
@c
@c Writing poke commands.

@menu
@c * Motivation::			Why a binary editor?
* Nomenclature::		poke, Poke and pickles.
@c * Demo
* Integers::			working with whole numbers.
* Offsets::			working with memory sizes.
* Endianness::			byte ordering.
* Output::			printing from Poke programs.

Appendices
* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@end menu

@node Nomenclature
@chapter Nomenclature
@cindex poke, Poke, pickle

GNU poke is a new program and it introduces many a new concept.  It is
a good idea to clarify how we call things in the poke community.
Unless everyone uses the same nomenclature to refer to pokeish
thingies, it is gonna get very confusing very soon!

First of all we have @command{poke}, the program.  Since ``poke'' is a
very common English word, when the context is not clear we either use
the full denomination @command{GNU poke}, or quote the word using some
other mean.

Then we have @dfn{Poke}, with upper case P, which is the name of the
domain-specific programming language implemented by @command{poke},
the program.

This distinction is important.  For example, when people talk about
``poke programmers'' they refer to the group of people hacking GNU
poke.  When they talk about ``Poke programmers'' they refer to the
people who write programs using the Poke programming language.

Finally, a @dfn{pickle} is a Poke source file containing definitions
of types, variables, functions, etc, that conceptually apply to some
definite domain.  For example, @file{elf.pk} is a pickle that provides
facilities to poke ELF object files.  Pickles are not necessarily
related to file formats: a set of functions to work with bit patterns,
for example, could be implemented in a pickle named
@file{bitpatterns.pk}.

We hope this helps to clarify things.

@node Integers
@chapter Integers
@cindex integers

@menu
* Integer Literals::		Writing integers in different bases.
* Characters::		        Another way to write small integers.
@end menu

@node Integer Literals
@section Integer Literals

Integers literals can be expressed in several numeration bases.

@emph{Decimal numbers} use the usual syntax @code{[1-9][0-9]*}.  For
example, @code{2345}.

@emph{Octal numbers} are expressed using a prefix @code{0o} (or
@code{0O}) followed by one or more digits in the range @code{[0-7]}.
Examples are @code{0o0}, @code{0o100} and @code{0o777}.

@emph{Hexadecimal numbers} are expressed using a prefix @code{0x} (or
@code{0X}) followed by one or more hexadecimal digits in the range
@code{[0-f]}.  Examples are @code{0x0} and @code{0xfe00ffff}.  Note
that both the @code{x} in the prefix and the letters in the
hexadecimal number are case insensitive.  Thus, @code{0XdeadBEEF} is a
valid (but ugly as hell) literal.

@emph{Binary numbers} are expressed using a prefix @code{0b} (or
@code{0B}) followed by one or more binary digits in the range
@code{[0-1]}.  Examples of binary literals are @code{0b0} and
@code{0B010}.

Negative numbers, of any numeration base, are constructed using the
minus operator as explained below.  Therefore the minus symbol
@code{-} in negative numbers is no part of the literal themselves.

@subsection The digits separator @code{_}

The character @code{_} can appear anywhere in a numeric literal other
than leading them.  It is ignored, and its purpose is to make it
easier for programmers to read them:

@example
0xf000_0000_0000_0000
0b0000_0001_0000_0001
@end example

@subsection Types of integer literals

The type of a numeric literal is the smallest signed integer capable
of holding it, starting with 32 bits, in steps of powers of two and up
to 64 bits.@footnote{Rationale: the width of a C ``int'' is 32 bits in
most currently used architectures, and binary data formats are usually
modeled after C.}

So, for example, the value @code{2} has type @code{int<32>}, but the
value @code{0xffff_ffff} has type @code{int<64>}, because it is out of
the range of signed 32-bit numbers.

A set of suffixes can be used to construct integer literals of certain
types explicitly.  @code{L} or @code{l} is for 64-bit integers.
@code{H} or @code{h} is for 16-bit integers (also known as
@dfn{halves}), @code{B} or @code{b} is for 8-bit integers (also known
as @dfn{bytes}) and @code{n} or @code{N} is for 4-bit integers (algo
known as @dfn{nibbles}).

Thus, @code{10L} is a 64-bit integer with value
@code{0x0000_0000_0000_000A}, @code{10H} is a 16-bit integer with
value @code{0x000A} and @code{10b} is a 8-bit integer with value
@code{0x0A}.

Similarly, the signed or unsigned attribute of an integer can be
explicitly specified using the suffix @code{u} or @code{U} (the
default are signed types).  For example @code{0xffff_ffffU} has type
@code{uint<32>} and @code{0ub} has type @code{uint<8>}.  It is possible
to combine width-indicating suffixes with signedness suffixes:
@code{10UL} denotes the same literal than @code{10LU}.

The above rules guarantee that it is always possible to determine the
width and signedness of an integer constant just by looking at it,
with no ambiguity.

@node Characters
@section Characters

8-bit unsigned integers can use an alternative literal notation that
is useful when working with @emph{ASCII character codes}.  Printable
character codes can be denoted with @code{'c'}.

Non-printable characters can be expressed using escape-sequences.  The
allowed sequences are:

@table @code
@item \n
New-line character (ASCII 012).
@item \t
Tab character (ASCII 011).
@item \[0-9][0-9]?[0-9]?
Character whose ASCII code is the specified number, in octal.
@end table

Examples:

@example
'o'
'\n'
'\t'
'\0'
@end example

The type of a character literal is always @code{char}, aka
@code{uint<8>}.


@node Offsets
@chapter Offsets
@cindex offset, united values

Poke uses united values to handle offsets and data sizes.  This is a
very central concept in poke.

@menu
* Why offsets::			byte-oriented or bit-oriented?
* Offset values::		denoting offsets in Poke.
* Offset operations::		operating with offsets.
@end menu

@node Why offsets
@section Why offsets

Early in the design of what is becoming GNU poke I was struck by a
problem that, to my surprise, would prove not easy to fix in a
satisfactory way: would I make a byte-oriented program, or a
bit-oriented program?  Considering that the program in question was
nothing less than an editor for binary data, this was no petty
dilemma.

Since the very beginning I had a pretty clear idea of what I wanted to
achieve: a binary editor that would be capable of editing user defined
data structures, besides bytes and bits.  I also knew I needed some
sort of domain specific language to describe these structures and
operate on them.  How that language would look like, and what kind of
abstractions it would provide, however, was not clear to me.  Not at
all.

So once I sketched an initial language design, barely something very
similar to C structs, I was determined to not continue with the poke
implementation until I had described as many as binary formats in my
language as possible.  That, I reckoned, was the only way to make sure
the implemented language would be expressive, complete and useful
enough to fulfill my requirements.

The first formats I implemented using my immature little language
included ELF, FLV, MP3, BSON... all of them describing structures
based on whole bytes.  Even when they try to be compact, it is always
by packing bit-fields in elements that are, invariably, sized as a
multiple of bytes.  Consequently, the language I was evolving became
byte oriented as well.  No doubt also influenced by my C inheritance,
I would think of bitfields either as a sort of second class citizen,
or as mere results of shifting and masking.

This worked well.  The language evolved to be able to express many
different aspects of these formats in a very nice way, like
variable-length data and holes in structures.  Consider the following
definition in what actually is @strong{not} valid today's Poke:

@example
deftype Data =
  struct
  @{
    byte magic;
    byte count;
    byte dstart;

    byte[count] data @ dstart;
  @};
@end example

The data starts with a byte that is a magic number.  Then the size of
the data stored, in bytes, and then the data itself.  This data,
however, doesn't start right after @code{dstart}: it starts at
@code{dstart}, which is expressed as an offset, in bytes, since the
beginning of the Data.  I conceived struct field labels to be any
expression evaluating to an integer, which would be... bytes,
obviously.

Then, one day, it was the turn for IETF RFC1951, which is the
specification of the DEFLATE algorithm and associated file format.  Oh
dear.  Near the beginning of the spec document it can be read:

@quotation
This document does not address the issue of the order in which bits of
a byte are transmitted on a bit-sequential medium, since the final
data format described here is byte- rather than bit-oriented.
However, we describe the compressed block format in below, as a
sequence of data elements of various bit lengths, not a sequence of
bytes.
@end quotation

Then it goes on describing rules to pack the DEFLATE elements into
bytes.  I was appalled, and certainly sort of deflated as well.  The
purpose of my program was precisely to edit binary in terms of the
data elements described by a format.  And in this case, these data
elements came in all sort of bit lengths and alignments.  This can be
seen in the following RFC1951 excerpt, that describes the header of a
compressed block:

@quotation
Each block of compressed data begins with 3 header bits
containing the following data:
@example
first bit       BFINAL
next 2 bits     BTYPE
@end example

Note that the header bits do not necessarily begin on a byte boundary,
since a block does not necessarily occupy an integral number of bytes.
@end quotation

At this point I understood that my little language on the works would
be never capable to describe the DEFLATE structures naturally: C-like
bit-fields, masking and shifting, all based on byte-oriented
containers and boundaries, would never provide the slickness I wanted
for my editor.  I mean, just use C and get done with it.

This pissed me off.  Undoubtely other formats and protocols would be
impacted in a similar way.  Even when most formats are byte oriented,
what am I supposed to tell to the people hacking bit-oriented stuff?
``Sorry pal, this is not supported, this program is not for you''?  No
way, I thought, not on my watch.

The obvious solution for the problem, is to be general.  In this case,
to express every offset and every memory size in bits instead of
bytes.  While this obviously gives the language maximum expressiveness
power, and is ideal for expressing the few bit-oriented formats, it
has the disadvantage of being very inconvenient for most situations.

To see how annoying this is, let's revisit the little Data element we
saw above.  In a bit-oriented description language, we would need to
write something like:

@example
deftype BitData =
  struct
  @{
    byte magic;
    byte count;
    byte dstart;

    byte[count] data @ dstart * 8;
  @};
@end example

Yeah... exactly.  The @key{*} and @key{8}> keys in the keyboards of
the poke users would wear out very fast, not to mention their patience
as well.  Also, should I provide both @code{sizeof} and
@code{bitsizeof} operators?  Nasty.

I am very fond of the maxim ``Never write a program you would never
use yourself''@footnote{Actually it is Lord Vetinari's ``Never build a
dungeon you can't get out of.'' but the point is the same.}, so I
resigned myself to make GNU poke byte oriented, and to provide as many
facilities for operating on bit-fields as possible.

@noindent
Fortunately, I have smart friends...

During one of the Rabbit Herd's Hacking
Weekends@footnote{@url{http://www.jemarch.net/rhhw}} I shared my
frustration and struggle with the other rabbits, and we came to
realize that offsets and data sizes in Poke should not be pure
magnitudes or mere integer values: they should be united.  They should
have units.

It makes full sense when you come to think about it.  For a program
like poke, it is only natural to talk about different memory units,
like bits, bytes, kilobytes, megabits, and so on.  Bits and bytes are
just too common units.  Apart from allowing me to express values in
different units, this approach also has other benefits as we will see
shortly.

I'm really grateful to Bruno Haible, Luca Saiu and Nacho Gonzalez for
putting me on the right track.

@node Offset values
@section Offset values

Poke provides a convenient syntax to provide united values, which are
called @dfn{offsets} (because in a binary editor you mostly use them
to denote offsets in the file you are editing):

@example
12#B
7#b
1024#Kb
@end example

The offsets above denote twelve bytes, seven bits and one thousand
twenty four kilobytes, respectively.  The unit can be separated from
the magnitude by blank characters, so you can write the following
instead if you are so inclined:

@example
12 #B
7 #b
(1024 * 1024) #Kb
@end example

Note how the magnitude part of an offset doesn't need to be constant.
If the variable @code{a} contains an integer, this is how you would
denote ``a bytes'':

@example
a#B
@end example

In the offset syntax units are specified as @code{#@var{foo}}, where
@var{FOO} is the name of the unit.  Poke provides the following list
of hardcoded unit names:

@table @code
@item b
bits.
@item B
bytes.
@item Kb
kilo bits (1024 bits.)
@item KB
Kilo bytes (1024 bytes.)
@item Mb
Mega bits.
@item MB
Mega bytes.
@item Gb
Mega bits.
@end table

However, it is also possible to express units in multiples of the base
unit, which is the bit.  Using this syntax, it becomes possible to
express offsets in any arbitrary unit, as disparate as it may seem:

@example
17#3
0#12
8#1
@end example

Thats it, 17 units of 3 bits each, zero units of 12 bits each,
and eight units of 1 bit each.

But then, why stopping there?  Poking is all about defining data
structures and operating on them... so why not using these structures
as units as well?  Consider the following struct:

@example
deftype Packet = struct @{ int i; long j; @};
@end example

The size of a @code{Packet} is known at compile time (which is not
generally true for Poke structs).  Wouldn't it be nice to use it as a
unit in offsets?  Sure it is:

@example
23#Packet
@end example

The above is the size occupied by 23 packets.  Any type whose size is
known at compile time can be specified as an offset unit.

Expressing offsets as united values also relieves the programmer from
doing many explicit unit conversions: poke can do them for you.
Consider for example an ELF section header.  One of its fields is the
size of the described section, in bytes:

@example
deftype Elf64_Shdr =
  struct
  @{
   ...
   offset<Elf64_Xword,B> sh_size;
   ...
  @};
@end example

If a given section is to contain, say, relocations with addends,
we can set its size doing something like this:

@example
shdr.sh_size = 10#Elf64_Rela;
@end example

@noindent
Instead of doing the conversion to bytes explicitly.

If the magnitude of an offset is 1 then it is allowed to omit it
entirely.  To denote one kilobyte, for example, we can write
@code{#KB}.

@node Offset operations
@section Offset operations

Poke supports a little algebra for offsets.

@subsection Addition and subtraction

The addition or subtraction of two offsets results in another offset.
Examples:

@example
(poke) 1#B + 1#b
9#b
(poke) 2#KB - 1024#B
1024#B
@end example

The unit of the result is the greatest common divisor of the units of
the operands.

@subsection Multiplication by a scalar

Multiplying an offset by a magnitude gives you another offset.
Examples:

@example
(poke) 8#b * 2
16#b
(poke) 16#MB * 0
0#MB
@end example

The unit of the result is the same than the unit of the offset
operand.

Note that multiplying two offsets is not supported.  This makes sense,
since computer memory is linear, and therefore it wouldn't make any
sense to have units like @code{#B@sup{2}}.

@subsection Division

Dividing two offsets gives you a magnitude.  Examples:

@example
(poke) 16#b / 1#B
2
(poke) 1024#MB / 512#Mb
16
@end example

Dividing offsets is the Pokish way of converting memory magnitudes
between different units: just use units like you do when doing physics
or working with units in other contexts.

For example, using the syntactic trick of omitting the magnitude (in
which case it is assumed to be 1) it is very natural to write
something like the following to convert from kilobits to bytes:

@example
(poke) 24 #Kb/#B
3072
@end example

@subsection Modulus

The modulus of two offsets gives you another offset with the expected
semantics.  Examples:

@example
(poke) 9#b % 1#B
1#b
(poke) 1#B % 9#b
8#b
@end example

The unit of the result is the greatest common divisor of the units of
the operands.

@node Endianness
@chapter Endianness
@cindex endian, endianness

Byte endianness is an important aspect of encoding data.  As a good
binary editor poke provides support for both little and big endian,
and will soon acquire the ability to encode exotic endianness like PDP
endian.  Endianness control is integrated in the Poke language, and is
designed to be easily used in type descriptions.

@menu
* .set endian::			dot-command to get and set the endianness.
* Endian built-ins::		changing endianness programmatically.
@end menu

@node .set endian
@section .set endian
@cindex commands

GNU poke maintains a global variable that holds the current
endianness.  This is the endianness that will be used when mapping
integers whose types do not specify an explicit endianness.

Like other poke global state, this global variable can be
modified using the @command{.set} dot-command:

@example
.set endian little
.set endian big
.set endian host
@end example

@noindent
The current endianness can be obtained like this:

@example
(poke) .set endian
little
@end example

We can easily see how changing The current endianness indeed impacts
the way integers are mapped:

@example
(poke) dump :from 0#B :size 4#B :ruler 0 :ascii 0
00000000: 8845 4c46
(poke) .set endian little
(poke) int @ 0#B
0x464c4588
(poke) .set endian big
(poke) int @ 0#B
0x88454c46
@end example

@node Endian built-ins
@section Endian built-ins

As handy as the @command {.set endian} dot-command may be, it is also
important to be able to change the current endianness programmatically
from a Poke program.  For that purpose, the PKL compiler provides a
couple of built-in functions: @code{get_endian} and @code{set_endian}.

Their definitions, along with the specific supported values, look
like:

@example
defvar ENDIAN_LITTLE = 0;
defvar ENDIAN_BIG = 1;

defun get_endian = int: @{ ... @}
defun set_endian = (int endian) int: @{ ... @}
@end example

Accessing the current endianness programmatically is especially useful
in situations where the data being poked features a different
structure, depending on the endianness.

A good (or bad) example of this is the way registers are encoded in
eBPF instructions.  eBPF is the in-kernel virtual machine of Linux,
and features an ISA with ten general-purpose registers.  eBPF
instructions generally use two registers, namely the source register
and the destination register.  Each register is encoded using 4 bits,
and the fields encoding registers are consecutive in the instructions.

Typical.  However, for reasons we won't be discussing here the order
of the source and destination register fields is switched depending on
the endianness.

@noindent
In big-endian systems the order is:

@example
dst:4 src:4
@end example

@noindent
Whereas in little-endian systems the order is:

@example
src:4 dst:4
@end example

In Poke, the obvious way of representing data whose structure depends
on some condition is using an union.  In this case, it could read like
this:

@example
deftype BPF_Insn_Regs =
  union
  @{
    struct
    @{
      BPF_Reg src;
      BPF_Reg dst;
    @} le : get_endian == ENDIAN_LITTLE;

    struct
    @{
      BPF_Reg dst;
      BPF_Reg src;
    @} be;
  @};
@end example

Note the call to the @code{get_endian} function (which takes no
arguments and thus can be called Algol68-style, without specifying an
empty argument list) in the constraint of the union alternative.  This
way, the register fields will have the right order corresponding to
the current endianness.

Nifty.  However, there is an ever better way to denote the
structure of these fields.  This is it:

@example
deftype BPF_Insn_Regs =
  struct
  @{
    defvar little_p = (get_endian == ENDIAN_LITTLE);

    BPF_Reg src @ !little_p * 4#b;
    BPF_Reg dst @ little_p * 4#b;
  @};
@end example

This version, where the ordering of the fields is implemented using
field labels, is not only more compact, but also has the virtue of not
requiring additional "intermediate" fields like @code{le} and
@code{be} above.  It also shows how convenient can be to declare
variables inside structs.

@noindent
Let's see it in action:

@example
(poke) BPF_Insn_Regs @ 1#B
BPF_Insn_Regs @{src=#<%r4>,dst=#<%r5>@}
(poke) .set endian big
(poke) BPF_Insn_Regs @ 1#B
BPF_Insn_Regs @{src=#<%r5>,dst=#<%r4>@}
@end example

Changing the current endianness in constraint expressions is useful
when dealing with binary formats that specify the endianness of the
data that follows using some sort of tag.  This is the case of ELF,
for example.

The first few bytes in an ELF header conform what is known as the
@code{e_ident}.  One of these bytes is called @code{ei_data} and its
value specifies the endianness of the data stored in the ELF file.

@noindent
This is how we handle this in Poke:

@example
defun elf_endian = (int endian) byte:
 @{
   if (endian == ENDIAN_LITTLE)
     return ELFDATA2LSB;
   else
     return ELFDAT2MSB;
 @}

[...]

deftype Elf64_Ehdr =
  struct
  @{
    struct
    @{
      byte[4] ei_mag : ei_mag[0] == 0x7fUB
                       && ei_mag[1] == 'E'
                       && ei_mag[2] == 'L'
                       && ei_mag[3] == 'F';
      byte ei_class;
      byte ei_data : (ei_data != ELFDATANONE
                      && set_endian (elf_endian (ei_data)));
      byte ei_version;
      byte ei_osabi;
      byte ei_abiversion;
      byte[6] ei_pad;
      offset<byte,B> ei_nident;
    @} e_ident;

    [...]
  @};
@end example

Note how @code{set_endian} returns an integer value...  it is always
@code{1}. This is to facilitate its usage in fields constraint
expressions.

@node Output
@chapter Output

Poke programs can print text to the standard output in two ways:
simple unformatted output, and formatted output.

@menu
* print::			simple output.
* printf::			formatted output.
@end menu

@node print
@section print
@cindex print, output

The @code{print} sentence prints the given string to the standard output.
@code{print} outputs text strings verbatim.  It can be invoked using
two alternative syntaxes, which are equivalent:

@example
print (@var{str});
print @var{str};
@end example

@code{print} is simple, but fast.  It is good to use it in simple
cases where the information to print out doesn't require any kind of
formatting and styling.

@node printf
@section printf
@cindex printf, formatted output, stylized output

The @code{printf} sentence gets a format string and, optionally, a
list of values to print.  It can be invoked using two alternative
syntaxes, which are equivalent:

@example
printf (@var{fmt}[, @var{value}...])
printf @var{fmt}[, @var{value}...]
@end example

The format string @var{fmt} is printed verbatim to the standard
output, but for @dfn{format tags} which start with @code{%}.  These
format tags are interpreted especially.

Most of the format tags ``consume'' one of the specified values.
Every value in the list shall be described by a tag, or the compiler
will signal an error.  Likewise, values without a corresponding
describing tag is an error.  These tags are:

@table @code
@item %s
Print the argument as a string.
@item %i@var{bits}(d|x|o|b|c)
Print the argument as a signed integer of size @var{bits}.  The last
letter determines how the argument is printed.
@table @code
@item d
Print the integer in decimal.
@item x
Print the integer in hexadecimal.
@item o
Print the integer in octal.
@item b
Print the integer in binary.
@item c
Print the integer as an ASCII character.  This only works with 8 bit
integers.
@end table
@item %u
Same than @code{%s}, but for unsigned integers.
@item %c
A shorter way to write @code{%u8c}.
@item %v
Print the value printed representation of the argument, which can be
of any type including complex types like arrays and structs.  This is
similar to the @code{write} operation available in many Lisp systems.

This tag is mainly intended to be used in pretty-printers.
@end table

The following format tags do not consume arguments.  They support
emitting styled text using the libtextstyle approach of having styling
classes that user can customize in a @file{.css} file.

@table @code
@item %<@var{classname}:
Start the styling class with name @var{classname}.  The class name
cannot be empty.
@item %>
End the last opened styling class.  All styling classes should be
ended before finishing the format string.
@end table

Note that styling classes can be nested, but all classes should be
ended before finishing the format string.

If you use a @var{name} class, you can define how to style it in the
@file{.css} file (poke installs and uses poke-default.css but you can
set the @code{POKE_STYLE} environment variable to point to another
css) like this:

@example
.NAME @{ text-decoration: blink; color : pink; @}
@end example

Examples:

@example
(poke) printf "This is a NAME: %<NAME:xxx%>"
This is a NAME: xxx
(poke) printf "Name: %<string:%s%> Age: %<integer:%i32d%>, "Jose", 39
Name: Jose Age: 39
@end example

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
