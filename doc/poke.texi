\input texinfo
@comment %**start of header
@setfilename poke.info
@include version.texi
@settitle The Poke Book
@afourpaper
@comment %**end of header

@copying
This book describes GNU poke (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2019 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Editors
@direntry
* poke: (poke). Interactive editor for binary files.
@end direntry

@titlepage
@title The Poke Book
@subtitle for version @value{VERSION}, @value{UPDATED}
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Poke Book

@insertcopying
@end ifnottex

@menu
Invoking Poke
* Hello Poke::

Basic Editing
@c* Commands::

@c XXX IO cache:
@c
@c   (poke) ... poke something ...
@c   (poke*) ... poke something more ...
@c   (poke*) .changes
@c   - 000043: 0034 aabb
@c   + 000043: ffff ffff
@c   (poke*) .commit
@c   Written 4 #B to IO foo.o
@c   (poke)
@c
@c   (poke*) .revert
@c   You sure you want to revert?  Use .revert yes.
@c   (poke)
@c
@c   (poke*) .exit
@c   There are unsaved changes.  Use .exit yes.
@c
@c .set safer 0
@c this disables the .revert yes and .exit yes stuff.

@c XXX document struct constructors
@c
@c Some special rules apply there that don't apply in struct
@c literals:
@c
@c - Every initializer is named.
@c   (This will change in the future.)
@c - The elements in the constructor should be a subset of
@c   the elements in the struct type.

@c XXX document .set OPTION
@c
@c  obase
@c  nenc
@c  safer
@c  etc...

* Mapping::			Structuring the IO space.

Advanced Editing
@c Searching

@c Marks
@c Useful Idioms

Reverse Engineering

Poke Language Reference Manual
* Introduction::
* Data Types::			Data types of values.
* Integers::			Whole numbers.
* Strings::			Strings of characters.
* Arrays::			Sequences of values.
* Structs and Unions::
* The Standard Library::	Predefined goodies!

@c * Grammar
* Future Extensions::

@c   Introduction
@c       About this Document
@c       Source Encoding and Character Set
@c       Comments
@c   Data Types (XXX: in this chapter literals are used, but are explained in detail later)
@c       Type Constructors
@c       Declaration of Types
@c       Integer Type
@c       String Type
@c       Struct and Union Types
@c       Array Type
@c       Type Equivalence
@c       Type Attributes
@c   Integers
@c       Integer Literals
@c       Characters
@c       Comparison of Integers
@c       Arithmetic Operations
@c       Bitwise Operations
@c       Integer Attributes
@c   Strings
@c       String Literals
@c       Comparison of Strings
@c       String Formatting
@c       String Attributes
@c   Arrays
@c       Array Literals
@c       Array Attributes
@c   Structs and Unions
@c       Fields
@c       Anonymous Fields
@c       Flattening
@c       Unions
@c       Conditional Fields
@c       Field Constraints
@c       Struct Literals
@c       Struct and Union Arguments
@c       Struct and Union Attributes
@c   Sets
@c       Enumerations
@c       Bitmasks
@c       Set Attributes
@c   Control Structures  (Conditionals and loops)
@c       Statements
@c       Conditionals
@c       Iteration
@c   Variables
@c       Variable Scope
@c       Declaration of Variables
@c   Functions
@c       Declaration of Functions
@c       Optional arguments to Functions
@c       Variadic Functions
@c   Mapping  (Accessing the IO space)
@c   Searching and Patterns
@c   Modules and Files
@c   The Standard Library
@c       Integer Standard Types

@c XXX ~/.pokerc
@c XXX: writing generic code: any and any[]

@c XXX
@c Using
@c   int i = magic;
@c and using
@c   int i : i == magic;
@c
@c is different.  The later does NOT install an implicit initializer
@c in the struct type.
@c
@c  Foo { }  works with the first.
@c  Foo { }  raises a constraint violation signal with the second

Old
* Structs::
* Unions::
* Enumerations::
* Bitmasks::
* Flattening::
@c XXX dedicate a chapter to the evaluation algorithm?
* Expressions::
* Constants::
* Variables::
* Statements::
* Procedures::
* MappingB::

Extending Poke
@c * Writing commands in C::
@c * Writing commands in Poke::

@c XXX: document promotions

* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@end menu

@node Hello Poke
@chapter Hello Poke!

XXX: explain why poke features a domain-specific languages.

XXX: aspects to discuss here:

     - Familiar C-like brace-based syntax.
     - Oriented for editing physical binary layouts:
       + Language-level support for endianness.
       + Padding control (by default, no padding.)

     - Data integrity:

       + Integrity constraints.
       + Validation.
       + Automatic fixing when feasible.
       + Allows altering the data with some level of assurance nothing
         gets broken.

     - Using C-like structs: easy to reuse definitions from software

     - Writing to the IO may change the layout of some data structure,
       so the data structures must adapt automatically.  This is a
       powerful concept in poke.

     - No pointers: variables do not have addresses.

     - poke          => bytes editor
     - poke + elf.pk => elf editor
     - poke + foo.pk => foo editor

@node Mapping
@chapter Mapping

@menu
* The IO Space::
* Mapped Values::
* Mapping Structs::
* Mapping Arrays::
* Unchecked Mapping::           Accessing erroneous data.
@end menu

@node The IO Space
@section The IO Space

XXX WRITEME

@node Mapped Values
@section Mapped Values

XXX WRITEME

XXX how simple types are never mapped.

XXX mapped attributes.

@node Mapping Structs
@section Mapping Structs

Struct values are mapped in the IO space by specifying the name of the
struct type in the map @code{@@} operation:

@example
@code{StructType} @@ @var{offset}
@end example

@node Mapping Arrays
@section Mapping Arrays

Arrays can be mapped in IO space in three different ways, depending on
the characteristics of the type provided to the mapping operator.

@subsection Array maps bounded by number of elements

When an array type bounded by number of elements is used in a mapping
operation, the resulting mapped array is also bounded by number of
elements.

For example, this is how we would map an array of four 32-bit signed
integers in the current IO space:

@example
(poke) int[4] @@ 0#B
[10,20,30,40]
@end example

Since you can specify a dynamic array type, the number of elements
doesn't need to be constant.  For example, given the variable
@code{nelems} has a value of @code{2}:

@example
(poke) int[nelems + 1] @@ 0#B
[100,222,333]
@end example

If an end-of-file condition happens while mapping the array, because
the number of elements specified in the array type, at the given
offset, exceeds the capacity of the underneath IO device, an exception
is raised and the mapping is not performed:

@example
(poke) int[99999999999] @@ 0#B
unhandled EOF exception
@end example

Likewise, if a constraint fails while performing the mapping (while
mapping an array of structs, for example) an exception is raised and
the map is aborted.

@subsection Array maps bounded by size

While dealing with binary formats, it often happens that the number of
entities in a collection is given by the space they occupy, rather
than the count itself.

For example, consider ELF sections holding relocations.  These
sections contain a collection of zero or more relocations. The layout
of each relocation is specified by the following type:

@example
deftype Elf64_Rela =
  struct
  @{
    offset<Elf64_Addr,B> r_offset;
    Elf64_Xword r_info;
    Elf64_Sxword r_addend;
  @};
@end example

The section is described by an entry in the ELF sections header table:

@example
deftype Elf64_Shdr =
  struct
  @{
    Elf_Word sh_name;
    Elf_Word sh_type;
    Elf64_Xword sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off sh_offset;
    offset<Elf64_Xword,B> sh_size;
    Elf_Word sh_link;
    Elf_Word sh_info;
    Elf64_Xword sh_addralign;
    offset<Elf64_Xword,b> sh_entsize;
  @};
@end example

The relevant elements of @code{Elf64_Shdr} are @code{sh_offset} and
@code{sh_size}, which indicate the offset of the beginning of the
section's contents, and it's size, respectively.  At this point, if we
wanted to get an array with all the relocations in the section, we
could map an array bounded by number of elements like we saw in the
previous section, like this:

@example
(poke) Elf64_Rela[sh_size / 1#Elf64_Rela]
[... relocs ...]
@end example

However, this approach adoleces from two problems.  First, it doesn't
work with any entity type.  For an offset like @code{1#Elf64_Rela} to
work, it is required for the unit type to be complete, as we saw in
previous chapters.  In the particular case of @code{Elf64_Rela}, that
condition is satisfied, but too often that's not the case.  For
example, think about a section containing @code{NULL} terminated
strings.

Another problem is when the data in the header is corrupted.  Using
the mapping bounded by number of elements, we wouldn't realize it.  It
would be good if the tool would tell us whether the specified size
actually holds an exact number of the requested elements.

A mapping bound by size is what we need.  Fortunately, @command{poke}
allows to specify an offset instead of an integral value, in the array
type specification.  The right amount of entities (in this case
relocations) to strictly satisfy the provided size will be mapped in
the IO space.  So, in order to obtain an array containing all the
relocations in the section, we simply write:

@example
(poke) Elf64_Rela[sh_size]
[... relocs ...]
@end example

The strictness mentioned above is important.  Poke will complain (and
abort the mapping) if it is not possible to map an exact number of
elements.  Thus the following mapping would not be successful:

@example
(poke) int[33#b] @@ 0#B
unhandled out of map bounds exception
@end example

Like in mappings bounded by number of elements, if a constraint fails
while performing the mapping, an exception is raised and the map is
aborted.

@subsection Unbounded array maps

We mentioned above that if an end-of-file condition happens while
performing a mapping (be it bounded by number of elements or by size)
an EOF exception is raised, and the mapping is aborted.

Unbounded array mappings are performed by using an unbounded array
type in the mapping operation, like in:

@example
@var{type}[] @@ 0#B
@end example

The above construction will map values of type @var{type} in the IO
space until there is an end-of-file condition, or a constraint fails,
whatever happens first.

Let's assume a binary file contains a series of blocks, located one
after the other, of a kind described by the following struct type:

@example
deftype Block =
  struct
  @{
     byte magic[2] : magic[0] == 'B' && magic[1] == 'K';
     ... other data ...
  @};
@end example

we can map the blocks using an unbounded array map:

@example
(poke) Block[] @@ 0#B
[ ... blocks ... ]
@end example

If the blocks extend up to the end of the IO space, that many blocks
will be mapped.  If there is some other content in the file following
the blocks, the constraint in the @code{magic} field will fail and
will delimit the map that way (provided the binary format is well
designed.)

@subsection Mapped bounds in bounded arrays

When an array map is bounded, be it by number of elements or by size,
the bounding value can be mapped itself.  To illustrate how this
works, let's go back to our ELF file and the section containing
relocations.  First, we map an @code{Elf64_Shdr} to get the section
header:

@example
(poke) defvar shdr = Elf64_Shdr @@ @var{offset}
(poke) shdr.sh_offset
120#B
(poke) shdr.sh_size
24#B
@end example

Now we map an array with the relocations themselves, using a map
bounded by size, as we learned in the last section:

@example
(poke) defvar relocs = ELF64_Rela[shdr.sh_size] @@ shdr.sh_offset
(poke) relocs'length
3
@end example

Now, observe that @code{shdr.sh_size} is mapped itself!  This means
that, should the section size be modified (to accommodate an extra
relocation, for example) the mapping of @code{relocs} will reflect
that automatically:

@example
(poke) shdr.sh_size = shdr.sh_size + 1#Elf64_Rela
(poke) relocs'length
4
@end example

This is certainly an useful idiom, that is often used while poking
around.  However, sometimes this is @emph{not} what we want.  If we
don't want the mapping bounds of @code{relocs} to be tied to
@code{shdr}, we can just use a temporary for the size:

@example
(poke) defvar s = shdr.sh_size
(poke) defvar relocs = Elf64_Rela[s] @@ shdr.sh_offset
@end example

Since simple values (such as the size above) are not mapped, this
trick works as intended.

@c  Assigning a new value to a mapped array: valmappers.

@node Unchecked Mapping
@section Unchecked Mapping

XXX WRITEME

This can be either:

@example
.set checked 0
@end example

or:

@example
(poke) Reloc @@! 0#B
@end example

@node Introduction
@chapter Introduction

@dfn{Poke} is a domain-specific programming language whose main purpose
is to manipulate structured binary data.  It is used in @code{poke},
the GNU interactive editor for binary files.

@menu
* About this Document::		What this document is and what it isn't.
* Source Files::                Source Encoding and Character Set.
* Comments::			Comments and their formatting conventions.
@end menu

@node About this Document
@section About this Document

This document contains a complete and semi-formal specification of
Poke, describing all the aspects of the language.  The main purpose of
the specification is to serve as a reference for both users and
implementors.

This document is not intended to be a tutorial for learning how to
write Poke programs.  For that purpose, please read the Poke Book. XXX:
xref to the poke book.

@node Source Files
@section Source Files

Poke source text shall be encoded in @acronym{ASCII} (ISO-646) and
covers the @acronym{ASCII} character set.

Source code lines are separated by the @dfn{newline character},
@acronym{ASCII} code @code{012}.

@node Comments
@section Comments

Poke supports two different kind of comments: multi-line non-nestable
comments and partial-line stackable comments.

Text enclosed between @code{/*} and @code{*/} sequences conforms a
possibly multi-line comment.  This is an example:

@example
/* This is a comment that spans
   through several lines.  */
@end example

Multi-line comments can't be nested.  Thus, the following is not
syntactically correct:

@example
/* This is /* not */ correct!  */
@end example

Characters following @code{//}, up to the next newline character or
end of file, conform a partial line comment.  These kind of comments
can be stacked.  The following are valid comments:

@example
// This is a one line comment.
// This is a stacked // comment.
@end example

Both stackable and non-nestable comments are usually processed and
removed by the lexical analyzer, as these are not intended to be
preserved for subsequent processing@footnote{Some implementations may
find it suitable to encode certain meta-information in comments
however.}.

@c @section Identifiers

@c @b{R-LEX-02}: A letter (uppercase or lowercase) or an underscore
@c (@acronym{ASCII} code 137) followed by zero or more letters (uppercase
@c or lowercase), underscore characters, or digits conform an
@c @dfn{identifier}.

@c The semantic payload of identifiers is the sequence of characters
@c conforming the token.

@c @section Reserved Words

@c Certain character sequences look like identifiers, but they conform
@c other tokens.  These sequences are known as @dfn{reserved words}, and
@c can't be used as identifiers in any context.

@c @b{R-LEX-01}: The Poke reserved words are @code{struct}, @code{else},
@c @code{while}, @code{if}, @code{sizeof}, @code{defun}, @code{deftype},
@c @code{defvar}, @code{return}, @code{string}, @code{as} and
@c @code{__builtin_print__}.

@c @section Numeric Literals

@c Numeric literals allow to express numbers of several characteristics,
@c like width and numeration base.

@c @b{R-LEX-02}: @dfn{Decimal numeric literals} are denoted by a digit
@c followed by zero or more digits or underscores (@acronym{ASCII} code
@c 137), followed by an optional suffix string.

@c @b{R-LEX-03}: @dfn{Hexadecimal numeric literals} are denoted by the
@c sequence @code{0x} or @code{0X} followed by an @dfn{hexadecimal digit}
@c (@code{[0-9fA-F]}), followed by zero or more hexadecimal digits or
@c underscores, followed by an optional suffix string.

@c @b{R-LEX-04}: @dfn{Octal numeric literals} are denoted by the sequence
@c @code{0o} or @code{0O} followed by an @dfn{octal digit} (@code{[0-7]}),
@c followed by zero or more octal digits or underscores, followed by an
@c optional suffix string.

@c @b{R-LEX-05}: @dfn{Binary numeric literals} are denoted by the
@c sequence @code{0b} or @code{0B} folloed by a @dfn{binary digit}
@c (@code{[01]}), followed by zero or more binary digits or underscores,
@c followed by an optional suffix argument.

@c The underscores in numeric literals are intended to increase
@c readability, and do not contribute to the semantic value of the token.

@c The optional suffix allowed in numeric literals are composed by
@c sequences of characters, which characterize the number. The allowed
@c characters are:

@c @table @code
@c @item u
@c @itemx U
@c The numeric literal is unsigned.
@c @item n
@c @item N
@c The numeric literal is a @dfn{nibble}, i.e. it is 4-bit long.
@c @item B
@c The numeric literal is a @dfn{byte}, i.e. it is 8-bit long.
@c @item h
@c @itemx H
@c The numeric literal is a @dfn{half}, i.e. it is 16-bit long.
@c @item l
@c @item L
@c The numeric literal is a @dfn{long}, i.e. it is 64-bit long.
@c @end table

@c Not every combination of suffix characters makes sense.  Well-formed
@c numeric literal suffixes are characterized by the regular expression
@c @code{((u|U)|(u|U)?(l|L|B|h|H|n|N)|(l|L|B|h|H|n|N)(u|U))}.

@c If not explicitly specified with one of the @code{l}, @code{L},
@c @code{B}, @code{h} or @code{H} suffixes, the width of an integer
@c constant is the smallest signed or unsigned integer capable of holding
@c it, starting with 32 bits, in steps of power of two and up to 64 bits.

@c @section Character Literals

@c There is another way to express unsigned 8-bit integers, which is to
@c use a @dfn{character literal}.  Character literals are delimited by
@c @code{'} characters, and contain a representation of an
@c @acronym{ASCII} character.  The value of the resulting integer is the
@c code of the represented @acronym{ASCII} character in the
@c @acronym{ASCII}s 7-bit encoding.

@c The representation of a printable character is the printable
@c representation of the character itself.  For example, @code{'a'}
@c represents the integer @code{97}.

@c The representation of non-printable characters use escape sequences
@c instead, which are listed in the following table.

@c @table @code
@c @item '\NNN'
@c Character with octal code @code{NNN}.  The number can feature one, two
@c or three digits, but no more.  Example: @code{\0} is the @code{NULL}
@c character.
@c @item '\t'
@c Tab (@acronym{ASCII} @code{0x9}).
@c @item '\n'
@c Newline character (@acronym{ASCII} @code{0xa}).
@c @end table

@c @section String Literals

@c String literals allow to express sequences of characters, implicitly
@c finished by the @dfn{NULL character} or @code{'\0'}.  The contents of
@c a string literal are enclosed between @code{"} characters.

@c The @dfn{empty string}, which features only the implicit finishing
@c @code{'\0'}, is denoted as @code{""}.

@c The representation of printable ASCII characters in a string is the
@c printable representation of the characters themselves.  For example,
@c @code{"abc"} is a string composed by the characters @code{'a'},
@c @code{'b'}, @code{'c'} and @code{'\0'}.

@c The representation of non-printable characters within the string use
@c escape sequences instead, which are listed in the following table.

@c @table @code
@c @item \\
@c Represents the @code{\} character.
@c @item \n
@c Newline character (@acronym{ASCII} @code{0xa}).
@c @item \t
@c Tab (@acronym{ASCII} @code{0x9}).
@c @end table

@c XXX @section Formatted String Literals

@node Data Types
@chapter Data Types

@dfn{Values} are the data objects manipulated by Poke programs.  They
include numbers, offsets, character strings, structs, arrays, etc.

Every value belongs to one, and only one, type.  Values of the same
type have similar characteristics and may usually be used in the same
contexts.  The type corresponding to a value is unambiguous and well
defined, even if the value is denoted as a literal.  This suites well
the purpose of the language, since the programmer should always be
aware of the storage characteristics of the data being manipulated.

Poke provides a set of predefined type constructors that the programmer
can use directly.  This includes whole numbers of several different
bit lengths and signedness, and strings.  Also, constructs are
provided to allow the declaration of user-defined types, like structs,
unions and arrays.

This chapter describes generalities about types, an exhaustive list of
supported types, and also elaborates on how to define new types.

@c Static.  (XXX: rationale on why static.)

@c Probably sound, but not proven (yet).  The proof should be done by
@c induction, on the poke expressions tree.

@c The Poke type system establishes the rules to be applied in order to
@c determine the type of many different language constructs.  This
@c chapter contains an exhaustive relation of these rules.  A conforming
@c implementation should check for all of these, emitting errors in case
@c some rule is violated.

@menu
* Type Constructors::		Defining types.
* Declaration of Types::	Defining named types.
* Integer Types::		Whole numbers.
* Offset Types::                File offsets with units.
* String Type::			Character strings.
* Struct and Union Types::	Collections of Fields.
* Array Types::			Sequences of objects.
* Type Equivalence::		What types are considered equal.
* Type Attributes::		Querying properties of types.
@end menu

@node Type Constructors
@section Type Constructors

A @dfn{type constructor} is a syntax that denotes a type and its
properties.  Depending on the type being denoted, constructors can be
as simple as a single keyword, or be rather complex like a structure
definition spawning several program pages.  Consider for example the
following type constructors:

@example
string
int<32>
offset<uint<16>,8>
struct @{int<32> foo; int<64> bar;@}
uint<8>[]
@end example

The first line in the example above denotes the @dfn{string type}.
Since there is only one string type in Poke, this constructor doesn't
take any parameter.  Very simple.

The second line denotes the signed 32-bit integer type.  In this case,
a parameter should be passed to the type constructor in order to
specify the number of bits.  Note how @code{<} and @code{>} characters
are used to enclose type constructor parameters.

The third line denotes the offset type with base type unsigned 16-bit
integer and unit 8 bits.  Note how commas (@code{,}) are used to
separate parameters, and how a type (in this case the integer type)
can be passed as a parameter to a constructor.

The fourth line denotes a struct type.  In this case, the constructor
uses a more elaborated syntax, even if this example is actually a
rather simple struct type.

The fifth line denotes an array type, whose elements (values) are of
the unsigned 8-bit integer type.

The following sections discuss type constructors in great detail, for
the several types supported in Poke.

@node Declaration of Types
@section Declaration of Types

Types can be given names using the @code{deftype} construct:

@example
deftype @var{name} = @var{type_constructor};
@end example

@noindent
declares a new named type with name @var{name}, described by
@var{type_constructor}.  Type names are conformed by a letter or an
underscore character (@code{_}) followed by zero or more letters,
underscore characters or digits.  The type names are case-sensitive.

For example, consider the type declaration:

@example
deftype int = int<32>;
@end example

@noindent
which declares a type named @code{int} as a signed 32-bit integer
type.

Once a named type is declared, it is visible until the end of the
current lexical block (XXX xref see lexical blocks).  It is an error
to declare two types with the same name in the same lexical block.
Types declared in inner lexical blocks can ghost types declared in
outer blocks.

Once a type is declared, its name can be used everywhere a type is
expected.  This includes another @code{deftype}:

@example
deftype another_int = int;
@end example

Note that, whereas a type name can appear everywhere a type
constructor is expected, the inverse is not true: there are places
where a type name is accepted but not a type constructor.  The
following sections identify these contexts.

By convention, CamelCase is used for @code{struct} and @code{union}
types.

@c While discussing the type system, we will be using two different but
@c certainly related concepts: @dfn{type expressions} and @dfn{type
@c specifiers}.

@c A @dfn{type expression} is an abstract representation of a type, such
@c as @code{integer (32, 0)}, that denotes an unsigned 32-bit integral
@c type.  The syntax we use for type expressions doesn't equal the
@c concrete syntax of Poke, and is often more general.

@c As we shall see, type specifiers sometimes contain additional
@c information that is not kept in the corresponding type expression.
@c For example, @code{int[3]} is a valid array type specifier in certain
@c contexts, but the corresponding type expression is @code{array
@c (integer (3,1))}.  In this case, the @code{3} in the type specifier,
@c that denotes the number of elements of the array, is not part of the
@c type expression.

@c Type expressions are useful to reason about types and their
@c properties, such as type equivalence.  However, it is important to
@c keep in mind that they are not language constructions.

@c @section Type Expressions

@c Poke type expressions are structured, and are defined as follows.

@c A @dfn{basic type constructor}, maybe applied to some arguments, is a
@c type expression, and constructs basic types.  Basic type constructors
@c include:

@c @itemize @bullet
@c @item Integers.

@c If @var{size} is a constant expression evaluating to a positive
@c integer and @var{sign} is a constant expression evaluating to a
@c boolean, then:

@c @example
@c integer (@var{size}, @var{sign})
@c @end example

@c is a type expression denoting an integer of width @var{size} bits and
@c signedness @var{sign}.

@c Examples:

@c @itemize
@c @item @code{integer (32, 1)} denotes a signed 32-bit integer type.
@c @item @code{integer (13, 1)} denotes a signed 13-bit integer type.
@c @item @code{integer (64, 0)} denotes an unsigned 64-bit integer type.
@c @item @code{integer (4, 0)} denotes an unsigned 4-bit integer ("nibble").
@c @end itemize

@c @item Strings.

@c @code{string} is a type expression denoting a NULL-terminated string.

@c @item The @code{void} type.

@c @code{void} is a type expression denoting the absence of a type.  It
@c is used for functions that do not return a value.
@c @end itemize

@c A @dfn{type constructor}, applied to type expressions, is a type
@c expression.  Type constructors include:

@c @itemize
@c @item Offsets.

@c If @var{t} is a basic integral type expression and @var{u} is a constant
@c expression evaluating to a non-negative integer, then @code{offset (@var{t},@var{u})}
@c denotes an "united" magnitude having type @var{t} and multiple of the basic
@c unit @var{u}.

@c Examples:

@c @itemize
@c @item
@c @code{offset (integer (32, 1), 8)} denotes a signed 32-bit offset with
@c unit 8 (bytes).
@c @item
@c @code {offset (integer (32, 1), 7 + 1)} denotes the same type.
@c @item
@c @code{offset (integer (64, 0), 1)} denotes an unsigned 64-bit offset
@c with unit 1 (bits).
@c @end itemize

@c @item Arrays.

@c If @var{t} is a type expression, @code{array (@var{t})} is a type
@c expression denoting the type of an array with zero or more elements of
@c type @var{t}.

@c Examples:

@c @example
@c array (integer (32, 1))  -> Array of signed 32-bit integrals.
@c array (offset (integer (32, 1) ,8))
@c                                -> Array of signed 32-bit offsets with
@c                                   unit bytes.
@c @end example

@c Note that array types do not include a number of elements.  When
@c something like this is found in a struct type definition:

@c @example
@c struct
@c @{
@c    int num;
@c    Packet[num] packets;
@c @};
@c @end example

@c the type of @code{packets} is @code{array (Packet)}, and @code{num} is
@c used in the struct constructor to create the @emph{value} of the
@c array.  Likewise, in:

@c @example
@c defvar a = [1,2,3];
@c @end example

@c the type of @code{a} is @code{array (integer (32, 1))}, and it's size
@c is @code{3}.
 
@c In function definitions, it is not allowed to specify a size for an
@c array argument, thus, this is @emph{not} allowed:

@c @example
@c defun foo = (int[3] a) @{ ... @}
@c @end example

@c Ditto for casts to arrays.  The following is @emph{not} allowed:

@c @example
@c array as int[32]
@c @end example

@c @item Structs.

@c If @var{n} is a string, @var{ln} are strings, @var{tn} are type
@c expressions, and @var{field} is an expression like:

@c @example
@c field (@var{l1}, @var{t1})
@c @end example

@c then

@c @example
@c struct (@var{n}, @var{field1}, ..., @var{fieldm})
@c @end example

@c is a type expression denoting a struct type having name @var{n} and @var{m}
@c fields, each featuring a field name @var{li} and a type @var{ti}.
  
@c The strings @var{n} and @var{li} can be @code{NULL}, meaning the
@c structure type is anonymous and that the corresponding struct fields
@c are anonymous, respectively.

@c @item Unions.

@c       XXX

@c @item Functions.

@c If @var{tn} are type expressions, `function (@var{t0}, @var{t1},
@c @var{t2},..., @var{tm})' is a type expression denoting the type of a
@c function getting @var{m} arguments of the given types, and returning a
@c value of type @var{t0}.

@c Note that @var{t0} should be @code{void} for functions that do not
@c return a value.

@c @end itemize

@c Poke uses graphs (XXX: trees or dags?) to represent type expressions,
@c where interior nodes are type constructors, and leaves are basic type
@c constructors.

@c Note that type names, by themselves, do not constitute type
@c expressions.  However they can be part of some type constructor, like
@c in structs and unions.

@c @section Cycles in Type Expressions

@c Poke imposes the restriction that no type can be referred by name
@c before it is declared.  Therefore, it is not possible to define
@c recursive types and the graphs used to implement type expressions
@c can't have cycles.

@node Integer Types
@section Integer Types

Most of the values manipulated in Poke programs are whole numbers, also
typically known as @dfn{integers} in computing parlance.  This is
because integers are pervasive in binary formats.

Most general-purpose programming languages provide a small set of
integer types, each featuring a range corresponding to strategic
storage sizes: basically, signed and unsigned variants of 8, 16, 32,
64 bits.  When integers having an ``odd'' width (like 13 bits, for
example) get into play for whatever reason, the programmer is required
to use the integer arithmetic operators (and sometimes bit-wise
operators) herself, in a clever way, in order to achieve the desired
results.

Poke, on the contrary, provides a rich set of integer types featuring
different widths, in both signed and unsigned variants.  The language
operators are aware of these types, and will do the right thing when
operating on integer values having different widths.  XXX xref: see
arithmetic operators.

Unsigned integer types are created using the type constructor
@code{uint<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{(0,64]}.

Similarly, signed integer types are created using the type constructor
@var{int<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{(0,64]}.

Note that expressions are not allowed in the type integral constructor
parameters.  Not even constant expressions.  Thus, things like
@code{int<foo>} and @code{uint<2+3>} are not allowed.

@node Offset Types
@section Offset Types

@node String Type
@section String Type

Poke supports a notion of @dfn{strings} which is very similar to the C
programming language: a string value is a sequence of characters that
is terminated by the so-called @dfn{null character}.  String values,
and the operations allowed on them, are described in detail in later
chapters.

There is only one type for Poke string values (the lenght of the string
is not part of its type) and the type constructor is simply the
reserved word @code{string}.

@node Struct and Union Types
@section Struct and Union Types

@c XXX: in this section we use struct literals, which are described
@c later in @xref.

@node Array Types
@section Array Types

Arrays type constructors are denoted using the following syntax:

@example
[]@var{type}
@end example

Where @var{type} is the type of the elements contained in the
array.

Examples:

@example
[]int32
[]uint64
[]string
[]char
@end example

The elements contained in an array can be arrays themselves.  This is
how you would declare a type of such an array:

@example
[][]int
@end example

Note that, unlike in many other programming languages, no boundaries
are expressed in the array type definitions.  This is because in poke
the actual size of an array is not part of its type.  This means that,
for example, an array containing four 32-bit integers has the same
type than an array containing four hundred 32-bit integers:
@code{[]int}.  See the section on type equivalence below for details.

@node Type Equivalence
@section Type Equivalence

The checking rules described below uses the notion of equality among
type expressions: "if T1 and T2 are equal".

@b{R-TYPE-00}: Poke uses structural equivalence for all types, but for
struct and union types, which are compared by name.

Note however that not all the components of the type expressions are
used in the equivalence rules.  The structural equivalence algorithm
implements some modified notions of equivalence.  For example, two
array types are equivalent even if they have a different number of
elements defined in their type expression.

Structural equivalence rules:

@example
IF T1.type = string AND T2.type = string
   RETURN true;
IF T1.type = int<s1> AND T2.type = int<s2>
   RETURN s1 == s2;
ELIF T1.type = uint<s1> AND T2.type = uint<s2>
   RETURN s1 == s2;
ELIF T1.type = offset<t1,u1> AND T2.type = offset<t2,u2>
   RETURN t1 EQUAL t2 AND u1 == u2
ELIF T1.type = t11 x t12 AND T2.type = t21 x t22
   RETURN t11 EQUAL t21 AND t12 EQUAL t22
ELIF T1.type = t1[] AND T2.type = t2[]
   RETURN t1 EQUAL t2
ELIF T1.type = struct @{name=n1@} AND T2.type = struct @{name=n2@}
   RETURN n1 == n2
ELIF T1.type = union @{name=n1@} AND T2.type = union @{name=n2@}
   RETURN n1 == n2
ELIF T1.type = (T11, ..., T1n) : T10 AND T2.type = (T21, .., T2n) : T20
   RETURN T10 EQUAL T20 AND (T11 EQUAL T21 AND ... T1n EQUAL T2n)
@end example

@c XXX move this paragraph to the pokeint manual.
The Poke compiler function @code{pkl_ast_type_equal} implements the
equivalence rules described above.

Anonymous struct and union types are never equivalent to any union type,
not even to themselves, thus:

@example
defvar s = @{.foo=10,.bar=20@};
s = @{.foo=30,.bar=40@};  /* Type error.  */
@end example

@node Type Attributes
@section Type Attributes

@c @section Overloading of Operators

@c Certain Poke operators are overloaded.  For example, addition is
@c supported for integer types of any type, and also for strings.

@c However, the overloading of operators in Poke are carefully designed in
@c a way it is always possible to infer the type of the result of the
@c operator based on the types of the arguments.

@c This means it is possible for an implementation to perform type
@c checking of expressions in a single pass, using synthetized attributes
@c only.  No second top-down pass to narrow types is ever necessary.

@c For example:

@c @example
@c int<N> + int<N> -> int<N>          @r{is defined}.
@c int<N> + int<N> -> int<N*2>        @r{is NOT defined}.
@c @end example

@c @section Type Checking of Expressions

@c R-TYPE-02: The type of the Nth actual parameter passed in a function
@c call should match the type of the Nth formal argument defined in the
@c function type of the function being called.

@c @section Type Checking of Statements

@c In Poke statements do not have types, but expressions can appear in
@c certain statements, and the types of these expressions are checked
@c according to the following rules.

@c @b{R-TYPE-01}: The type of the expression in the right-hand side of an
@c assignment statement should match the type of the variable in the
@c left-hand side.

@c @b{R-TYPE-03}: Record and union type specifiers are only allowed in
@c deftype constructions and embedded in other struct and union type
@c specifiers.  In particular, these specifiers are not allowed in
@c function argument lists and casts.

@c @b{R-TYPE-04}: The type of the expression in the condition part of a
@c conditional statement should be an integral type, suitable to be
@c promoted to a signed 32-bit integer.

@c @b{R-TYPE-05}: The type of the expression in the condition part of a
@c while statement should be an integral type, suitable to be promoted to
@c a signed 32-bit integer.

@c @b{R-TYPE-06}: The type of the expression in an expression statement
@c should be @code{void}, i.e. a call to a function that doesn't return
@c any value.

@c @section Type Checking of Type Specifiers

@c As described above, type constructors may contain other types, either
@c directly or indirecly.

@c An example of a direct type inclusion is the type of the elements
@c specified in an array type constructor.  An example of an indirect
@c type inclusion is the type of the constant expression denoting the
@c units in an offset type constructor.

@c Thus the Poke type system also includes checks for types contained in
@c type expressions, and these are listed below.

@c @b{R-TYPE-07}: An array type specifier may contain an expression
@c denoting the number of elements it contains, but only when it appears
@c in a field in a struct type.  Thus, @code{struct @{int[10] foo;@}} is
@c valid, but @code{defun foo = (int[10] a) @{...@}} isn't.

@c @b{R-TYPE-08}: The type of the expression denoting the number of
@c elements in an array type constructor should be suitable to be
@c promoted to an @code{uint<64>}.  (See promotion rules in XXX xref).

@c @b{R-TYPE-09}: The expression denoting the number of elements in an
@c array should be constant.  (See constant expressions in XXX xref).

@c @b{R-TYPE-10}: The base type of an offset type should be an integral
@c type.  For example, @code{offset<string,1>} is not valid.

@c @b{R-TYPE-11}: The type of the expression denoting the unit of an
@c offset type specifier should be suitable to be promoted to an
@c @code{uint<64>}.

@c @b{R-TYPE-12}: The type of the expression denoting the unit of an
@c offset type specifier should be constant.

@c @section Type Promotion

@c XXX document promotion rules here.

@node Integers
@chapter Integers

@c       Integer Literals
@c       Comparison of Integers
@c       Arithmetic Operations
@c       Bitwise Operations
@c       Integer Attributes

@menu
* Integer Literals::		Writing integers in different bases.
* Characters::		        Another way to write little integers.
@end menu

@node Integer Literals
@section Integer Literals

Integers literals can be expressed in several numeration bases.

@emph{Decimal numbers} use the usual syntax @code{[1-9][0-9]*}.  For
example, @code{2345}.

@emph{Octal numbers} are expressed using a prefix of zero or more
@code{0} digits with syntax @code{0[0-9]+}.  Examples are @code{00},
@code{0100} and @code{0777}.

@emph{Hexadecimal numbers} are expressed using the syntax
@code{0[xX][0-9a-fA-F]+}.  Examples are @code{0x0} and
@code{0xfe00ffff}.  Note that both the @code{x} in the prefix and the
letters in the hexadecimal number are case insensitive.  Thus,
@code{0XdeadBEEF} is a valid (but ugly as hell) literal.

@emph{Binary numbers} are expressed using the syntax
@code{0[bB][01]+}.  Again, the @code{b} in the prefix is
case-insensitive.  Examples of binary literals are @code{0b0} and
@code{0B010}.

Note that negative numbers, of any numeration base, are constructed
using the minus operator as explained below.

@subsection The digits separator @code{_}

The character @code{_} can appear anywhere in a numeric literal other
than leading them.  It is ignored, and its purpose is to make it
easier for programmers to read them:

@example
0xf000_0000_0000_0000
0b0000_0001_0000_0001
@end example

@subsection Types of integer literals

The type of a numeric literal is the smallest signed integer capable
of holding it, starting with 32 bits, in steps of powers of two and up
to 64 bits.@footnote{Rationale: the width of a C ``int'' is 32 bits in
most currently used architectures, and binary data formats are usually
modeled after C.}

So, for example, the value @code{2} has type @code{int<32>}, but the
value @code{0xffff_ffff} has type @code{int<64>}, because it is out of
the range of signed 32-bit numbers.

A set of suffixes can be used to construct integer literals of certain
types explicitly.  @code{L} or @code{l} is for 64-bit integers.
@code{H} or @code{h} is for 16-bit integers (also known as
@dfn{halves}), @code{B} or @code{b} is for 8-bit integers (also known
as @dfn{bytes}) and @code{n} or @code{N} is for 4-bit integers (algo
known as @dfn{nibbles}).

Thus, @code{10L} is a 64-bit integer with value
@code{0x0000_0000_0000_000A}, @code{10H} is a 16-bit integer with
value @code{0x000A} and @code{10b} is a 8-bit integer with value
@code{0x0A}.

Similarly, the signed or unsigned attribute of an integer can be
explicitly specified using the suffix @code{u} or @code{U} (the
default are signed types).  For example @code{0xffff_ffffU} has type
@code{uint<32>} and @code{0ub} has type @code{uint<8>}.  It is possible
to combine width-indicating suffixes with signedness suffixes:
@code{10UL} denotes the same literal than @code{10LU}.

The above rules guarantee that it is always possible to determine the
width and signedness of an integer constant just by looking at it,
with no ambiguity.  This is important, because very often numbers are
used in commands like @code{poke} and @code{peek} where these
attributes determine the number of bytes written/read to/from the IO
space, and their encoding.

@node Characters
@section Characters

8-bit unsigned integers can use an alternative literal notation that
is useful when working with @emph{ASCII character codes}.  Printable
character codes can be denoted with @code{'c'}.

Non-printable characters can be expressed using escape-sequences.  The
allowed sequences are:

@table @code
@item \n
New-line character (ASCII 012).
@item \t
Tab character (ASCII 011).
@item \[0-9][0-9][0-9]
Character whose ASCII code is the specified number, in octal.
@end table

Examples:

@example
'o'
'\n'
'\t'
'\0'
@end example

The type of a character literal is always @code{char}, aka
@code{uint<8>}.

@node Strings
@chapter Strings

@menu
* String Literals::		Writing string values.
@end menu

@node String Literals
@section String Literals

NULL-terminated sequences of ASCII codes can be denoted using the
following syntax:

@example
"foo"
@end example

The above string is of type @code{string}.

Note that the empty string @code{""} corresponds to the array
@code{[0x0]}, which is a valid array containing at least one
element.

The following escape sequences are supported inside string literals:

@table @code
@item \DDD
Where @var{ddd} is a one to three digits octal number.  The escape
sequence denotes the ASCII character having that code.  It must be in
the range @code{0-127}.  For example @code{\000} denotes the ASCII
@code{NULL} character.
@item \xHH
Where @var{hh} is a one to two digits hexadecimal number.  The escape
sequence denotes the ASCII character having that code.  For example
@code{\x38} denotes the @code{8} character.
@item \"
Denotes a double quote.
@item \n
Denotes a new line character.
@item \t
Denotes an horizontal tab.
@end table

@node Arrays
@chapter Arrays

@menu
* Array Literals::		Writing array values.
@end menu

@node Array Literals
@section Array Literals

Array literals are constructed using the following syntax:

@example
[<exp>, <exp>, ..., <exp>]
@end example

Where @code{<exp>} is an arbitrary expression.

For example, @code{[1,2,3]} constructs an array of type
@code{[]int<32>} containing three elements.  Likewise,
@code{['a','b','c']} constructs an array of type @code{[]uint<8>}
containing three elements.

The type of the array literal is inferred from the type of its
elements.  Accordingly, all the elements in an array literal must be
of the same type.  Examples of invalid array literals, that will raise
a compilation-time error if evaluated, are:

@example
[1,2u,3]
[1,0xffff_ffff,3]
['a',"b",'c']
@end example

Arrays must contain at least one element.  Accordingly, @code{[]} is
not a valid array literal.

This is how a @code{3x3} matrix could be constructed using an array of
arrays:

@example
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
@end example

It is possible to refer to specific elements when constructing array
literals.  For example, @code{[1, 2, 3, .[3] = 4]} denotes the same
array than @code{[1, 2, 3, 4]}.

This allows creating arrays without having to specify all its
elements.  Unspecified elements have the value @code{null}.  For
example, @code{[.[2] = 2]} denotes the same array than @code{[null,
null, 20]}.

@c XXX
Note that an array element should only be referred once.  Accordingly,
@code{[1, 2, 3, .[1] = 10]} is not a valid array literal.

@node Structs and Unions
@chapter Structs and Unions

@section Flattening

Useful idiom: a struct containing common fields can be defined and
used as a flattening inside the union alternatives.  The type
@code{packet_epilogue} is not visible from outside the union.

@example
deftype Packet =
  union
  @{
    deftype PacketEpilogue = struct @{ uint32 quux; @};

    struct
    @{
      uint32 type = 0x0;
      byte[1024] data;
      PacketEpilogue;
    @} audio;

    struct
    @{
      uint32 type = 0x1;
      byte[2048] data;
      PacketEpilogue;
    @} video;
  @};
@end example

The desugared version of a conditional struct field is a flattened
union with an empty alternative.

@example
deftype foo =
  struct
  @{
    int f1;
    int f2 if f1 > 0;
  @};
@end example

@noindent
is equivalent to

@example
deftype foo =
  struct
  @{
    int f1;
    union
    @{
      int f2 : f1 > 0;
      struct @{@};
    @};
  @};
@end example

@noindent
Flattened structs can also be conditional:

@example
deftype foo =
  struct
  @{
    int f1;
    struct
    @{
      int f2;
      int f3;
    @} if f1 > 0;
  @};
@end example

@noindent
is equivalent to

@example
deftype foo =
  struct
  @{
    int f1;
    union
    @{
      struct @{ int f2; int f3; @} : f1 > 0;
      struct @{@};
    @};
  @};
@end example

@noindent
Video file example.

@example
deftype vfile = tag [];

deftype Tag =
  union
  @{
    deftype TagCommon =
      struct
      @{
        int flags;
        int reserved;
      @};
    
    struct
    @{
      int tag_type = TAG_VIDEO;
      TagCommon;
      uint64 time;
      byte[1024] data;
    @} video;

    struct
    @{
      int tag_type = TAG_SCRIPT;
      TagCommon;
      string code;
    @} script;

    struct
    @{
      int tag_type = TAG_NULL;
      TagCommon = @{ .flags = 0, .reserved = 0 @};
    @} null;
  @};
@end example
  
Compare the above with the following version where flattening is not
used at all.  The type `tag' is changed to a struct and an additional
union is nested, very C-like.

@example
deftype Tag =
  struct
  @{
    int tag_type;
    int flags;
    int reserved;

    union
    @{
      struct
      @{
        uint64 time;
        byte[1024] data;
      @} video : tag_type == TAG_VIDEO;

      struct
      @{
        string code;
      @} script : tag_type == TAG_SCRIPT;

      struct
      @{
      @} null : tag_type = TAG_NULL;
      
    @} data;
  @};
@end example

@c XXX
@noindent
Flattening also works with enums.

@example
deftype relocs =
  enum <int> (int mach)
  @{
    enum <int>
    @{
      R_SPARC_FOO = 1,
      R_SPARC_BAR = 2
    @} if mach == SPARC;

    enum <int>
    @{
      R_ALPHA_FOO = 1,
      R_ALPHA_BAR = 2
    @} if mach == ALPHA;
  @};
@end example

@node The Standard Library
@chapter The Standard Library

@menu
* Integer Standard Types::	@code{int}, @code{long} and friends.
@end menu

@node Integer Standard Types
@section Integer Standard Types

@table @code
@item char
8-bit ASCII code.
@item byte
@item uint8
Unsigned 8-bit integer.
@item int8
Signed 8-bit integer.
@item uint16
Unsigned 16-bit integer.
@item short
@item int16
Signed 16-bit integer.
@item int
@item int32
Signed 32-bit integer.
@item uint32
Unsigned 32-bit integer.
@item long
@item int64
Signed 64-bit integer.
@item uint64
Unsigned 64-bit integer.
@end table

@node Future Extensions
@chapter Future Extensions

@section Future Extensions to the Type System

The idea is to evolve the type system, in subsequent versions, in a
backwards-compatible way:

@itemize @bullet
@item
Support for recursive types.  It may be useful, although binary file
formats are seldom defined in a recursive way.  In most (all?) cases,
offsets are used instead.

@item
Supporting dynamic integer types, i.e. variable types,
eg. @code{int<@var{exp}>} where @var{exp} is not constant.

@item
Evolve into a kind of gradual typing, to provide more dynamism while
keeping the control and efficiency associated with static typing.
@end itemize

@section Other future extensions

@itemize
@item
Allow constant expressions in integral type constructors, like
@code{uint<2+3>}.
@end itemize

@c XXX: for the struct chapter
@c XXX: We need to be able to specify that an unbounded array is of some given
@c     size (sizeof) i.e. the array elem type is applied until: a constraint
@c     fails or the byte size of the array is achieved or EOF is found.  Very
@c     interesting :)  Sometimes you don't know the number of elements, but you
@c     know the total size of the array.
@c
@c          [OFFSET]TYPE
@c
@c     This is because array elements, despite all being of the same
@c     type, can have different sizes if they are structs or unions.
@c
@c @example
@c defvar int[32] a;  /* Array of 100 integers.  */
@c defvar int[128#B] a; /* Array of 128 bytes, i.e. 100 integers.  */
@c @end example
@c
@c    Example: dwarf CFA expression:
@c
@c @example
@c deftype dwarf_cfa_expression =
@c   struct
@c   @{
@c     uint128 reg;
@c     uint128 len;
@c     dwarf_op[#len] expr; /* An error is raised if the elements
@c                             of EXPR do not sum exactly LEN bytes.  */
@c   @};
@c @end example
@c 
@c     Note that if LEN is not achieved because of an union constraint
@c     failure, this will catch the error (the union constraint failure
@c     won't.)  Put an example.

@node Structs
@chapter Structs

Structs, or structures, allow to group several data structures, called
@dfn{fields}, together.

XXX Fields have an order inside the containing struct, and also an
    offset.  The offset and the order are independent.

XXX iterating through struct fields.  In offset order?  Or in field
    definition order?  Configurable?

XXX evaluation algorithm.  Poke must work on a staging area for the
    region i tis operating on, working recursively with rollback.  In
    fact, the struct evaluation algorithm performs backtracking.

XXX Problem: How to raise constraint marks in unions?  Maybe a warning()
    function that returns true but logs/marks a warning?

XXX how to handle recursive definitions?  With defrectype?  Or with
    forward references?

XXX versioned types

XXX Explain how it is possible to define procedures inside structs,
    and how can they be accessed using the dot-notation, very similar
    fields are accessed.  The same scope and visibility rules are used
    for procedures.

XXX Use the deflate format to show how structs can generally be
    bit-aligned.  For an example of a bit-oriented format, see
    deflate.pk.

@example
deftype elf =
   versioned("1.0") struct
   @{
     ...
   @}
@end example

   The version above is not of the ELF format, but of the poke spec.
   This is an important distinction.  Useful for the binary diffs.

Structs are collections of heterogeneous values.

A struct defines the layout of an area in IO space.  They are defined
as follows:

@example
struct
@{
  @var{field1};
  @var{field2};
  ...
  @var{fieldN};
@};
@end example

where @var{field1}..@var{fieldN} are the definitions of fields.  It is
legal to have an empty struct, i.e. with no field defined.

@var{qualifiers} is a list of optional qualifiers for the struct
contents:

@table @code
@item lsb
The default endianness of the struct contents is little-endian.
@item msb
The default endianness of the struct contents is big-endian.
@end table

Each field is defined as follows:

@example
[@var{label}:] [@var{qualifiers}] @var{type} @var{field}[: @var{constraint}];
@end example

where @var{label} is an optional offset relative to the beginning of
the struct.  The field is located @var{label} bytes in the struct.

@var{qualifiers} is a list of optional qualifiers for the field:

@table @code
@item lsb
The contents of the field are stored in little-endian.
@item msb
The contents of the field are stored in big-endian.
@end table

@var{type} is the type of the field.  @var{field} is the name of the
field, which must be unique in the containing struct.

@section Struct Types

A struct type is
denoted using the following syntax:

@example
struct @{<type> [<name>];[<type> [<name>];]...@}
@end example

Where @code{<type>} is any type or @code{<null>}.

The type of a struct containing three 32-bit signed integers is
@code{struct @{int64; int64; int64;@}}.  Similarly, the type of a struct
containing a string, an unsigned 8-bit number, and a character is
@code{struct @{string; byte; char@}}.

The order of the struct elements is significant.  For example, the type
@code{struct @{int; long;@}} is different than the type
@code{struct @{long; int;@}}.

The type of an empty struct, i.e. a struct with no elements, is
@code{struct @{@}}.

It is possible to name some (or all) of the struct constituents.  For
example, if we wanted to define a struct to store information about a
person, we could do it like @code{struct @{int age; string name;@}}.
The element names are significant, i.e. the type @code{struct @{int
foo; int bar;@}} denotes a different type than @code{struct @{int baz;
int quux;@}}.

@section Struct Constructors

Struct literals are constructed using the following syntax:

@example
@{[[[.<name> =] <exp>][,[.<name> = ] <exp>]...]@}
@end example

Where @code{<exp>} are arbitrary expressions.  For example, a strct
containing three signed 32-bit integers can be constructed as
@code{@{10, 20, 30@}} and it is of type @code{struct @{int; int;
int;@}}.  Similarly, @code{@{age, name@}} would construct a type
@code{struct @{int;string;@}} provided @code{age} and @code{string}
are variable holding values of the appropriate type.

For example:

@example
@{10, "foo", 'x'@}
@end example

An empty struct is denoted by @code{@{@}}.

It is possible to specify named elements in a struct literal, like in
@code{@{.age = 37, .name = "Jose"@}}.  The struct constructed this way
has type @code{struct @{int age; string name@}}, i.e. the ordering of
the named members follows their appearance in the literal.

Constructing a named struct type is done with:

@example
packet @{...@}
@end example

XXX: discuss anonymous fields.
XXX: discuss labels and offsets.

     Offsets are just numbers associated with members of composite
     types (structs, bitmaps, unions and arrays).  All members of
     unions have offset 0.  When a type is constructed (from a
     literal, or zeroed, or from an IO map) the members get their
     offsets.

     Two types: offset in bytes (:) and offset in bits (::).

     They are always unsigned 64-bit integers, i.e. they have type
     uint64.

     When a field or array member is defined, and its size determined,
     a location counter is increased by the number of bytes that the
     field occupies.  This new value of the counter is the offset
     assigned to the next field, unless it features a label.

     Note that the order of fields and array members is not correlated
     with their offsets.  This means that the element @code{a[10]} may
     have an offset bigger than @code{a[2]}, for example.  Usually,
     however, the offset is the one expected, i.e. @code{a[10]} will
     have offset @code{4 * 10} if it is an array of 32-bit integers.

     Offsets are used to map elements to IO space.  Conceptually, the
     offset of a non-composite type is always @code{0}, i.e. the IO
     offset of a @code{int @@ 0xff} is @code{0xff + 0}.  Mapping-offset
     + offset.  (XXX: this is elegant.)

     The operator @@field can be used to get the offset in bytes of a
     field inside its containing struct.  It doesn't work with bitmap
     fields.

     Note that if the label of an array contains a *$index construct,
     it is interpreted as the offset within the current structure of
     _each_ element, _not_ of the array itself.  This syntax works
     because it doesn't make sense to define both simultaneously.

XXX: pinned structs

@example
struct
@{
  int f1;
 @@f1:
  int f2;
@};
@end example

   Use use pinned structs:

@example
pinned struct
@{
  int f1;
  int f2;
@};
@end example
  
   The location counter is not advanced when a pinned struct is
   processed.  Labels can be used with pinned fields with the usual
   semantics.

XXX: discuss struct parameters and struct attributes.

   The arguments to structs and unions should be preserved, because
   they can be part of the tag of contained unions.

   They can be accessed using foo.attr, like local variables, and are
   read_only.  By default they are visible, but this can be changed
   using the `hidden' qualifier, like variables and procedures.

   Attributes are inheritable in structs/unions lexical scopes.

   Support for initial values for default arguments.

XXX: discuss component constraints.


    Named constraints:

      int foo : foo > 10;      /* Error constraint.  */
      int foo final: foo > 10; /* Final constraint.  */
      or int foo $: foo > 10;
      int foo warning: foo > 10; /* Warning.  *

    These constraints can be combined:

      int foo : foo > 10 warning: foo == 8 final: foo == 5;

XXX: discuss lazy projection in structs.

XXX: discuss recursive structs and forward declarations.

XXX: document the operator 'is' for united values.

XXX: assignment to structs.

@example
     if (doc.elements[20] is timestamp)
        bleh;

     for (section in elf.sections)
        if (section is progbits)
         ...
        else if (section is symtab)
         ...

     Support also a switch statement for is?

     for (elf_section section in elf.sections)
       switch (tagof (section))
         @{ 
          case progbits: bleh;
          case symtab: bleh;
         @}
@end example

@example
struct file
@{
   uint64 size;
   struct record[size] records;
@}
@end example

@example
(poke) defvar file f @@ 0x0     <- this reads nothing.
(poke) print f.size            <- this reads size.
1000000000
(poke) print f.records[10000]  <- this reads a record.
record @{....@}
@end example

XXX: discuss the deprecated field qualifier.

XXX: discuss the `reserved' field qualifier.

XXX: discuss about the two idioms for union tags: tag outside of the
union leading to names like foo.contents.date or tag inside of the
union (relying on recursive propagation of constraint failures)
leading to names like foo.date.value.  What idiom works best probably
depends on the context. Show examples for both cases (bson elemens
works better with the second idiom, for example.)

XXX: discuss using offsets to make chains of structs

@example
struct inode
@{
  uint32 perms;
  uint32 size;
  byte[size] data;
  uint32 next;
@};

void zero_inodes (inode i)
@{
  if (i.perms & INODE_WRITE)
    i.data[0:i.size] = 0x0;

  if (i.next != 0)
    print_inodes (inode @@ i.next);
@}
@end example

@section Casting Structs

Casts to structs use the usual syntax @code{(<type>) <exp>} and can be
applied to struct values.

However, when casting to struct types featuring more than one element,
an alternative syntax can be used: @code{(int,long) <exp>} is
equivalent to @code{((int,long)) <exp>}.  This abbreviated form can't
be used to cast to tuples having one element, because it is
indistinguishable to casts to other types.  For example @code{(int)
<exp>} is a cast to type @code{int}, not to type @code{(int)}.

Casts can be used to ``augment'' a tuple.  For example
@code{(int,long,long)@{10,20@}} is augmented to the tuple
@code{@{10,20,null@}}.

Casts can be used to ``reorder'' the named elements in a tuple
literal.  For example, @code{(string name, int age) @{.age = 30, .name
= "Jose"@}} generates the struct @code{@{"Jose", 30@}} of type
@code{(string name, int age)}.

XXX metatypes

@example
    deftype int32 = sbit<32>;
    deftype uint32 = ubit<32>;

    defset foo = enum @{ a = 1, b = 2 @};
    defset bar = bitmask @{ a = 0x1, b = 0x4 @};

    foo<int>
    bar<bit<32>>
@end example

    Syntactic sugar to avoid to have to declare an explicit metatype:

@example
deftype foo = enum<bleh> @{ ... @};
@end example

XXX Getting attributes of types?  With sizeof and friends...

XXX discuss bitmaps

 Bitmaps contain bit fields.
 If named, a bitmap can always be used like its base type, i.e. like
 an integral field.
 Bit endianness: msbit, lsbit.
 Byte endianness: msb, lsb.
 Labels are not allowed in bitmaps.
 Projection works with bitmaps.

 Writing bit fields involves doing bit-wise logical operations (or to
 set, and to clear, and shifts) on the containing type:

 (poke) poke a.bitfield, 0xf
 0xfeeffeef <- 0xdeadbeef | 0xf << 3

@example
deftype audio_props =
  struct
  @{
     bit<4> flv_sound_format format = FLV_AAC;
     bit<2> flv_sound_rate rate = FLV_RATE_44K;
     bit<1> flv_sound_size size;
     bit<1> flv_sound_type type = FLV_SND_STEREO;
  @};
@end example

By default the type of each bit field is interpreted as having the
same width than the width of the bitmap, and the sign is determined by
either @code{bit:N} or @code{sbit:N}.

Is it possible to operate on bitmaps like if they were integer types?
This would allow to use:

@example
struct
@{
  struct
  @{
     bit:28 elf_sym_binding st_bind;
      bit:4 elf_st_type (mach) st_type;
  @} st_info;
@}
@end example

instead of

struct
@{
  pinned uint32 st_info;
  struct
  @{
     bit:28 elf_sym_binding st_bind;
      bit:4 elf_st_type (mach) st_type;
  @};
@}

XXX alignment checks for structs and fields.  Something like:

@example
aligned(32) struct
@{
  int i;
  long l;
@};
@end example

@node Unions
@chapter Unions

XXX: discuss unions.  Tags, arguments, lexical scope, etc.  Provide
some examples on how to model some real-life situations in binary
formats, like the BSON elements.

XXX: mention how it is better to define struct types at the toplevel
instead of using in-situ structs, because that allows the user to map
them wherever she wants in IO space, and to use constructors for
matching etc.

- Arguments to boolean operators are promoted to signed 32-bit
  integers.

XXX: optional fields.

@example
     optional int f;
@end example

     is equivalent to:

@example
    union
     @{
       int f;
       struct @{@};
     @};
@end example     

     Note that if f does not have constraints associated with it, then
     it will be always present.

XXX Explain how unions play the declarative role of conditionals.

@node Enumerations
@chapter Enumerations

XXX: enumerations and bitmasks are set types.  They should be
discussed in the same chapter.  In contrast, struct an bitmaps are
product types.  unions are sum types.

Enumerations are collections of related constants.  They use the
following syntax:

@example
enum @var{type} @var{tag}
@{
   @var{enumerator1} [= @var{value1}],
   @var{enumerator2} [= @var{value2}],
   ...
   @var{enumeratorN} [= @var{valueN}][,]
@}
@end example

Where:

@table @var
@item type
Is the base type of the enumeration.  It should be an integer type.
@item tag
Is the name of the enumeration.  It should be unique in the global
scope.
@item enumeratorN
Are the names of the enumerators.
@item valueN
Are initialization values.  They should be expressions evaluating to
constant values valid for @var{type}.

If an explicit initialization value is not specified for an
enumerator, an implicit value is used.  The implicit value is
initially @code{0}, and increased by one every time it is used.
@end table

An enumeration  must contain at least one enumerator.

Enumerations do not provide its own lexical scope.  The enumerators
should be unique in the global scope.  It is highly recommended to use
prefixes to avoid conflicts.

@node Bitmasks
@chapter Bitmasks

@example
bitmask elf_xword elf_sh_flags
@{
  /** Section contains data that should be writable during process
      execution.  */
  SHF_WRITE = 0x1,

  /** Section occupies memory during process execution.  */
  SHF_ALLOC = 0x2,

  /** Section contains executable machine instructions.  */
  SHF_EXECINSTR = 0x4,
@}
@end example

@node Flattening
@chapter Flattening

We have already discussed how it is possible to omit the name of
fields when defining structs.  When this is done, an anonymous field
is defined.  Generally speaking, this means the field cannot be
accessed in a poke program, since struct components can only be
referred by name.  Due to this limitation, anonymous fields are
typically used for padding or other applications where the data stored
in the field doesn't need to be referenced.

However, the picture changes when the anonymous field is of a type
having named components itself.  In this case, it is still possible to
access to the named sub-components like if they were components of the
entity containing the anonymous field.  This is easy to see using an
example.

@example
deftype astruct =
  struct
  @{
     int f1;

     struct
     @{
        int f2;
        int f3;
     @};
  @}

defvar astruct s;
@end example

The struct above has two fields: an integer @code{f1} and a struct.
The struct field has no name (it is anonymous) so it is not possible
to refer to it explicitly.  However, its components (the fields
@code{f2} and @code{f3}) can be accessed using @code{s.f2} and
@code{s.f3} respectively.  This is called @dfn{flattening} in poke
parlance, and it is an important concept that makes it possible to
implement many useful idioms.

It is very important to note that flattening doesn't change the
structures it involves: @code{astruct} still contains an anonymous
struct field that in turn contains two fields.  In other words: the
fields @code{f2} and @code{f3} do not become fields of the outer
struct.

The compiler or the run-time will complain if flattening an anonymous
field would result in ambiguity, and will consider that an error in
the program.  This happens in the following example, where the field
@code{f1} introduces an ambiguity.

@example
struct
@{
   int f1;

   struct
   @{
      int f1;
      int f2;
   @};
@}
@end example

Flattening is transitive.  In the following example:

@example
deftype astruct =
  struct
  @{
     int f1;
     struct
     @{
        int f2;
        struct
        @{
          int f3;
        @};
     @};
  @}

defvar astruct s;
@end example

The three fields can be referred as @code{s.f1}, @code{s.f2} and
@code{s.f3} respectively.

@section Flattening Unions

Until now we have focused on structs when talking about flattening.
However, flattening can be used with any type featuring named
subcomponents.  This includes unions.

Consider the following example:

@example
deftype astruct =
  struct
  @{
     int f1;
 
     union
     @{
        int f2 : f1 == 0;
        int f3;
     @};
  @}

defvar astruct s;
@end example

In this case, the alternative active in the union can be accessed like
if it was a component of the outermost struct: either @code{s.f2} or
@code{s.f3}.

Transitive flattening also works with unions.  In the example below
both @code{f3} and @code{f4} are accessible as @code{s.f3} and
@code{s.f4} provided @code{s.f1} is not zero.

@example
deftype astruct =
  struct
  @{
     int f1;
 
     union
     @{
        int f2 : f1 == 0;
        struct
        @{
          int f3;
          int f4;
        @};
     @};
  @}

defvar astruct s;
@end example

Note that flattening unions can be tricky and should be used carefully:
since there is no way to refer to the union itself (it has no name)
the user must know what alternative of the union is active when the
flattened field is accessed.

XXX: we need full type reflection, to know what fields a struct has.
Maybe a field iterator?

Note that generally speaking flattening is a process that should be
done at run-time.  However, if unions are not involved, it happens at
compile-time instead for performance purposes.  For example, the
following struct:

@example
struct
@{
   int f1;

   struct
   @{
      int f2;
      int f3;
   @};
@}
@end example

is transformed at compile time to:

@example
struct
@{
   int f1;
   int f2;
   int f3;
@}
@end example

@section Flattening Bitmaps

Bit-fields defined in a bitmap can be flattened in exactly the same
way than struct fields.

@node Expressions
@chapter Expressions

PCL supports expressions in a very similar way than other programming
languages.

@menu
* Arithmetic Operators::	Operating with numbers.
* Logical Operators::		Building predicates.
* Relational Operators::	Equality and ordering.
* Bitwise Operators::		Working with bits.
* Operators on Arrays::		Operating on arrays.
* Conditional Operator::	if-then-else.
* The Cast Operator::		Changing the type of a value.
* Other Operators::		Stuff that is explained elsewhere.
* Operators Precedence::	What gets executed first.
* Parenthesized Expressions::	Grouping and changing precedence.
@end menu

@node Arithmetic Operators
@section Arithmetic Operators

The following left-associative binary arithmetic operators are
supported, in descending precedence order:

@itemize
@item Multiplication @code{*}, integer division @code{/} and modulus
      @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@end itemize

The following right-associative unary arithmetic operators are
supported:

@itemize
@item Unary minus @code{-} and unary plus @code{+}.
@end itemize

The arithmetic operators are defined on integer and character values.
Attempting to use them on another kind of value results on a run-time
error.

@node Logical Operators
@section Logical Operators

The following left-associative, short-circuited binary logical
operators are supported, in descending precedence order:

XXX: Add the ``implies'' operator => which is useful in constraints.

@itemize
@item Logical AND @code{&&}.
@item Inclusive OR: @code{||}.
@end itemize

The following right-associative unary logical operators are supported:

@itemize
@item Logical negation @code{!}.
@end itemize

@node Relational Operators
@section Relational Operators

The following binary relational operators are supported, in descending
precedence order:

@itemize
@item Equality @code{==} and inequality @code{!=}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=}.
@end itemize

When applied to integer and character values, these operators
implement an arithmetic ordering.  When applied to strings, these
operators implement a lexicographic ordering.

Only equality and inequality can be applied to arrays, structs and
unions.

XXX: equality on structs works as expected.  Ditto to arrays.

These operators resolve in boolean values encoded as 32-bit integers:
@code{0} meaning false and @code{1} meaning true.

@node Bitwise Operators
@section Bitwise Operators

The following left-associative bitwise binary operators are supported,
in descending precedence order:

@itemize
@item Bitwise shift left @code{<<} and bitwise shift right @code{>>}.
@item Bitwise AND @code{&}.
@item Bitwise exclusive OR @code{^}.
@item Bitwise inclusive OR @code{|}.
@item Bitwise concatenation @code{::}.
@end itemize

XXX bitwise concatenation works with any integral type, of any bit
    length.

The following right-associative unary bitwise operators are supported:

@itemize
@item Bitwise complement @code{~}.
@end itemize

Bitwise operators can be applied to integer values, with the expected
semantics.

@node Operators on Arrays
@section Operators on Arrays

@subsection Concatenation

The elements of two arrays can be concatenated using the
left-associative binary operator @code{+}.  For example:

@example
[1, 2, 3] :: [4, 5, 6]
@end example

evaluates to @code{@{1, 2, 3, 4, 5, 6@}}

The operator can also be applied to an array and a value of the same
type than the elements of the array.  This is called a @dfn{cons}, and
it is very useful to build arrays recursively.  For example:

@example
@{1, 2, 3@} + 4
@end example

evaluates to @code{@{1, 2, 3, 4@}}.

Note that the semantics of this operator vary a bit when applied to
arrays of ASCII codes, also known as strings.  In this case, the
@code{NULL} ASCII character finishing the first array is not included
in the concatenated value.  Thus the operation:

@example
@{'a', 'b', 0x0@} + @{'c', 'd', 0x0@}
@end example

evaluates to @code{@{'a', 'b', 'c', 'd', 0x0@}}.  Or, using string
notation:

@example
"ab" + "cd"
@end example

evaluates to @code{"abcd"}.

Likewise, the semantics of the cons operator also vary with arrays of
@code{char}:

@example
@{'f', 'o', 0x0@} + 'o'
@end example

evaluates to @code{@{'f', 'o', 'o', 0x0@}}.  Or, using string
notation:

@example
"fo" + 'o'
@end example

evaluates to @code{"foo"}.

@subsection Indexing

The elements of an array can be referred to using the left-associative
unary operator @code{[@var{idx}]}, where @var{idx} is a positive
integer.

For example, the operation @code{@{1, 2, 3@}[0]} evaluates to
@code{1}, while @code{@{1, 2, 3@}[2]} evaluates to @code{2}.

If the index refers past to the last element contained in the array,
then the operation evaluates to @code{null}, i.e. @code{@{1, 2,
3@}[4]} evaluates to @code{null}.

Negative indexes are not allowed and an error is raised if they are
used.

@c XXX: play with the idea of negative indexes?  Some formats may
@c store information before pointers, like ghostscript's memory
@c allocators do.

XXX: lengthof returns the number of elements of an array.

The indexing operator can also be used to refer to a region of the
array, using a range of indexes @code{[@var{idx1}:@var{idx2}]}.  The
denoted range is @code{[@var{idx1},@var{idx2}]}, i.e. the elements in
both positions are included in the range.  Note that @var{idx1} should
be less or equal than @var{idx2}, or an error is raised.

For example, the operation @code{@{1, 2, 3@}[0:1]} evaluates to
@code{@{1,2@}} and the operation @code{@{1, 2, 3@}[2:3]} evaluates
to @code{@{2,3@}}.

If @var{idx1} equals to @var{idx2}, the result of the operation is an
array of one element.  Thus, @code{@{1, 2, 3@}[1:1]} evaluates to
@code{@{2@}} whereas @code{@{1, 2, 3@}[1]} evaluates to @code{2}.  The
indexation of an array with a range always evaluates to an array.

If the range includes indexes past the end of the array, @code{null}
values are used accordingly.  For example, the operation @code{@{1, 2,
3@}[1:3]} evaluates to @code{[2, 3, null]}, which in turn is
@code{[2, 32]}.

Note that indexing an array range does not create a copy of the
elements.  Instead, both the operand array and the array resulting
from the operation refer to the same instance of the elements.  The
importance of this will become apparent when we talk about variables
later in this manual.

XXX it should be supported to assign a value to ranges:

@example
  data[0:size] = 0x0;
@end example

XXX: if either of the range ends are omitted, then the intuitive
semantics are used: [2:] means an array with the second to the last
element.  Ditto for [:2].

@subsection Inserting and removing elements

Poke supports language operators to insert and remove elements in an
array without having to involve loops and explicit copy operations.

XXX: problem.  With CBVS, are assignments to the array itself visible
outside??  Nope.  Also, can you pass an array range as an array?

For example:

@example
defvar array = [1,2,3,4];
array[1] := 0;  /* array is now [1,0,2,3,4]  */
@end example

or, use functional style:

@example
v = v[0] :: [@{0xb, 0xc@}] :: v[2:];
@end example

But in this case we have to define the assign to array operator.

Appending past the end of the array: fills with zeroes.

XXX: explain elsewhere how any poke type (basic or composite) can be
zeroed.  This is also used in variable initialization.

As we saw before, @code{null} is a special value that denotes the
absence of a value.  It is possible to remove elements from an array
by assigning @code{null} to them.  For example, @code{array[2] = null}
will remove the third element from @code{array}.  Ranges are accepted:
@code{array[0:lengthof array - 1] = null} will empty an array.

XXX: what syntax doesn't sucks ass??

@subsection Array member operator

Very useful in union constraints.
XXX: show realistic example.

@example
ELEM in ARRAY
@end example

@node Conditional Operator
@section Conditional Operator

The following right-associative ternary conditional operators are
supported:

@itemize
@item Conditional operator @code{? :}.
@end itemize

The conditional operator can be applied to integer and character
values.

XXX quantified ternary expressions

    forall ID in ARRAY_EXPR : BOOLEAN_EXPR

    It is true iff BOOLEAN_EXPR is true for all index ID in the array.

@example
   []int a : forall i in a : (i == 0) || (a[i] == a[i-1]+1);
@end example

XXX ternary inclusion operator (useful with enums):

    A in B : C.

@node The Cast Operator
@section The Cast Operator

The right-associative unary operator cast @code{(type)} can be used to
derive a new value having a different type from an existing value.

Casts between integer types are always allowed.  If the new type is
narrower than the existing type, truncation may be performed to
accommodate the value in its new type.  For example, the expression
@code{(uint8) 0x8765_4321} evaluates to @code{0x4321}.  If the new type
is wider than the existing type, either zero-extension or
sign-extension is performed depending on the signedness of the
operand.

The semantics of the sign-extension operation depends on the currently
selected negative representation encoding in @code{.nencoding}. @c
XXX: xref to section documenting @code{.nencoding}.

For example, in two's complement the expression @code{(uint16) 0xffff}
evaluates to @code{0x0000_ffff}.  However, @code{(int16)0xffff}
evaluates to @code{0xffff_ffff} in two's complement, and it evaluates
to @code{0xffff_0000} in one's complement.

Casts are also used in order to construct struct, union, enumerated
and bitmask values, as it is explained later in this manual. @c XXX:
@c xref to section documenting it.

@node Other Operators
@section Other Operators

Other operators, whose meaning and purpose is explained in full later
in this manual, are summarized here.

Left-associative binary operators:

@itemize
@item The map operator @code{@@}.
@end itemize

Left-associative unary operators:

@itemize
@item Member selection operator @code{.}.
@end itemize

Right-associative unary operators:

@itemize
@item @code{sizeof}, @code{bitsizeof}, @code{lengthof}, @code{startof} and @code{typeof}
@end itemize

@node Operators Precedence
@section Operators Precedence

The following table summarizes the precedence and the associativity of
all the operators described above, in descending order:

@table @code
@item Array subscript operator @code{[ ]}.
@item Member selection operator @code{.}.
@item Postfix increment @code{++} and postfix decrement @code{--}.
@item Prefix increment @code{++} and prefix decrement @code{--}.
@item Unary minus @code{-} and unary plus @code{+}.
@item Logical negation @code{!} and bitwise complement @code{~}.
@item Cast @code{(type)}.
@item @code{sizeof}, @code{startof} and @code{typeof}.
@item Array concatenation @code{+}.
@item Multiplication @code{*}, integer division @code{/} and modulus
      @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@item Bitwise shift left @code{<<} and bitwise shift right @code{>>}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=},
@item Equality @code{==} and inequality @code{!=}.
@item Bitwise AND @code{&}.
@item Bitwise exclusive OR @code{^}.
@item Bitwise inclusive OR @code{|}.
@item Logical AND @code{&&}.
@item Inclusive OR: @code{||}.
@item Ternary conditional operator @code{? :}.
@item Comma operator @code{,}.
@end table

@node Parenthesized Expressions
@section Parenthesized Expressions

Parentheses can be used in order to change the precedence of
sub-expressions, the usual way.

@node Constants
@chapter Constants

Constants are named values that don't change during the lifetime of a
poke program.

The definition of a constant uses the following syntax:

@example
const [@var{type}] @var{name} = @var{const_exp}
      (,[@var{type}] @var{name} = @var{const_exp})*;
@end example

This declares a set of constants with the given @var{name}s having the
value of the corresponding @var{const_exp}.  The expressions must be
constant, i.e. it should be possible to compute their values at
compile-time.

If a @var{type} is specified in a constant definition then the value
computed by the assignment expression must be of the same type, or an
error is raised.  Otherwise the type of the constant is the type of
the value computed by the expression.

Examples:

@example
const limit = 256;
const balance = 23U;
const offset = (uint64) 256;
const uint64 offset = 256;
const section_name = ".text";
const x = 'x', y = 'y';
@end example

@node Variables
@chapter Variables

XXX primitives to get struct's begin and end addresses (and, in
    general, of any variable).  beginof VAR, endof VAR?  What if the
    variable is not mapped to IO?

Variables are the association between a symbol and a value.  They are
declared using the @code{def} construction:

@example
defvar [<type>] <name> [= <exp>]
      (,[<type>] <name> [= <exp>)*;
@end example

Where @code{<name>} is a literal with the form
@code{[a-zA-Z_][a-zA-Z0-9_]*}.

The variable can be initialized with a value, which is the result of
computing the expression @code{<exp>}.  If no initial value is
provided then it is @code{null}.

Generally a variable can hold values of different types during its
life time.  However, if @code{<type>} is specified in a variable
declaration then only values of that type are allowed to be stored in
the variable.

It is important to note that poke variables are not stored in
addressable memory; and if they are, that is none of the business of
the poke programmer!

@section Variables Lifetime

Variables exist until the execution flow exits the scope where they
are declared:

@itemize
@item Variables declared in the top-level exist until poke exists.
@item Variables declared in the body of a function exist until the
      function exits.
@item Variables declared in the body of a struct or an union exist
      until the execution flow exits the struct or union.
@end itemize

@section Variables Scope

A variable is accessible in the lexical scope where they are declared,
and in the lexical scopes nested in the lexical scope where they are
declared.

For example, this is an error:

@example
@{
  defvar int i;
@}

i = 30;
@end example

But this is not:

@example
@{
  defvar int i;

  @{
    i = 30;
  @}
@}
@end example

Note that variables defined in inner scopes ghost variables with the
same symbol defined in an outer scope.

@node Statements
@chapter Statements

Statements are the basic execution units of poke programs.  Executing
a program means executing its statements one by one.  Their main
purpose is to perform some side-effect.

@menu
* Assignments::			Setting the value of a variable.
* Statement Blocks::		Sequences of statements.
* If::				Simple conditional.
* Switch::			Multiple conditional.
* While::			Iterating while some condition is met.
* For::				Iterating on indexes.
* For-in::			Iterating on arrays.
* Continue::			Jumping to the next iteration.
* Break::			Escaping a loop or a switch.
* Function Calls::		Calling a subroutine.
@end menu

@node Assignments
@section Assignments

The assignment statement stores a value in a variable.  It's syntax
is:

@example
<variable> = <exp>;
@end example

Where @code{<variable>} is the name of the variable and @code{<exp>}
is an expression.  The value computed by the expression can be of any
type, unless the variable is declared with a fixed type.

The value previously stored in the variable is lost, unless there are
other references to it. (This can happen with arrays, structs and
unions.)

There are several variants of the assignment statement that are
provided to shorten common idioms:

@example
<variable> <op>= <exp>;
@end example

which is equivalent to:

@example
<variable> = <variable> <op> <exp>;
@end example

Valid @code{<op>}s are addition @code{+}, subtraction @code{-},
multiplication @code{*}, integer division @code{/}, modulus @code{%},
bit-wise AND @code{&}, bit-wise exclusive OR @code{^}, bit-wise
inclusive OR @code{|}, bit-wise shift left @code{<<} and bit-wise
shift right @code{>>}.  @c xref to operators chapter.

@node Statement Blocks
@section Statement Blocks

Statements that are to be executed sequentially can be grouped in
@dfn{blocks} using curly brackets:

@example
@{
  <stmt>
  <stmt>
  ...
  <stmt>
@}
@end example

Syntactically a block is equivalent to a single statement.  This means
that in every place where a statement is valid, a block is also valid.

Statement blocks introduce a new lexical scope.

@node If
@section If

The @code{if} statement has the following form:

@example
if (<exp>) <then_stmt> [else <else_stmt>]
@end example

The expression @code{<exp>} is evaluated.  If it evaluates to
@code{true} then @code{<then_stmt>} is executed.  If
@code{<else_stmt>} is specified and @code{<exp>} evaluates to either
@code{false} or @code{null} then @code{<else_stmt>} is executed
instead.

@node Switch
@section Switch

The @code{switch} statement looks like:

@example
switch (<exp>)
@{
   case <exp>:
   <stmt>
   ...
   <stmt>
   case <exp>:
   <stmt>
   ...
   <stmt>
   ...
   default:
   <stmt>
@}
@end example

The expression @code{<exp>} is evaluated and the case expressions are
evaluated in order.  Whenever the value of a ase expression matches
the value of @code{<exp>}, the statements following it are executed.
More than one case may be entered.  The statements following
@code{default:} are always executed if the control flow reaches there.

If the special statement @code{break} is found, the control flow jumps
to the end of the switch statement.

@node While
@section While

@code{while} statements have the form:

@example
while (<exp>) <stmt>
@end example

@code{do-while} statements have the form:

@example
do <stmt> while (<exp>);
@end example

@code{for} statements have the form:

@node For
@section For

@example
for ([<exp>];[<exp>];[<exp>]) <stmt>
@end example

@node For-in
@section For-in

@code {for} statements have the form:

@example
for ([variable] in <exp>) <stmt>
@end example

@node Continue
@section Continue

The @code{continue} statement makes the control flow to jump to the
beginning of the nearest loop instruction.  If no such loop
instruction is found an error is raised.

@node Break
@section Break

The @code{break} statement makes the control flow to exit the nearest
containing loop or switch statement.

@node Function Calls
@section Function Calls

Functions are called:

@example
<name> ((<arg>[,<arg>])*);
@end example

Where @code{<name>} is the name of a defined function.  When called as
a statement, a warning is issued if a function returns anything but
@code{null}, because in that case the return value is discarded.

It is possible to name specific function arguments in a function call:

@example
printf (fmt = "this is %d", number);
@end example

@node Procedures
@chapter Procedures

Procedures are defined using the following syntax:

@example
defproc <name> ((<arg> [,<arg>]*)*) [<return_type>]
@{
  <function_body>
@}
@end example

Function arguments follow the following syntax:

@example
[<type>] [&]<name> [= <exp>]
@end example

Where @code{<name>} is the name of the argument.  If a @code{<type>}
is indicated, the value in the argument must be of that type.

The body of a function introduces a new lexical scope.

A @code{return} statement with the form:

@example
return [<value>];
@end example

may be used to return a value for the function.  If the function
doesn't return any value, it returns @code{null}.

A function can be defined at top-level scope, or inside a lexical
scope.  This included another functions.  This is useful to write
auxiliary functions without polluting the global name space (Poke is a
truly block-oriented language.)

XXX: normal passing: CBVS.  CBR using & in both formal argument and
actual parameter:

@example
void add_elf_section (elf_section &section)
@{
   section[lengthof section] := create_section ();
@}
@end example

Or using inout?

@section Optional Arguments

If an assignment operator and an expression is included, then the
argument is optional and has the value of @code{<exp>} should it not
be specified in a function call.

@section Variadic Functions

If the last argument of a function is initialized to an empty tuple,
then it will contain any extra argument.

@example
function printf (string fmt, args = @{@})
@{
   defvar int i;
   for (i = 0; i < sizeof (args); i++)
   @{
      /* Process argument.  */
   @}
@}
@end example

@section Recursive Functions

Functions can be recursive, both directly and indirectly.  For
example, this is a factorial implementation in poke:

@example
function factorial (n)
@{
  if (n == 0)
     return 1;
  else
     return n * factorial (n - 1);
@}
@end example

GNU poke supports tail-recursion.  This means that if a recursive
function is written in certain way, it is equivalent to iteration with
no memory allocated in each iteration.  This is important, since it
allows writing recursive functions operating on large structures in IO
space.

@node MappingB
@chapter MappingB

The idea is that the same poke code will execute on mapped and
non-mapped variables, with no changes.

@section The IO Space

We already discussed the @dfn{IO Space} in the chapters dedicated to
basic editing: it basically corresponds to the file, stream or memory
image being edited at the current time.  As we saw, all these entities
are uniformly handled as a single abstraction, called ``the current IO
space''.

From the point of view of a poke program, the IO Space is infinite: it
starts at offset @code{0} and extends to infinity.  However, at some
point it starts containing @code{eof}s.  @code{eof} is a special value
which is of any type, and is not equal to any other other value.

The following example:

@example
defvar a = byte[] @@ 0x0;
@end example

defines an array that covers the entire IO space.  Remember that empty
arrays extends until it reads @code{eof} or a constraint in its
constituent fails.  In this case the constituents of the array are
bytes, which can't be associated with constraints.

In theory this is an infinite loop:

@example
struct
@{
  byte b : b == eof;
@};

defvar a = elem_type[] @@ 0x00;
@end example

but in practice it is detected by the run-time and reported as a
run-time error, because reading @code{eof} does not advance the IO
space location counter.

XXX: the location counter (which is read-only) is not really
     necessary, but it avoids having to replicate logic all the way in
     structs, in order to determine which fields have been defined or
     not.

XXX: the equivalent of

     (poke) poke 0x0, 0xff

     is

     int32 @@ 0x0 = 0xff

     i.e. a map as a l-value creates a mapped variable.

     And the equivalent of

     (poke) peek 0x0

     is

     doshit (int32 @@ 0x0)

     i.e. a map as a r-value creates a mapped variable and then gets
     its value.

XXX: variable := type + value
     mapped variable := type + value + map(address)

XXX: getting attributes of maps: beginning offset and end offset.

@section The Map Operator

XXX: since we want dynamically typed variables, we can't associate
     maps with variables.  Instead, the @@ operator creates mapped
     _values:

@example
/* The @@ operator creates mapped _values_:  */

let i = int32 @@ 0x00; /* This evals to a mapped int32 value.  */

      i = 10; /* This replaces the value.  */

let packet = Packet @@ 0x00; /* This evals to a mapped Packet in an rhs.  */

      packet.field = 10;   /* This accesses IO.  */
      packet = @{0xa, 0xb@}; /* But this replaces the value of the variable.  */
           
let packets = Packet[] @@ 0x00; /* This evals to a mapped array value in an rhs.  */

      packets[0] = @{0xa, 0xb@};  /* This accesses IO.  */
      packets = [];  /* But this replaces the value of the variable.  */
@end example


@section Peeking and poking thru maps

XXX Explain handling of EOF: There is _never_ EOF poking to IO space:
    the file gets expanded as needed, with same semantics than a fseek
    in the underlying system.  When committing to the file, there
    could be an error if the file doesn't admit appending, or disk
    full, or whatever.  But that is another level.

@example
     defvar i = int @@ 0xffff;
     i = 25;
@end example

    Peeking can return EOF... or 0?

@section Endianness and Negative Encoding

The encoding of a mapped variable depends on its value, its type, the
current endianness and the current negative encoding method.

The current endianness is determined by the value of the special
variable @code{.endian}.  If @code{.endian == msb} then the encoding is
big-endian.  If @code{.endian == lsb} then the encoding is
little-endian.  The default endianness is determined by the endianness
used by the machine where GNU poke is running.

XXX: use big_endian(), little_endian(), twos_compl(), ones_compl() in
     constraints, to change the value of these attributes in the
     implicit evaluation state.

     or, an ``use'' construction?  Like in:

@example
use lsb if EXP;
use neg2comp if EXP;
@end example

The current negative encoding method is determined by the value of the
special variable @code{.nencoding}.  If @code{.nencoding == 1} the
negative quantities in integer values are encoded using one's
complement.  If @code{.nencoding == 2} then they are encoded using
two's complement.  The default is @code{2}.

XXX: Globals suck.  How to handle computed endianness like in elf??

@section Encoding

Integer values are de/encoded as follows:

@itemize
@item @code{char}, @code{byte}, @code{uint8} values are encoded as 8-bit
      unsigned stored values.  Nulls of this type are encoded to
      @code{0x00}.
@item @code{uint16}, @code{uint32} and @code{uint64} values map to
      16-bit, 32-bit and 64-bit unsigned stored values, respectively,
      with endianness @code{.endian}.  Nulls of this type are encoded
      to @code{0x0000}, @code{0x0000_0000} and
      @code{0x0000_0000_0000_0000} respectively.
@item @code{int8} maps to a 8-bit signed stored values with negative
      encoding @code{.nencoding}.  Nulls of this type are encoded to
      @code{0x00}.
@item @code{short}, @code{int16}, @code{int},
      @code{int32}, @code{long} and @code{int64} values map to 16-bit,
      16-bit, 32-bit, 32-bit, 64-bit and 64-bit signed stored values,
      respectively, with negative encoding @code{.nencoding} and
      endianness @code{.endian}.  Nulls of this type are encoded to
      @code{0x0000}, @code{0x0000_0000} and
      @code{0x0000_0000_0000_0000} respectively.
@end itemize

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi


@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
