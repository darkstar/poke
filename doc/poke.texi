\input texinfo
@comment %**start of header
@setfilename poke.info
@include version.texi
@settitle The Poke Book
@afourpaper
@comment %**end of header

@copying
This book describes GNU poke (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2017 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Database
@direntry
* poke: (poke). Interactive editor for binary files.
@end direntry

@titlepage
@title The Poke Book
@subtitle for version @value{VERSION}, @value{UPDATED}
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Poke Book

@insertcopying
@end ifnottex

@menu
Invoking Poke

Basic Editing
@c* Commands::

The Poke Language
* Hello Poke::
* Numbers::
* Metatypes::
* Arrays::
* Strings::
* Structs::
* Unions::
* Enumerations::
* Bitmasks::
* Flattening::
* Expressions::
* Constants::
* Variables::
* Statements::
* Procedures::
* Mapping::			Accessing the IO stream from poke programs.

Advanced Editing
@c Searching
@c Marks
@c Useful Idioms

Reverse Engineering

Extending Poke
@c * Writing commands in C::
@c * Writing commands in Poke::

Poke Internals
* Poke Architecture::		Overall architecture.

* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@end menu

@node Hello Poke
@chapter Hello Poke!

XXX: explain why poke features a domain-specific languages.

XXX: aspects to discuss here:

     - Interpreted.
     - Familiar C-like brace-based syntax.
     - Oriented for editing physical binary layouts:
       + Language-level support for endianness.
       + Padding control (by default, no padding.)

     - Data integrity:

       + Integrity constraints.
       + Validation.
       + Automatic fixing when feasible.
       + Allows altering the data with some level of assurance nothing
         gets broken.

     - Using C-like structs: easy to reuse definitions from software

     - Writing to the IO may change the layout of some data structure,
       so the data structures must adapt automatically.  This is a
       powerful concept in poke.

     - No pointers: variables do not have addresses.

     - poke          => bytes editor
     - poke + elf.pk => elf editor
     - poke + foo.pk => foo editor

@node Numbers
@chapter Numbers

@menu
* Integers::			Integer numbers.
@end menu

@node Integers
@section Integers

Whole numbers, also known as integers, are ubiquitous in binary
formats.

Poke supports the following primitive types for integers:

@table @code
@item char
8-bit ASCII code.
@item byte
@item uint8
Unsigned 8-bit integer.
@item int8
Signed 8-bit integer.
@item uint16
Unsigned 16-bit integer.
@item short
@item int16
Signed 16-bit integer.
@item int
@item int32
Signed 32-bit integer.
@item uint32
Unsigned 32-bit integer.
@item long
@item int64
Signed 64-bit integer.
@item uint64
Unsigned 64-bit integer.
@end table

XXX: discuss bit-field types: signed and unsigned bit:N.  But then,
     what about the VM?  Bit-fields are better supported in struct
     fields... but using what syntax?  The usual ': BITS' is already
     used by constraints.  Using Ada's `at N range N .. M'?

     Also, since IO offsets are bit-oriented, and since poke variables
     do not have addresses, bit fields can be used like any other
     variable, mapped or not: no alignment issues.

     Making offsetof to work on bits?  Or having both offsetof and
     boffsetof.  But then what about labels?

     Also, support variable bit field types, like bit<EXPR> in
     datascript.  Maybe even bit<EXPR>? :D But then types are not
     static.  Unless bitfield type sizes are _not_ part of the type =>
     bitfield VM instructions should check size.

Integers literals can be expressed in several numeration bases.

@emph{Decimal numbers} use the usual syntax @code{[1-9][0-9]*}.  For
example, @code{2345}.

@emph{Octal numbers} are expressed using a prefix of zero or more
@code{0} digits with syntax @code{0[0-9]+}.  Examples are @code{00},
@code{0100} and @code{0777}.

@emph{Hexadecimal numbers} are expressed using the syntax
@code{0[xX][0-9a-fA-F]+}.  Examples are @code{0x0} and
@code{0xfe00ffff}.  Note that both the @code{x} in the prefix and the
letters in the hexadecimal number are case insensitive.  Thus,
@code{0XdeadBEEF} is a valid (but ugly as hell) literal.

@emph{Binary numbers} are expressed using the syntax
@code{0[bB][01]+}.  Again, the @code{b} in the prefix is
case-insensitive.  Examples of binary literals are @code{0b0} and
@code{0B010}.

Note that negative numbers, of any numeration base, are constructed
using the minus operator as explained below.

@subsection Characters

8-bit unsigned integers can use an alternative literal notation that
is useful when working with @emph{ASCII character codes}.  Printable
character codes can be denoted with @code{'c'}

Examples:

@example
'o'
'\n'
'\t'
'\0'
@end example

The type of a character literal is always @code{char}.

@subsection The digits separator @code{_}

The character @code{_} can appear anywhere in a numeric literal other
than leading them.  It is ignored, and its purpose is to make it
easier for programmers to read them:

@example
0xf000_0000_0000_0000
0b0000_0001_0000_0001
@end example

@subsection Types of integer literals

The type of a numeric literal is the smallest signed integer capable
of holding it, starting with 32 bits, in steps of powers of two and up
to 64 bits.@footnote{Rationale: the width of a C ``int'' is 32 bits in
most currently used architectures, and binary data formats are usually
modeled after C.}

So, for example, the value @code{2} has type @code{int32}, but the
value @code{0xffff_ffff} has type @code{int64}, because it is out of
the range of signed 32-bit numbers.

A set of suffixes can be used to construct integer literals of certain
types explicitly.  @code{L} or @code{l} is for 64-bit integers.
@code{H} or @code{h} is for 16-bit integers (also known as
@dfn{halves}) and @code{B} or @code{b} is for 8-bit integers (also
known as @dfn{bytes}).  @code{10L} is a 64-bit integer with value
@code{0x0000_0000_0000_000A}, @code{10H} is a 16-bit integer with
value @code{0x000A} and @code{10b} is a 8-bit integer with value
@code{0x0A}.

Similarly, the signed or unsigned attribute of an integer can be
explicitly specified using the suffix @code{u} or @code{U} (the
default are signed types).  For example @code{0xffff_ffffU} has type
@code{uint32} and @code{0ub} has type @code{uint8}.

The above rules guarantee that it is always possible to determine the
width and signedness of an integer constant just by looking at it,
with no ambiguity.  This is important, because very often numbers are
used in commands like @code{poke} and @code{peek} where these
attributes determine the number of bytes written/read to/from the IO
space, and their encoding.

For example, the following command writes four byte in IO offset 0x0:

@example
(poke) poke 0x0, 10
0x00000000 <- 0x00
0x00000001 <- 0x00
0x00000002 <- 0x00
0x00000003 <- 0x0a
@end example

But the following command writes just one byte:

@example
(poke) poke 0x0, 10b
0x00000000 <- 0x0a
@end example

Note that the operation above can also be achieved by using a cast
(XXX: xref to casts), like in:

@example
(poke) poke 0x0, (int8) 10
0x00000000 <- 0x0a
@end example

However using suffixes requires less keystrokes.

@node Metatypes
@chapter Metatypes

Bit types and sets.

@example
deftype int32 = sbit<32>;
deftype uint32 = ubit<32>;

defset foo = enum @{ a = 1, b = 2 @};
defset bar = bitmask @{ a = 0x1, b = 0x4 @};

foo<int>
bar<bit<32>>
@end example

XXX we need a new boxed value for non 8,16,32,64 integral values.  And
    to implement the promotion types for operators.

@node Arrays
@chapter Arrays

Arrays types are denoted using the following syntax:

@example
@var{type}[]
@end example

Where @var{type} is the type of the elements contained in the
array.

Examples:

@example
int32[]
uint64[]
string[]
char[]
@end example

The elements contained in an array can be arrays themselves.  This is
how you would declare a type of such an array:

@example
int[][]
@end example

Note that, unlike in many other programming languages, no boundaries
are expressed in the array type definitions.  This is because in poke
the actual size of an array is not part of its type.  This means that,
for example, an array containing four 32-bit integers has the same
type than an array containing four hundred 32-bit integers:
@code{int[]}.

XXX: operator '+' concatenates arrays.
XXX: operator '~' reverses arrays.

XXX: empty arrays are supported, but not literals of empty arrays.

XXX: explain how unbounded arrays play the declarative role of
     iteration.

Array literals are constructed using the following syntax:

@example
[<exp>, <exp>, ..., <exp>]
@end example

Where @code{<exp>} is an arbitrary expression.

For example, @code{[1,2,3]} constructs an array of type
@code{int32[]} containing three elements.  Likewise,
@code{['a','b','c']} constructs an array of type @code{char[]}
containing three elements.

The type of the array literal is inferred from the type of its
elements.  Accordingly, all the elements in an array literal must be
of the same type.  Examples of invalid array literals, that will raise
an error if evaluated, are:

@example
[1,2u,3]
[1,0xffff_ffff,3]
['a',"b",'c']
@end example

Arrays must contain at least one element.  Accordingly, @code{[]} is
not a valid array literal.

This is how a @code{3x3} matrix could be constructed using an array of
arrays:

@example
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
@end example

It is possible to refer to specific elements when constructing array
literals.  For example, @code{[1, 2, 3, .[3] = 4]} denotes the same
array than @code{[1, 2, 3, 4]}.

XXX: in GNU C the array size for [[1] = 10, 20, [4] = 40] would be 5.

This allows creating arrays without having to specify all its
elements.  Unspecified elements have the value @code{null}.  For
example, @code{[.[2] = 2]} denotes the same array than @code{[null,
null, 20]}.

Note that an array element should only be referred once.  Accordingly,
@code{[1, 2, 3, .[1] = 10]} is not a valid array literal.

XXX: Array subscripts are promoted to unsigned 64-bit integers.

@section Declaring the size of an array in bytes

XXX: We need to be able to specify that an unbounded array is of some given
     size (sizeof) i.e. the array elem type is applied until: a constraint
     fails or the byte size of the array is achieved or EOF is found.  Very
     interesting :)  Sometimes you don't know the number of elements, but you
     know the total size of the array.

     This is because array elements, despite all being of the same
     type, can have different sizes if they are structs or unions.

@example
defvar int[32] a;  /* Array of 100 integers.  */
defvar int[#128] a; /* Array of 128 bytes, i.e. 100 integers.  */
@end example

     XXX How to specify the maximum size in bits?  This may be needed
     for some bit-oriented formats like deflate.

     Example: dwarf CFA expression:

@example
deftype dwarf_cfa_expression =
  struct
  @{
    uint128 reg;
    uint128 len;
    dwarf_op[#len] expr; /* An error is raised if the elements
                            of EXPR do not sum exactly LEN bytes.  */
  @};
@end example

    Note that if LEN is not achieved because of an union constraint
    failure, this will catch the error (the union constraint failure
    won't.)  Put an example.

@node Strings
@chapter Strings

Arrays of ASCII codes can be denoted using an alternative literal
notation that is useful when working with ASCII null-terminated
strings:

@example
"foo"
@end example

The above string is of type @code{char[]} or @code{string}, and is
equivalent to:

@example
[0x66, 0x6f, 0x6f, null]
@end example

or to:

@example
[0x66, 0x6f, 0x6f, 0x0]
@end example

Note that the empty string @code{""} corresponds to the array
@code{[0x0]}, which is a valid array containing at least one
element.

The following escape sequences are supported inside string literals:

@table @code
@item \DDD
Where @var{ddd} is a one to three digits octal number.  The escape
sequence denotes the ASCII character having that code.  It must be in
the range @code{0-127}.  For example @code{\000} denotes the ASCII
@code{NULL} character.
@item \xHH
Where @var{hh} is a one to two digits hexadecimal number.  The escape
sequence denotes the ASCII character having that code.  For example
@code{\x38} denotes the @code{8} character.
@item \"
Denotes a double quote.
@item \n
Denotes a new line character.
@item \t
Denotes an horizontal tab.
@end table

@node Structs
@chapter Structs

XXX iterating through struct fields.  In offset order?  Or in field
    definition order?  Configurable?

XXX evaluation algorithm.  Poke must work on a staging area for the
    region i tis operating on, working recursively with rollback.  In
    fact, the struct evaluation algorithm performs backtracking.

XXX Problem: How to raise constraint marks in unions?  Maybe a warning()
    function that returns true but logs/marks a warning?

XXX how to handle recursive definitions?  With defrectype?  Or with
    forward references?

XXX versioned types

XXX Explain how it is possible to define procedures inside structs,
    and how can they be accessed using the dot-notation, very similar
    fields are accessed.  The same scope and visibility rules are used
    for procedures.


XXX Use the deflate format to show how structs can generally be
    bit-aligned.  For an example of a bit-oriented format, see
    deflate.pk.

@example
deftype elf =
   versioned("1.0") struct
   @{
     ...
   @}
@end example

   The version above is not of the ELF format, but of the poke spec.
   This is an important distinction.  Useful for the binary diffs.

Structs are collections of heterogeneous values.

A struct defines the layout of an area in IO space.  They are defined
as follows:

@example
struct
@{
  @var{field1};
  @var{field2};
  ...
  @var{fieldN};
@};
@end example

where @var{field1}..@var{fieldN} are the definitions of fields.  It is
legal to have an empty struct, i.e. with no field defined.

@var{qualifiers} is a list of optional qualifiers for the struct
contents:

@table @code
@item lsb
The default endianness of the struct contents is little-endian.
@item msb
The default endianness of the struct contents is big-endian.
@end table

Each field is defined as follows:

@example
[@var{label}:] [@var{qualifiers}] @var{type} @var{field}[: @var{constraint}];
@end example

where @var{label} is an optional offset relative to the beginning of
the struct.  The field is located @var{label} bytes in the struct.

@var{qualifiers} is a list of optional qualifiers for the field:

@table @code
@item lsb
The contents of the field are stored in little-endian.
@item msb
The contents of the field are stored in big-endian.
@end table

@var{type} is the type of the field.  @var{field} is the name of the
field, which must be unique in the containing struct.

@section Struct Types

A struct type is
denoted using the following syntax:

@example
struct @{<type> [<name>];[<type> [<name>];]...@}
@end example

Where @code{<type>} is any type or @code{<null>}.

The type of a struct containing three 32-bit signed integers is
@code{struct @{int64; int64; int64;@}}.  Similarly, the type of a struct
containing a string, an unsigned 8-bit number, and a character is
@code{struct @{string; byte; char@}}.

The order of the struct elements is significant.  For example, the type
@code{struct @{int; long;@}} is different than the type
@code{struct @{long; int;@}}.

The type of an empty struct, i.e. a struct with no elements, is
@code{struct @{@}}.

It is possible to name some (or all) of the struct constituents.  For
example, if we wanted to define a struct to store information about a
person, we could do it like @code{struct @{int age; string name;@}}.
The element names are significant, i.e. the type @code{struct @{int
foo; int bar;@}} denotes a different type than @code{struct @{int baz;
int quux;@}}.

@section Struct Constructors

Struct literals are constructed using the following syntax:

@example
@{[[[.<name> =] <exp>][,[.<name> = ] <exp>]...]@}
@end example

Where @code{<exp>} are arbitrary expressions.  For example, a strct
containing three signed 32-bit integers can be constructed as
@code{@{10, 20, 30@}} and it is of type @code{struct @{int; int;
int;@}}.  Similarly, @code{@{age, name@}} would construct a type
@code{struct @{int;string;@}} provided @code{age} and @code{string}
are variable holding values of the appropriate type.

For example:

@example
@{10, "foo", 'x'@}
@end example

An empty struct is denoted by @code{@{@}}.

It is possible to specify named elements in a struct literal, like in
@code{@{.age = 37, .name = "Jose"@}}.  The struct constructed this way
has type @code{struct @{int age; string name@}}, i.e. the ordering of
the named members follows their appearance in the literal.

Constructing a named struct type is done with:

@example
packet @{...@}
@end example

XXX: discuss anonymous fields.
XXX: discuss labels and offsets.

     Offsets are just numbers associated with members of composite
     types (structs, bitmaps, unions and arrays).  All members of
     unions have offset 0.  When a type is constructed (from a
     literal, or zeroed, or from an IO map) the members get their
     offsets.

     They are always unsigned 64-bit integers, i.e. they have type
     uint64.

     When a field or array member is defined, and its size determined,
     a location counter is increased by the number of bytes that the
     field occupies.  This new value of the counter is the offset
     assigned to the next field, unless it features a label.

     Note that the order of fields and array members is not correlated
     with their offsets.  This means that the element @code{a[10]} may
     have an offset bigger than @code{a[2]}, for example.  Usually,
     however, the offset is the one expected, i.e. @code{a[10]} will
     have offset @code{4 * 10} if it is an array of 32-bit integers.

     Offsets are used to map elements to IO space.  Conceptually, the
     offset of a non-composite type is always @code{0}, i.e. the IO
     offset of a @code{int @ 0xff} is @code{0xff + 0}.  Mapping-offset
     + offset.  (XXX: this is elegant.)

     The operator @@field can be used to get the offset in bytes of a
     field inside its containing struct.  It doesn't work with bitmap
     fields.

     Note that if the label of an array contains a *$index construct,
     it is interpreted as the offset within the current structure of
     _each_ element, _not_ of the array itself.  This syntax works
     because it doesn't make sense to define both simultaneously.

XXX: pinned structs

@example
struct
@{
  int f1;
 @@f1:
  int f2;
@};
@end example

   Use use pinned structs:

@example
pinned struct
@{
  int f1;
  int f2;
@};
@end example
  
   The location counter is not advanced when a pinned struct is
   processed.  Labels can be used with pinned fields with the usual
   semantics.

XXX: discuss struct parameters and struct attributes.

   The arguments to structs and unions should be preserved, because
   they can be part of the tag of contained unions.

   They can be accessed using foo.attr, like local variables, and are
   read_only.  By default they are visible, but this can be changed
   using the `hidden' qualifier, like variables and procedures.

   Attributes are inheritable in structs/unions lexical scopes.

   Support for initial values for default arguments.

XXX: discuss component constraints.
XXX: discuss lazy projection in structs.

XXX: discuss recursive structs and forward declarations.

XXX: document the operator 'is' for united values.

@example
     if (doc.elements[20] is timestamp)
        bleh;

     for (section in elf.sections)
        if (section is progbits)
         ...
        else if (section is symtab)
         ...

     Support also a switch statement for is?

     for (elf_section section in elf.sections)
       switch (tagof (section))
         @{ 
          case progbits: bleh;
          case symtab: bleh;
         @}
@end example

@example
struct file
@{
   uint64 size;
   struct record[size] records;
@}
@end example

@example
(poke) let f = file @ 0x0      <- this reads nothing.
(poke) print f.size            <- this reads size.
1000000000
(poke) print f.records[10000]  <- this reads a record.
record @{....@}
@end example

XXX: discuss the deprecated field qualifier.

XXX: discuss the `reserved' field qualifier.

XXX: discuss about the two idioms for union tags: tag outside of the
union leading to names like foo.contents.date or tag inside of the
union (relying on recursive propagation of constraint failures)
leading to names like foo.date.value.  What idiom works best probably
depends on the context. Show examples for both cases (bson elemens
works better with the second idiom, for example.)

XXX: discuss using offsets to make chains of structs

@example
struct inode
@{
  uint32 perms;
  uint32 size;
  byte[size] data;
  uint32 next;
@};

void zero_inodes (inode i)
@{
  if (i.perms & INODE_WRITE)
    i.data[0:i.size] = 0x0;

  if (i.next != 0)
    print_inodes (inode @ i.next);
@}
@end example

@section Casting Structs

Casts to structs use the usual syntax @code{(<type>) <exp>} and can be
applied to struct values.

However, when casting to struct types featuring more than one element,
an alternative syntax can be used: @code{(int,long) <exp>} is
equivalent to @code{((int,long)) <exp>}.  This abbreviated form can't
be used to cast to tuples having one element, because it is
indistinguishable to casts to other types.  For example @code{(int)
<exp>} is a cast to type @code{int}, not to type @code{(int)}.

Casts can be used to ``augment'' a tuple.  For example
@code{(int,long,long)@{10,20@}} is augmented to the tuple
@code{@{10,20,null@}}.

Casts can be used to ``reorder'' the named elements in a tuple
literal.  For example, @code{(string name, int age) @{.age = 30, .name
= "Jose"@}} generates the struct @code{@{"Jose", 30@}} of type
@code{(string name, int age)}.

XXX metatypes

@example
    deftype int32 = sbit<32>;
    deftype uint32 = ubit<32>;

    defset foo = enum @{ a = 1, b = 2 @};
    defset bar = bitmask @{ a = 0x1, b = 0x4 @};

    foo<int>
    bar<bit<32>>
@end example

    Syntactic sugar to avoid to have to declare an explicit metatype:

@example
deftype foo = enum<bleh> @{ ... @};
@end example

XXX Getting attributes of types?  With sizeof and friends...

XXX discuss bitmaps

 Bitmaps contain bit fields.
 If named, a bitmap can always be used like its base type, i.e. like
 an integral field.
 Bit endianness: msbit, lsbit.
 Byte endianness: msb, lsb.
 Labels are not allowed in bitmaps.
 Projection works with bitmaps.

 Writing bit fields involves doing bit-wise logical operations (or to
 set, and to clear, and shifts) on the containing type:

 (poke) poke a.bitfield, 0xf
 0xfeeffeef <- 0xdeadbeef | 0xf << 3

@example
deftype audio_props =
  struct
  @{
     bit<4> flv_sound_format format = FLV_AAC;
     bit<2> flv_sound_rate rate = FLV_RATE_44K;
     bit<1> flv_sound_size size;
     bit<1> flv_sound_type type = FLV_SND_STEREO;
  @};
@end example

By default the type of each bit field is interpreted as having the
same width than the width of the bitmap, and the sign is determined by
either @code{bit:N} or @code{sbit:N}.

Is it possible to operate on bitmaps like if they were integer types?
This would allow to use:

@example
struct
@{
  struct
  @{
     bit:28 elf_sym_binding st_bind;
      bit:4 elf_st_type (mach) st_type;
  @} st_info;
@}
@end example

instead of

struct
@{
  pinned uint32 st_info;
  struct
  @{
     bit:28 elf_sym_binding st_bind;
      bit:4 elf_st_type (mach) st_type;
  @};
@}

XXX alignment checks for structs and fields.  Something like:

@example
aligned(32) struct
@{
  int i;
  long l;
@};
@end example

@node Unions
@chapter Unions

XXX: discuss unions.  Tags, arguments, lexical scope, etc.  Provide
some examples on how to model some real-life situations in binary
formats, like the BSON elements.

XXX: mention how it is better to define struct types at the toplevel
instead of using in-situ structs, because that allows the user to map
them wherever she wants in IO space, and to use constructors for
matching etc.

- Arguments to boolean operators are promoted to signed 32-bit
  integers.

XXX: optional fields.

@example
     optional int f;
@end example

     is equivalent to:

@example
    union
     @{
       int f;
       struct @{@};
     @};
@end example     

     Note that if f does not have constraints associated with it, then
     it will be always present.

XXX Explain how unions play the declarative role of conditionals.

@node Enumerations
@chapter Enumerations

XXX: enumerations and bitmasks are set types.  They should be
discussed in the same chapter.  In contrast, struct an bitmaps are
product types.  unions are sum types.

Enumerations are collections of related constants.  They use the
following syntax:

@example
enum @var{type} @var{tag}
@{
   @var{enumerator1} [= @var{value1}],
   @var{enumerator2} [= @var{value2}],
   ...
   @var{enumeratorN} [= @var{valueN}][,]
@}
@end example

Where:

@table @var
@item type
Is the base type of the enumeration.  It should be an integer type.
@item tag
Is the name of the enumeration.  It should be unique in the global
scope.
@item enumeratorN
Are the names of the enumerators.
@item valueN
Are initialization values.  They should be expressions evaluating to
constant values valid for @var{type}.

If an explicit initialization value is not specified for an
enumerator, an implicit value is used.  The implicit value is
initially @code{0}, and increased by one every time it is used.
@end table

An enumeration  must contain at least one enumerator.

Enumerations do not provide its own lexical scope.  The enumerators
should be unique in the global scope.  It is highly recommended to use
prefixes to avoid conflicts.

@node Bitmasks
@chapter Bitmasks

@example
bitmask elf_xword elf_sh_flags
@{
  /** Section contains data that should be writable during process
      execution.  */
  SHF_WRITE = 0x1,

  /** Section occupies memory during process execution.  */
  SHF_ALLOC = 0x2,

  /** Section contains executable machine instructions.  */
  SHF_EXECINSTR = 0x4,
@}
@end example

@node Flattening
@chapter Flattening

We have already discussed how it is possible to omit the name of
fields when defining structs.  When this is done, an anonymous field
is defined.  Generally speaking, this means the field cannot be
accessed in a poke program, since struct components can only be
referred by name.  Due to this limitation, anonymous fields are
typically used for padding or other applications where the data stored
in the field doesn't need to be referenced.

However, the picture changes when the anonymous field is of a type
having named components itself.  In this case, it is still possible to
access to the named sub-components like if they were components of the
entity containing the anonymous field.  This is easy to see using an
example.

@example
deftype astruct =
  struct
  @{
     int f1;

     struct
     @{
        int f2;
        int f3;
     @};
  @}

defvar astruct s;
@end example

The struct above has two fields: an integer @code{f1} and a struct.
The struct field has no name (it is anonymous) so it is not possible
to refer to it explicitly.  However, its components (the fields
@code{f2} and @code{f3}) can be accessed using @code{s.f2} and
@code{s.f3} respectively.  This is called @dfn{flattening} in poke
parlance, and it is an important concept that makes it possible to
implement many useful idioms.

It is very important to note that flattening doesn't change the
structures it involves: @code{astruct} still contains an anonymous
struct field that in turn contains two fields.  In other words: the
fields @code{f2} and @code{f3} do not become fields of the outer
struct.

The compiler or the run-time will complain if flattening an anonymous
field would result in ambiguity, and will consider that an error in
the program.  This happens in the following example, where the field
@code{f1} introduces an ambiguity.

@example
struct
@{
   int f1;

   struct
   @{
      int f1;
      int f2;
   @};
@}
@end example

Flattening is transitive.  In the following example:

@example
deftype astruct =
  struct
  @{
     int f1;
     struct
     @{
        int f2;
        struct
        @{
          int f3;
        @};
     @};
  @}

defvar astruct s;
@end example

The three fields can be referred as @code{s.f1}, @code{s.f2} and
@code{s.f3} respectively.

@section Flattening Unions

Until now we have focused on structs when talking about flattening.
However, flattening can be used with any type featuring named
subcomponents.  This includes unions.

Consider the following example:

@example
deftype astruct =
  struct
  @{
     int f1;
 
     union
     @{
        int f2 : f1 == 0;
        int f3;
     @};
  @}

defvar astruct s;
@end example

In this case, the alternative active in the union can be accessed like
if it was a component of the outermost struct: either @code{s.f2} or
@code{s.f3}.

Transitive flattening also works with unions.  In the example below
both @code{f3} and @code{f4} are accessible as @code{s.f3} and
@code{s.f4} provided @code{s.f1} is not zero.

@example
deftype astruct =
  struct
  @{
     int f1;
 
     union
     @{
        int f2 : f1 == 0;
        struct
        @{
          int f3;
          int f4;
        @};
     @};
  @}

defvar astruct s;
@end example

Note that flattening unions can be tricky and should be used carefully:
since there is no way to refer to the union itself (it has no name)
the user must know what alternative of the union is active when the
flattened field is accessed.

XXX: we need full type reflection, to know what fields a struct has.
Maybe a field iterator?

Note that generally speaking flattening is a process that should be
done at run-time.  However, if unions are not involved, it happens at
compile-time instead for performance purposes.  For example, the
following struct:

@example
struct
@{
   int f1;

   struct
   @{
      int f2;
      int f3;
   @};
@}
@end example

is transformed at compile time to:

@example
struct
@{
   int f1;
   int f2;
   int f3;
@}
@end example

@section Flattening Bitmaps

Bit-fields defined in a bitmap can be flattened in exactly the same
way than struct fields.

@node Expressions
@chapter Expressions

PCL supports expressions in a very similar way than other programming
languages.

@menu
* Arithmetic Operators::	Operating with numbers.
* Logical Operators::		Building predicates.
* Relational Operators::	Equality and ordering.
* Bitwise Operators::		Working with bits.
* Operators on Arrays::		Operating on arrays.
* Conditional Operator::	if-then-else.
* The Cast Operator::		Changing the type of a value.
* Other Operators::		Stuff that is explained elsewhere.
* Operators Precedence::	What gets executed first.
* Parenthesized Expressions::	Grouping and changing precedence.
@end menu

@node Arithmetic Operators
@section Arithmetic Operators

The following left-associative binary arithmetic operators are
supported, in descending precedence order:

@itemize
@item Multiplication @code{*}, integer division @code{/} and modulus
      @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@end itemize

The following right-associative unary arithmetic operators are
supported:

@itemize
@item Unary minus @code{-} and unary plus @code{+}.
@end itemize

The arithmetic operators are defined on integer and character values.
Attempting to use them on another kind of value results on a run-time
error.

@node Logical Operators
@section Logical Operators

The following left-associative, short-circuited binary logical
operators are supported, in descending precedence order:

XXX: Add the ``implies'' operator => which is useful in constraints.

@itemize
@item Logical AND @code{&&}.
@item Inclusive OR: @code{||}.
@end itemize

The following right-associative unary logical operators are supported:

@itemize
@item Logical negation @code{!}.
@end itemize

@node Relational Operators
@section Relational Operators

The following binary relational operators are supported, in descending
precedence order:

@itemize
@item Equality @code{==} and inequality @code{!=}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=}.
@end itemize

When applied to integer and character values, these operators
implement an arithmetic ordering.  When applied to strings, these
operators implement a lexicographic ordering.

Only equality and inequality can be applied to arrays, structs and
unions.

XXX: equality on structs works as expected.  Ditto to arrays.

These operators resolve in boolean values encoded as 32-bit integers:
@code{0} meaning false and @code{1} meaning true.

@node Bitwise Operators
@section Bitwise Operators

The following left-associative bitwise binary operators are supported,
in descending precedence order:

@itemize
@item Bitwise shift left @code{<<} and bitwise shift right @code{>>}.
@item Bitwise AND @code{&}.
@item Bitwise exclusive OR @code{^}.
@item Bitwise inclusive OR @code{|}.
@item Bitwise concatenation @code{::}.
@end itemize

XXX bitwise concatenation works with any integral type, of any bit
    length.

The following right-associative unary bitwise operators are supported:

@itemize
@item Bitwise complement @code{~}.
@end itemize

Bitwise operators can be applied to integer values, with the expected
semantics.

@node Operators on Arrays
@section Operators on Arrays

@subsection Concatenation

The elements of two arrays can be concatenated using the
left-associative binary operator @code{+}.  For example:

@example
@{1, 2, 3@} + @{4, 5, 6@}
@end example

evaluates to @code{@{1, 2, 3, 4, 5, 6@}}

The operator can also be applied to an array and a value of the same
type than the elements of the array.  This is called a @dfn{cons}, and
it is very useful to build arrays recursively.  For example:

@example
@{1, 2, 3@} + 4
@end example

evaluates to @code{@{1, 2, 3, 4@}}.

Note that the semantics of this operator vary a bit when applied to
arrays of ASCII codes, also known as strings.  In this case, the
@code{NULL} ASCII character finishing the first array is not included
in the concatenated value.  Thus the operation:

@example
@{'a', 'b', 0x0@} + @{'c', 'd', 0x0@}
@end example

evaluates to @code{@{'a', 'b', 'c', 'd', 0x0@}}.  Or, using string
notation:

@example
"ab" + "cd"
@end example

evaluates to @code{"abcd"}.

Likewise, the semantics of the cons operator also vary with arrays of
@code{char}:

@example
@{'f', 'o', 0x0@} + 'o'
@end example

evaluates to @code{@{'f', 'o', 'o', 0x0@}}.  Or, using string
notation:

@example
"fo" + 'o'
@end example

evaluates to @code{"foo"}.

@subsection Indexing

The elements of an array can be referred to using the left-associative
unary operator @code{[@var{idx}]}, where @var{idx} is a positive
integer.

For example, the operation @code{@{1, 2, 3@}[0]} evaluates to
@code{1}, while @code{@{1, 2, 3@}[2]} evaluates to @code{2}.

If the index refers past to the last element contained in the array,
then the operation evaluates to @code{null}, i.e. @code{@{1, 2,
3@}[4]} evaluates to @code{null}.

Negative indexes are not allowed and an error is raised if they are
used.

@c XXX: play with the idea of negative indexes?  Some formats may
@c store information before pointers, like ghostscript's memory
@c allocators do.

XXX: lengthof returns the number of elements of an array.

The indexing operator can also be used to refer to a region of the
array, using a range of indexes @code{[@var{idx1}:@var{idx2}]}.  The
denoted range is @code{[@var{idx1},@var{idx2}]}, i.e. the elements in
both positions are included in the range.  Note that @var{idx1} should
be less or equal than @var{idx2}, or an error is raised.

For example, the operation @code{@{1, 2, 3@}[0:1]} evaluates to
@code{@{1,2@}} and the operation @code{@{1, 2, 3@}[2:3]} evaluates
to @code{@{2,3@}}.

If @var{idx1} equals to @var{idx2}, the result of the operation is an
array of one element.  Thus, @code{@{1, 2, 3@}[1:1]} evaluates to
@code{@{2@}} whereas @code{@{1, 2, 3@}[1]} evaluates to @code{2}.  The
indexation of an array with a range always evaluates to an array.

If the range includes indexes past the end of the array, @code{null}
values are used accordingly.  For example, the operation @code{@{1, 2,
3@}[1:3]} evaluates to @code{[2, 3, null]}, which in turn is
@code{[2, 32]}.

Note that indexing an array range does not create a copy of the
elements.  Instead, both the operand array and the array resulting
from the operation refer to the same instance of the elements.  The
importance of this will become apparent when we talk about variables
later in this manual.

XXX it should be supported to assign a value to ranges:

@example
  data[0:size] = 0x0;
@end example

@subsection Inserting and removing elements

Poke supports language operators to insert and remove elements in an
array without having to involve loops and explicit copy operations.

XXX: problem.  With CBVS, are assignments to the array itself visible
outside??  Nope.  Also, can you pass an array range as an array?

For example:

@example
let array = [1,2,3,4];
array[1] := 0;  /* array is now [1,0,2,3,4]  */
@end example

Appending past the end of the array: fills with zeroes.

XXX: explain elsewhere how any poke type (basic or composite) can be
zeroed.  This is also used in variable initialization.

As we saw before, @code{null} is a special value that denotes the
absence of a value.  It is possible to remove elements from an array
by assigning @code{null} to them.  For example, @code{array[2] = null}
will remove the third element from @code{array}.  Ranges are accepted:
@code{array[0:lengthof array - 1] = null} will empty an array.

XXX: what syntax doesn't sucks ass??

@subsection Array member operator

Very useful in union constraints.
XXX: show realistic example.

@example
ELEM in ARRAY
@end example

@node Conditional Operator
@section Conditional Operator

The following right-associative ternary conditional operators are
supported:

@itemize
@item Conditional operator @code{? :}.
@end itemize

The conditional operator can be applied to integer and character
values.

XXX quantified ternary expressions

    forall ID in ARRAY_EXPR : BOOLEAN_EXPR

    It is true iff BOOLEAN_EXPR is true for all index ID in the array.

@example
   int[] a : forall i in a : (i == 0) || (a[i] == a[i-1]+1);
@end example

XXX ternary inclusion operator (useful with enums):

    A in B : C.

@node The Cast Operator
@section The Cast Operator

The right-associative unary operator cast @code{(type)} can be used to
derive a new value having a different type from an existing value.

Casts between integer types are always allowed.  If the new type is
narrower than the existing type, truncation may be performed to
accommodate the value in its new type.  For example, the expression
@code{(uint8) 0x8765_4321} evaluates to @code{0x4321}.  If the new type
is wider than the existing type, either zero-extension or
sign-extension is performed depending on the signedness of the
operand.

The semantics of the sign-extension operation depends on the currently
selected negative representation encoding in @code{.nencoding}. @c
XXX: xref to section documenting @code{.nencoding}.

For example, in two's complement the expression @code{(uint16) 0xffff}
evaluates to @code{0x0000_ffff}.  However, @code{(int16)0xffff}
evaluates to @code{0xffff_ffff} in two's complement, and it evaluates
to @code{0xffff_0000} in one's complement.

Casts are also used in order to construct struct, union, enumerated
and bitmask values, as it is explained later in this manual. @c XXX:
@c xref to section documenting it.

@node Other Operators
@section Other Operators

Other operators, whose meaning and purpose is explained in full later
in this manual, are summarized here.

Left-associative binary operators:

@itemize
@item The map operator @code{@@}.
@end itemize

Left-associative unary operators:

@itemize
@item Member selection operator @code{.}.
@end itemize

Right-associative unary operators:

@itemize
@item @code{sizeof}, @code{bitsizeof}, @code{lengthof}, @code{startof} and @code{typeof}
@end itemize

@node Operators Precedence
@section Operators Precedence

The following table summarizes the precedence and the associativity of
all the operators described above, in descending order:

@table @code
@item Array subscript operator @code{[ ]}.
@item Member selection operator @code{.}.
@item Postfix increment @code{++} and postfix decrement @code{--}.
@item Prefix increment @code{++} and prefix decrement @code{--}.
@item Unary minus @code{-} and unary plus @code{+}.
@item Logical negation @code{!} and bitwise complement @code{~}.
@item Cast @code{(type)}.
@item @code{sizeof}, @code{startof} and @code{typeof}.
@item Array concatenation @code{+}.
@item Multiplication @code{*}, integer division @code{/} and modulus
      @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@item Bitwise shift left @code{<<} and bitwise shift right @code{>>}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=},
@item Equality @code{==} and inequality @code{!=}.
@item Bitwise AND @code{&}.
@item Bitwise exclusive OR @code{^}.
@item Bitwise inclusive OR @code{|}.
@item Logical AND @code{&&}.
@item Inclusive OR: @code{||}.
@item Ternary conditional operator @code{? :}.
@item Comma operator @code{,}.
@end table

@node Parenthesized Expressions
@section Parenthesized Expressions

Parentheses can be used in order to change the precedence of
sub-expressions, the usual way.

@node Constants
@chapter Constants

Constants are named values that don't change during the lifetime of a
poke program.

The definition of a constant uses the following syntax:

@example
const [@var{type}] @var{name} = @var{const_exp}
      (,[@var{type}] @var{name} = @var{const_exp})*;
@end example

This declares a set of constants with the given @var{name}s having the
value of the corresponding @var{const_exp}.  The expressions must be
constant, i.e. it should be possible to compute their values at
compile-time.

If a @var{type} is specified in a constant definition then the value
computed by the assignment expression must be of the same type, or an
error is raised.  Otherwise the type of the constant is the type of
the value computed by the expression.

Examples:

@example
const limit = 256;
const balance = 23U;
const offset = (uint64) 256;
const uint64 offset = 256;
const section_name = ".text";
const x = 'x', y = 'y';
@end example

@node Variables
@chapter Variables

XXX primitives to get struct's begin and end addresses (and, in
    general, of any variable).  beginof VAR, endof VAR?  What if the
    variable is not mapped to IO?

Variables are the association between a symbol and a value.  They are
declared using the @code{def} construction:

@example
defvar [<type>] <name> [= <exp>]
      (,[<type>] <name> [= <exp>)*;
@end example

Where @code{<name>} is a literal with the form
@code{[a-zA-Z_][a-zA-Z0-9_]*}.

The variable can be initialized with a value, which is the result of
computing the expression @code{<exp>}.  If no initial value is
provided then it is @code{null}.

Generally a variable can hold values of different types during its
life time.  However, if @code{<type>} is specified in a variable
declaration then only values of that type are allowed to be stored in
the variable.

It is important to note that poke variables are not stored in
addressable memory; and if they are, that is none of the business of
the poke programmer!

@section Variables Lifetime

Variables exist until the execution flow exits the scope where they
are declared:

@itemize
@item Variables declared in the top-level exist until poke exists.
@item Variables declared in the body of a function exist until the
      function exits.
@item Variables declared in the body of a struct or an union exist
      until the execution flow exits the struct or union.
@end itemize

@section Variables Scope

A variable is accessible in the lexical scope where they are declared,
and in the lexical scopes nested in the lexical scope where they are
declared.

For example, this is an error:

@example
@{
  defvar int i;
@}

i = 30;
@end example

But this is not:

@example
@{
  defvar int i;

  @{
    i = 30;
  @}
@}
@end example

Note that variables defined in inner scopes ghost variables with the
same symbol defined in an outer scope.

@node Statements
@chapter Statements

Statements are the basic execution units of poke programs.  Executing
a program means executing its statements one by one.  Their main
purpose is to perform some side-effect.

@menu
* Assignments::			Setting the value of a variable.
* Statement Blocks::		Sequences of statements.
* If::				Simple conditional.
* Switch::			Multiple conditional.
* While::			Iterating while some condition is met.
* For::				Iterating on indexes.
* For-in::			Iterating on arrays.
* Continue::			Jumping to the next iteration.
* Break::			Escaping a loop or a switch.
* Function Calls::		Calling a subroutine.
@end menu

@node Assignments
@section Assignments

The assignment statement stores a value in a variable.  It's syntax
is:

@example
<variable> = <exp>;
@end example

Where @code{<variable>} is the name of the variable and @code{<exp>}
is an expression.  The value computed by the expression can be of any
type, unless the variable is declared with a fixed type.

The value previously stored in the variable is lost, unless there are
other references to it. (This can happen with arrays, structs and
unions.)

There are several variants of the assignment statement that are
provided to shorten common idioms:

@example
<variable> <op>= <exp>;
@end example

which is equivalent to:

@example
<variable> = <variable> <op> <exp>;
@end example

Valid @code{<op>}s are addition @code{+}, subtraction @code{-},
multiplication @code{*}, integer division @code{/}, modulus @code{%},
bit-wise AND @code{&}, bit-wise exclusive OR @code{^}, bit-wise
inclusive OR @code{|}, bit-wise shift left @code{<<} and bit-wise
shift right @code{>>}.  @c xref to operators chapter.

@node Statement Blocks
@section Statement Blocks

Statements that are to be executed sequentially can be grouped in
@dfn{blocks} using curly brackets:

@example
@{
  <stmt>
  <stmt>
  ...
  <stmt>
@}
@end example

Syntactically a block is equivalent to a single statement.  This means
that in every place where a statement is valid, a block is also valid.

Statement blocks introduce a new lexical scope.

@node If
@section If

The @code{if} statement has the following form:

@example
if (<exp>) <then_stmt> [else <else_stmt>]
@end example

The expression @code{<exp>} is evaluated.  If it evaluates to
@code{true} then @code{<then_stmt>} is executed.  If
@code{<else_stmt>} is specified and @code{<exp>} evaluates to either
@code{false} or @code{null} then @code{<else_stmt>} is executed
instead.

@node Switch
@section Switch

The @code{switch} statement looks like:

@example
switch (<exp>)
@{
   case <exp>:
   <stmt>
   ...
   <stmt>
   case <exp>:
   <stmt>
   ...
   <stmt>
   ...
   default:
   <stmt>
@}
@end example

The expression @code{<exp>} is evaluated and the case expressions are
evaluated in order.  Whenever the value of a ase expression matches
the value of @code{<exp>}, the statements following it are executed.
More than one case may be entered.  The statements following
@code{default:} are always executed if the control flow reaches there.

If the special statement @code{break} is found, the control flow jumps
to the end of the switch statement.

@node While
@section While

@code{while} statements have the form:

@example
while (<exp>) <stmt>
@end example

@code{do-while} statements have the form:

@example
do <stmt> while (<exp>);
@end example

@code{for} statements have the form:

@node For
@section For

@example
for ([<exp>];[<exp>];[<exp>]) <stmt>
@end example

@node For-in
@section For-in

@code {for} statements have the form:

@example
for ([variable] in <exp>) <stmt>
@end example

@node Continue
@section Continue

The @code{continue} statement makes the control flow to jump to the
beginning of the nearest loop instruction.  If no such loop
instruction is found an error is raised.

@node Break
@section Break

The @code{break} statement makes the control flow to exit the nearest
containing loop or switch statement.

@node Function Calls
@section Function Calls

Functions are called:

@example
<name> ((<arg>[,<arg>])*);
@end example

Where @code{<name>} is the name of a defined function.  When called as
a statement, a warning is issued if a function returns anything but
@code{null}, because in that case the return value is discarded.

It is possible to name specific function arguments in a function call:

@example
printf (fmt = "this is %d", number);
@end example

@node Procedures
@chapter Procedures

Procedures are defined using the following syntax:

@example
defproc <name> ((<arg> [,<arg>]*)*) [<return_type>]
@{
  <function_body>
@}
@end example

Function arguments follow the following syntax:

@example
[<type>] [&]<name> [= <exp>]
@end example

Where @code{<name>} is the name of the argument.  If a @code{<type>}
is indicated, the value in the argument must be of that type.

The body of a function introduces a new lexical scope.

A @code{return} statement with the form:

@example
return [<value>];
@end example

may be used to return a value for the function.  If the function
doesn't return any value, it returns @code{null}.

A function can be defined at top-level scope, or inside a lexical
scope.  This included another functions.  This is useful to write
auxiliary functions without polluting the global name space (Poke is a
truly block-oriented language.)

XXX: normal passing: CBVS.  CBR using & in both formal argument and
actual parameter:

@example
void add_elf_section (elf_section &section)
@{
   section[lengthof section] := create_section ();
@}
@end example

Or using inout?

@section Optional Arguments

If an assignment operator and an expression is included, then the
argument is optional and has the value of @code{<exp>} should it not
be specified in a function call.

@section Variadic Functions

If the last argument of a function is initialized to an empty tuple,
then it will contain any extra argument.

@example
function printf (string fmt, args = @{@})
@{
   defvar int i;
   for (i = 0; i < sizeof (args); i++)
   @{
      /* Process argument.  */
   @}
@}
@end example

@section Recursive Functions

Functions can be recursive, both directly and indirectly.  For
example, this is a factorial implementation in poke:

@example
function factorial (n)
@{
  if (n == 0)
     return 1;
  else
     return n * factorial (n - 1);
@}
@end example

GNU poke supports tail-recursion.  This means that if a recursive
function is written in certain way, it is equivalent to iteration with
no memory allocated in each iteration.  This is important, since it
allows writing recursive functions operating on large structures in IO
space.

@node Mapping
@chapter Mapping

The idea is that the same poke code will execute on mapped and
non-mapped variables, with no changes.

@section The IO Space

We already discussed the @dfn{IO Space} in the chapters dedicated to
basic editing: it basically corresponds to the file, stream or memory
image being edited at the current time.  As we saw, all these entities
are uniformly handled as a single abstraction, called ``the current IO
space''.

From the point of view of a poke program, the IO Space is infinite: it
starts at offset @code{0} and extends to infinity.  However, at some
point it starts containing @code{eof}s.  @code{eof} is a special value
which is of any type, and is not equal to any other other value.

The following example:

@example
defvar a = byte[] @ 0x0;
@end example

defines an array that covers the entire IO space.  Remember that empty
arrays extends until it reads @code{eof} or a constraint in its
constituent fails.  In this case the constituents of the array are
bytes, which can't be associated with constraints.

In theory this is an infinite loop:

@example
struct
@{
  byte b : b == eof;
@};

defvar a = elem_type[] @ 0x00;
@end example

but in practice it is detected by the run-time and reported as a
run-time error, because reading @code{eof} does not advance the IO
space location counter.

XXX: the location counter (which is read-only) is not really
     necessary, but it avoids having to replicate logic all the way in
     structs, in order to determine which fields have been defined or
     not.

@section The Map Operator


@section Peeking and poking thru maps

XXX Explain handling of EOF: There is _never_ EOF poking to IO space:
    the file gets expanded as needed, with same semantics than a fseek
    in the underlying system.  When committing to the file, there
    could be an error if the file doesn't admit appending, or disk
    full, or whatever.  But that is another level.

@example
     defvar i = int @ 0xffff;
     i = 25;
@end example

    Peeking can return EOF... or 0?

@section Endianness and Negative Encoding

The encoding of a mapped variable depends on its value, its type, the
current endianness and the current negative encoding method.

The current endianness is determined by the value of the special
variable @code{.endian}.  If @code{.endian == msb} then the encoding is
big-endian.  If @code{.endian == lsb} then the encoding is
little-endian.  The default endianness is determined by the endianness
used by the machine where GNU poke is running.

XXX: use big_endian(), little_endian(), twos_compl(), ones_compl() in
     constraints, to change the value of these attributes in the
     implicit evaluation state.

     or, an ``use'' construction?  Like in:

@example
use lsb if EXP;
use neg2comp if EXP;
@end example

The current negative encoding method is determined by the value of the
special variable @code{.nencoding}.  If @code{.nencoding == 1} the
negative quantities in integer values are encoded using one's
complement.  If @code{.nencoding == 2} then they are encoded using
two's complement.  The default is @code{2}.

XXX: Globals suck.  How to handle computed endianness like in elf??

@section Encoding

Integer values are de/encoded as follows:

@itemize
@item @code{char}, @code{byte}, @code{uint8} values are encoded as 8-bit
      unsigned stored values.  Nulls of this type are encoded to
      @code{0x00}.
@item @code{uint16}, @code{uint32} and @code{uint64} values map to
      16-bit, 32-bit and 64-bit unsigned stored values, respectively,
      with endianness @code{.endian}.  Nulls of this type are encoded
      to @code{0x0000}, @code{0x0000_0000} and
      @code{0x0000_0000_0000_0000} respectively.
@item @code{int8} maps to a 8-bit signed stored values with negative
      encoding @code{.nencoding}.  Nulls of this type are encoded to
      @code{0x00}.
@item @code{short}, @code{int16}, @code{int},
      @code{int32}, @code{long} and @code{int64} values map to 16-bit,
      16-bit, 32-bit, 32-bit, 64-bit and 64-bit signed stored values,
      respectively, with negative encoding @code{.nencoding} and
      endianness @code{.endian}.  Nulls of this type are encoded to
      @code{0x0000}, @code{0x0000_0000} and
      @code{0x0000_0000_0000_0000} respectively.
@end itemize

@node Poke Architecture
@chapter Poke Architecture

PKL stands for ``Poke Language''.  It is pronounced ``pickle''.

@verbatim

      +----------+
      | compiler |      
      +----------+      +------+
           |            |      |
           v            |      |
      +----------+      |      |
      |   PVM    | <--->|  IO  |
      +----------+      |      |
           ^            |      |
           |            |      |
           v            +------+
      +----------+
      | command  |
      +----------+

@end verbatim

Files:

@table @file
@item pkl.h
PKL compiler header file.
@item pkl-ast.h pkl-ast.c
PKL abstract syntax tree.
@item pkl-gen.c
PKL code generator.
@item pkl-lex.l pkl-lex.y
PKL parser and lexer.
@item pvm.h pvm.c
Poke virtual machine.
@end table

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi


@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
