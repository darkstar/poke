\input texinfo
@comment %**start of header
@setfilename poke.info
@include version.texi
@settitle The Pokist Guide
@afourpaper
@comment %**end of header

@copying
This manual describes GNU poke (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2019 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Editors
@direntry
* poke: (poke). Interactive editor for binary files.
@end direntry

@titlepage
@title The Poke Book
@subtitle for version @value{VERSION}, @value{UPDATED}
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Poke Book

@insertcopying
@end ifnottex

@c Introduction
@c
@c - Motivation, and history (first part of talk)
@c - The program
@c - Demo: poking a relocation
@c
@c Hacking poke
@c
@c Writing poke commands.

@menu
Introduction
* Motivation::			Why a binary editor?
* Nomenclature::		poke, Poke and pickles.
* Invoking poke::		command line options.

Dot-Commands
* .file::			Opening and closing IO spaces.
* .info::			Getting information about open files, etc.
* .set::			Querying and setting global options.
* .vm::				Poke Virtual Machine related commands.
* .exit::			Exiting poke :(

Commands
* dump::			Inspecting crude binary.

Configuration
* pokerc::			User's initialization file.
* Styling::			Changing the appearance of poke's output.

The Language
* Integers::			Working with whole numbers.
* Offsets::			Working with memory sizes.
* Strings::			Working with null-terminated strings.
* Arrays::			Working with homogeneous collections of values.
* Endianness::			Byte ordering.
* Mapping::			Accessing the IO space.
* Output::			Printing from Poke programs.

Hacking poke
* Writing Commands::		Extending poke with new commands.

Appendices
* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@end menu

@node Motivation
@chapter Motivation

XXX

@node Nomenclature
@chapter Nomenclature
@cindex poke, Poke, pickle

GNU poke is a new program and it introduces many a new concept.  It is
a good idea to clarify how we call things in the poke community.
Unless everyone uses the same nomenclature to refer to pokeish
thingies, it is gonna get very confusing very soon!

First of all we have @command{poke}, the program.  Since ``poke'' is a
very common English word, when the context is not clear we either use
the full denomination @command{GNU poke}, or quote the word using some
other mean.

Then we have @dfn{Poke}, with upper case P, which is the name of the
domain-specific programming language implemented by @command{poke},
the program.

This distinction is important.  For example, when people talk about
``poke programmers'' they refer to the group of people hacking GNU
poke.  When they talk about ``Poke programmers'' they refer to the
people who write programs using the Poke programming language.

Finally, a @dfn{pickle} is a Poke source file containing definitions
of types, variables, functions, etc, that conceptually apply to some
definite domain.  For example, @file{elf.pk} is a pickle that provides
facilities to poke ELF object files.  Pickles are not necessarily
related to file formats: a set of functions to work with bit patterns,
for example, could be implemented in a pickle named
@file{bitpatterns.pk}.

We hope this helps to clarify things.

@node Invoking poke
@chapter Invoking poke

XXX

@node .file
@chapter .file

XXX

@node .info
@chapter .info

XXX

@node .set
@chapter .set

The @command{.set} command allows to inspect and set the value of
global settings.  The syntax is:

@example
.set @var{setting} [@var{value}]
@end example

Where @var{setting} is an identifier identifying the setting to
inspect or modify.  If @var{value} is specified, then it is the new
value for the setting.  If @var{value} is not specified the current
value of the setting is displayed.

The following settings can be handled with @command{.set}:

@table @code
@item endian
Byte endianness that will be used when mapping the IO space.  Valid
values are @code{big}, @code{little} and @code{host}.  The default
endianness is the host endianness.
@item obase
Numeric base to be used when displaying values in the REPL and in
@code{printf} statements using the @code{%v} format tag.  Valid values
are @code{2}, @code{8}, @code{10} and @code{16}.  Default value is
@code{10}.
@item pretty-print
Flag indicating whether pretty-printers shall be used when printing
values in the REPL and in @code{printf} statements using the @code{%v}
format tag.  Valid values are @code{yes} and @code{no}.  Default value
is @code{no}.
@item error-on-warning
Flag indicating whether handling compilation warnings as errors.
Default value is @code{no}.
@end table

@node .vm
@chapter .vm

@node .exit
@chapter .exit

The @code{.exit} command exits poke.

@node dump
@chapter dump
@cindex dump

XXX

@node pokerc
@chapter pokerc

XXX

@node Styling
@chapter Styling

XXX

@node Integers
@chapter Integers
@cindex integers

Most of the values manipulated in Poke programs are whole numbers,
also typically known as @dfn{integers} in computing parlance.  This is
because integers are pervasive in binary formats, often featuring
unusual characteristics in terms of size and/or alignment.  Single
bits denoting flags or packed small integers are good examples of
this.  In order to ease the manipulation of such entities, and unlike
most programming languages, Poke provides integer types of any number
of bits and a rich set of accompanying operators.

@menu
* Integer Literals::		Writing integers in different bases.
* Characters::			Another way to write small integers.
* Booleans::			Integers denoting truth values.
* Integer Types::		int<N> and uint<N>.
* Casting Integers::		Converting integers.
* Relational Operators::	Comparing integers.
* Arithmetic Operators::	Operating with integers.
* Bitwise Operators::		Getting and setting integer bits.
* Boolean Operators::		Equality and inequality.
* Integer Attributes::		Accessing properties of integer values.
@end menu

@node Integer Literals
@section Integer Literals

Integers literals can be expressed in several numeration bases.

@emph{Decimal numbers} use the usual syntax @code{[1-9][0-9]*}.  For
example, @code{2345}.

@emph{Octal numbers} are expressed using a prefix @code{0o} (or
@code{0O}) followed by one or more digits in the range @code{[0-7]}.
Examples are @code{0o0}, @code{0o100} and @code{0o777}.

@emph{Hexadecimal numbers} are expressed using a prefix @code{0x} (or
@code{0X}) followed by one or more hexadecimal digits in the range
@code{[0-f]}.  Examples are @code{0x0} and @code{0xfe00ffff}.  Note
that both the @code{x} in the prefix and the letters in the
hexadecimal number are case insensitive.  Thus, @code{0XdeadBEEF} is a
valid (but ugly as hell) literal.

@emph{Binary numbers} are expressed using a prefix @code{0b} (or
@code{0B}) followed by one or more binary digits in the range
@code{[0-1]}.  Examples of binary literals are @code{0b0} and
@code{0B010}.

Negative numbers, of any numeration base, are constructed using the
minus operator as explained below.  Therefore the minus symbol
@code{-} in negative numbers is no part of the literal themselves.

@subsection The digits separator @code{_}

The character @code{_} can appear anywhere in a numeric literal other
than leading them.  It is ignored, and its purpose is to make it
easier for programmers to read them:

@example
0xf000_0000_0000_0000
0b0000_0001_0000_0001
@end example

@subsection Types of integer literals

The type of a numeric literal is the smallest signed integer capable
of holding it, starting with 32 bits, in steps of powers of two and up
to 64 bits.@footnote{Rationale: the width of a C ``int'' is 32 bits in
most currently used architectures, and binary data formats are usually
modeled after C.}

So, for example, the value @code{2} has type @code{int<32>}, but the
value @code{0xffff_ffff} has type @code{int<64>}, because it is out of
the range of signed 32-bit numbers.

A set of suffixes can be used to construct integer literals of certain
types explicitly.  @code{L} or @code{l} is for 64-bit integers.
@code{H} or @code{h} is for 16-bit integers (also known as
@dfn{halves}), @code{B} or @code{b} is for 8-bit integers (also known
as @dfn{bytes}) and @code{n} or @code{N} is for 4-bit integers (algo
known as @dfn{nibbles}).

Thus, @code{10L} is a 64-bit integer with value
@code{0x0000_0000_0000_000A}, @code{10H} is a 16-bit integer with
value @code{0x000A} and @code{10b} is a 8-bit integer with value
@code{0x0A}.

Similarly, the signed or unsigned attribute of an integer can be
explicitly specified using the suffix @code{u} or @code{U} (the
default are signed types).  For example @code{0xffff_ffffU} has type
@code{uint<32>} and @code{0ub} has type @code{uint<8>}.  It is possible
to combine width-indicating suffixes with signedness suffixes:
@code{10UL} denotes the same literal than @code{10LU}.

The above rules guarantee that it is always possible to determine the
width and signedness of an integer constant just by looking at it,
with no ambiguity.

@node Characters
@section Characters

8-bit unsigned integers can use an alternative literal notation that
is useful when working with @emph{ASCII character codes}.  Printable
character codes can be denoted with @code{'c'}.

Non-printable characters can be expressed using escape-sequences.  The
allowed sequences are:

@table @code
@item \n
New-line character (ASCII 012).
@item \t
Tab character (ASCII 011).
@item \[0-9][0-9]?[0-9]?
Character whose ASCII code is the specified number, in octal.
@end table

Examples:

@example
'o'
'\n'
'\t'
'\0'
@end example

The type of a character literal is always @code{char}, aka
@code{uint<8>}.

@node Booleans
@section Booleans

Like in C, truth values in Poke are encoded using integers.  Zero
(@code{0}) denotes the logical value ``false'', and any integer other
than zero denotes the logical value ``true''.

@node Integer Types
@section Integer Types

Most general-purpose programming languages provide a small set of
integer types, each featuring a range corresponding to strategic
storage sizes: basically, signed and unsigned variants of 8, 16, 32,
64 bits.  As we have seen in the previous sections, suffixes like
@code{H} or @code{L} are used in Poke for that purpose.

However, in conventional programming languages when integers having an
``odd'' width (like 13 bits, for example) get into play for whatever
reason, the programmer is required to use the integer arithmetic
operators (and sometimes bit-wise operators) herself, in a clever way,
in order to achieve the desired results.

Poke, on the contrary, provides a rich set of integer types featuring
different widths, in both signed and unsigned variants.  The language
operators are aware of these types, and will do the right thing when
operating on integer values having different widths.

Unsigned integer types are specified using the type constructor
@code{uint<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{[1,64]}.  Examples:

@example
uint<1>
uint<7>
uint<64>
@end example

Similarly, signed integer types are created using the type constructor
@var{int<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{[1,64]}.  Examples:

@example
int<1>
int<8>
int<64>
@end example

Note that expressions are not allowed in the type integral constructor
parameters.  Not even constant expressions.  Thus, things like
@code{int<foo>} and @code{uint<2+3>} are not allowed.

@node Casting Integers
@section Casting Integers

The right-associative unary operator cast @code{as} can be used to
derive a new integer value having a different type from an existing
value.

For example, this is how we would create a signed 12-bit integer value
holding the value 666:

@example
(poke) 666 as int<12>
(int<12>) 666
@end example

Note that the @code{666} literal is originally a 32-bit signed
integer.  The cast performs the conversion.

Casts between integer types are always allowed, and never fail.  If
the new type is narrower than the existing type, truncation may be
performed to accommodate the value in its new type.  For example, the
expression @code{0x8765_4321 as uint<16>} evaluates to @code{0x4321}.
If the new type is wider than the existing type, either zero-extension
or sign-extension is performed depending on the signedness of the
operand.

The semantics of the sign-extension operation depends on the
signedness of the value being connverted, and on the currently
selected encoding for negative numbers.

When using two's complement encoding, converting a signed value will
always sign-extend regardless of the signedness of the target type.
Thus:

@example
(poke) -2H as uint<32>
0xfffffffeU
(poke) -2H as int<32>
0xfffffffe
@end example

Likewise, converting an unsigned value will always zero-extend
regardless of the signedness of the target type. Thus:

@example
(poke) 0xffffUH as uint<32>
0xffffU
(poke) 0xffffUH as int<32>
0xffff
@end example

@node Relational Operators
@section Relational Operators

The following binary relational operators are supported on integer
values, in descending precedence order:

@itemize
@item Equality @code{==} and inequality @code{!=}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=}.
@end itemize

When applied to integer and character values, these operators
implement an arithmetic ordering.

These operators resolve in boolean values encoded as 32-bit integers:
@code{0} meaning false and @code{1} meaning true.

@node Arithmetic Operators
@section Arithmetic Operators

The following left-associative binary arithmetic operators are
supported, in descending precedence order:

@itemize
@item Multiplication @code{*}, integer division @code{/} and modulus
      @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@end itemize

In all the binary arithmetic operations automatic promotions
(coercions) are performed in the operands as needed.  The rules are:

@itemize @bullet
@item If one of the operands is unsigned and the other operand is
signed, the second is converted to an unsigned value.
@item If the size in bits of one of the operands is bigger than the
size of the other operand, the second is converted to the same number
of bits.
@end itemize

The following right-associative unary arithmetic operators are
supported:

@itemize
@item Unary minus @code{-} and unary plus @code{+}.
@end itemize

@node Bitwise Operators
@section Bitwise Operators

The following left-associative bitwise binary operators are supported,
in descending precedence order:

@itemize
@item Bitwise shift left @code{<<.} and bitwise shift right @code{.>>}.
@item Bitwise AND @code{&}.
@item Bitwise exclusive OR @code{^}.
@item Bitwise inclusive OR @code{|}.
@item Bitwise concatenation @code{::}.
@end itemize

Bitwise concatenation works with any integral type, of any bit length.

The following right-associative unary bitwise operators are supported:

@itemize
@item Bitwise complement @code{~}.
@end itemize

@node Boolean Operators
@section Boolean Operators

The following left-associative, short-circuited binary logical
operators are supported, in descending precedence order:

@itemize
@item Logical AND: @code{&&}.
@item Inclusive OR: @code{||}.
@end itemize

The following right-associative unary logical operators are supported:

@itemize
@item Logical negation @code{!}.
@end itemize

@node Integer Attributes
@section Integer Attributes

The following attributes are defined for integer values.

@table @code
@item size
Gives an offset with the storage occupied by the string.  This
includes the terminating null.  Examples:

@example
(poke) 10'size
0x20UL#b
(poke) 10N'size
0x4UL#b
(poke) (10 as int<1>)'size
0x1UL#b
@end example

@item signed
Gives 1 if the value is a signed integer, 0 otherwise.  Examples:

@example
(poke) 10'signed
1
(poke) 10UL'signed
0
@end example
@item mapped
Always 0 for integers.  See mapping.
@end table


@node Offsets
@chapter Offsets
@cindex offset, united values

Poke uses united values to handle offsets and data sizes.  This is a
very central concept in poke.

@menu
* Why Offsets::			Byte-oriented or bit-oriented?
* Offset Literals::		Denoting offsets in Poke.
* Offset Types::		offset<...>.
* Casting Offsets::		Converting offsets.
* Offset Operations::		Operating with offsets.
* Offset Attributes::           Accessing properties of offset values.
@end menu

@node Why Offsets
@section Why Offsets

Early in the design of what is becoming GNU poke I was struck by a
problem that, to my surprise, would prove not easy to fix in a
satisfactory way: would I make a byte-oriented program, or a
bit-oriented program?  Considering that the program in question was
nothing less than an editor for binary data, this was no petty
dilemma.

Since the very beginning I had a pretty clear idea of what I wanted to
achieve: a binary editor that would be capable of editing user defined
data structures, besides bytes and bits.  I also knew I needed some
sort of domain specific language to describe these structures and
operate on them.  How that language would look like, and what kind of
abstractions it would provide, however, was not clear to me.  Not at
all.

So once I sketched an initial language design, barely something very
similar to C structs, I was determined to not continue with the poke
implementation until I had described as many as binary formats in my
language as possible.  That, I reckoned, was the only way to make sure
the implemented language would be expressive, complete and useful
enough to fulfill my requirements.

The first formats I implemented using my immature little language
included ELF, FLV, MP3, BSON... all of them describing structures
based on whole bytes.  Even when they try to be compact, it is always
by packing bit-fields in elements that are, invariably, sized as a
multiple of bytes.  Consequently, the language I was evolving became
byte oriented as well.  No doubt also influenced by my C inheritance,
I would think of bitfields either as a sort of second class citizen,
or as mere results of shifting and masking.

This worked well.  The language evolved to be able to express many
different aspects of these formats in a very nice way, like
variable-length data and holes in structures.  Consider the following
definition in what actually is @strong{not} valid today's Poke:

@example
deftype Data =
  struct
  @{
    byte magic;
    byte count;
    byte dstart;

    byte[count] data @@ dstart;
  @};
@end example

The data starts with a byte that is a magic number.  Then the size of
the data stored, in bytes, and then the data itself.  This data,
however, doesn't start right after @code{dstart}: it starts at
@code{dstart}, which is expressed as an offset, in bytes, since the
beginning of the Data.  I conceived struct field labels to be any
expression evaluating to an integer, which would be... bytes,
obviously.

Then, one day, it was the turn for IETF RFC1951, which is the
specification of the DEFLATE algorithm and associated file format.  Oh
dear.  Near the beginning of the spec document it can be read:

@quotation
This document does not address the issue of the order in which bits of
a byte are transmitted on a bit-sequential medium, since the final
data format described here is byte- rather than bit-oriented.
However, we describe the compressed block format in below, as a
sequence of data elements of various bit lengths, not a sequence of
bytes.
@end quotation

Then it goes on describing rules to pack the DEFLATE elements into
bytes.  I was appalled, and certainly sort of deflated as well.  The
purpose of my program was precisely to edit binary in terms of the
data elements described by a format.  And in this case, these data
elements came in all sort of bit lengths and alignments.  This can be
seen in the following RFC1951 excerpt, that describes the header of a
compressed block:

@quotation
Each block of compressed data begins with 3 header bits
containing the following data:
@example
first bit       BFINAL
next 2 bits     BTYPE
@end example

Note that the header bits do not necessarily begin on a byte boundary,
since a block does not necessarily occupy an integral number of bytes.
@end quotation

At this point I understood that my little language on the works would
be never capable to describe the DEFLATE structures naturally: C-like
bit-fields, masking and shifting, all based on byte-oriented
containers and boundaries, would never provide the slickness I wanted
for my editor.  I mean, just use C and get done with it.

This pissed me off.  Undoubtely other formats and protocols would be
impacted in a similar way.  Even when most formats are byte oriented,
what am I supposed to tell to the people hacking bit-oriented stuff?
``Sorry pal, this is not supported, this program is not for you''?  No
way, I thought, not on my watch.

The obvious solution for the problem, is to be general.  In this case,
to express every offset and every memory size in bits instead of
bytes.  While this obviously gives the language maximum expressiveness
power, and is ideal for expressing the few bit-oriented formats, it
has the disadvantage of being very inconvenient for most situations.

To see how annoying this is, let's revisit the little Data element we
saw above.  In a bit-oriented description language, we would need to
write something like:

@example
deftype BitData =
  struct
  @{
    byte magic;
    byte count;
    byte dstart;

    byte[count] data @@ dstart * 8;
  @};
@end example

Yeah... exactly.  The @key{*} and @key{8}> keys in the keyboards of
the poke users would wear out very fast, not to mention their patience
as well.  Also, should I provide both @code{sizeof} and
@code{bitsizeof} operators?  Nasty.

I am very fond of the maxim ``Never write a program you would never
use yourself''@footnote{Actually it is Lord Vetinari's ``Never build a
dungeon you can't get out of.'' but the point is the same.}, so I
resigned myself to make GNU poke byte oriented, and to provide as many
facilities for operating on bit-fields as possible.

@noindent
Fortunately, I have smart friends...

During one of the Rabbit Herd's Hacking
Weekends@footnote{@url{http://www.jemarch.net/rhhw}} I shared my
frustration and struggle with the other rabbits, and we came to
realize that offsets and data sizes in Poke should not be pure
magnitudes or mere integer values: they should be united.  They should
have units.

It makes full sense when you come to think about it.  For a program
like poke, it is only natural to talk about different memory units,
like bits, bytes, kilobytes, megabits, and so on.  Bits and bytes are
just too common units.  Apart from allowing me to express values in
different units, this approach also has other benefits as we will see
shortly.

I'm really grateful to Bruno Haible, Luca Saiu and Nacho Gonzalez for
putting me on the right track.

@node Offset Literals
@section Offset Literals

Poke provides a convenient syntax to provide united values, which are
called @dfn{offsets} (because in a binary editor you mostly use them
to denote offsets in the file you are editing):

@example
12#B
7#b
1024#Kb
@end example

The offsets above denote twelve bytes, seven bits and one thousand
twenty four kilobytes, respectively.  The unit can be separated from
the magnitude by blank characters, so you can write the following
instead if you are so inclined:

@example
12 #B
7 #b
(1024 * 1024) #Kb
@end example

Note how the magnitude part of an offset doesn't need to be constant.
If the variable @code{a} contains an integer, this is how you would
denote ``a bytes'':

@example
a#B
@end example

In the offset syntax units are specified as @code{#@var{foo}}, where
@var{FOO} is the name of the unit.  Poke provides the following list
of hardcoded unit names:

@table @code
@item b
bits.
@item B
bytes.
@item Kb
kilo bits (1024 bits.)
@item KB
Kilo bytes (1024 bytes.)
@item Mb
Mega bits.
@item MB
Mega bytes.
@item Gb
Mega bits.
@end table

However, it is also possible to express units in multiples of the base
unit, which is the bit.  Using this syntax, it becomes possible to
express offsets in any arbitrary unit, as disparate as it may seem:

@example
17#3
0#12
8#1
@end example

Thats it, 17 units of 3 bits each, zero units of 12 bits each,
and eight units of 1 bit each.

But then, why stopping there?  Poking is all about defining data
structures and operating on them... so why not using these structures
as units as well?  Consider the following struct:

@example
deftype Packet = struct @{ int i; long j; @};
@end example

The size of a @code{Packet} is known at compile time (which is not
generally true for Poke structs).  Wouldn't it be nice to use it as a
unit in offsets?  Sure it is:

@example
23#Packet
@end example

The above is the size occupied by 23 packets.  Any type whose size is
known at compile time can be specified as an offset unit.

Expressing offsets as united values also relieves the programmer from
doing many explicit unit conversions: poke can do them for you.
Consider for example an ELF section header.  One of its fields is the
size of the described section, in bytes:

@example
deftype Elf64_Shdr =
  struct
  @{
   ...
   offset<Elf64_Xword,B> sh_size;
   ...
  @};
@end example

If a given section is to contain, say, relocations with addends,
we can set its size doing something like this:

@example
shdr.sh_size = 10#Elf64_Rela;
@end example

@noindent
Instead of doing the conversion to bytes explicitly.

If the magnitude of an offset is 1 then it is allowed to omit it
entirely.  To denote one kilobyte, for example, we can write
@code{#KB}.

@node Offset Types
@section Offset Types

Offset types are denoted as @code{offset<@var{base_type},@var{unit}>},
where @var{base_type} is an integer type and @var{unit} the
specification of an unit.

The offset base type is the type of the magnitude part of the united
value.  It can be any integer type, signed or unsigned, of any size.

The unit specification should be one of the unit identifiers that are
allowed in offset literals (see above) or the name of a Poke type
whose size is known as compile time.

Let's see some examples.  A signed 32-bit offset expressed in bytes
has type @code{offset<int<32>,B>}.  An unsigned 12-bit offset
expressed in kilobits has type @code{offset<uint<12>,Kb>}.  Finally, a
signed 64-bit offset in units of ``packets'', where a packet is
denoted with a Poke type @code{Packet} has type
@code{offset<uint<64>,Packet>}.

@node Casting Offsets
@section Casting Offsets

The right-associative unary operator cast @code{as} can be used to
derive a new offset value having a different type from an existing
value.

For example, this is how we would create a signed 12-bit offset in
units bytes:

@example
(poke) 1024#b as offset<int<12>,B>
(int<12>) 128#B
@end example

The same rules governing conversion of integers apply for the
magnitude part.  Depending on the unit, there can be truncation, like
in:

@example
(poke) 9#b as offset<int,B>
1#B
@end example

@node Offset Operations
@section Offset Operations

Poke supports a little algebra for offsets.

@subsection Addition and subtraction

The addition or subtraction of two offsets results in another offset.
Examples:

@example
(poke) 1#B + 1#b
9#b
(poke) 2#KB - 1024#B
1024#B
@end example

The unit of the result is the greatest common divisor of the units of
the operands.

@subsection Multiplication by a scalar

Multiplying an offset by a magnitude gives you another offset.
Examples:

@example
(poke) 8#b * 2
16#b
(poke) 16#MB * 0
0#MB
@end example

The unit of the result is the same than the unit of the offset
operand.

Note that multiplying two offsets is not supported.  This makes sense,
since computer memory is linear, and therefore it wouldn't make any
sense to have units like @code{#B@sup{2}}.

@subsection Division

Dividing two offsets gives you a magnitude.  Examples:

@example
(poke) 16#b / 1#B
2
(poke) 1024#MB / 512#Mb
16
@end example

Dividing offsets is the Pokish way of converting memory magnitudes
between different units: just use units like you do when doing physics
or working with units in other contexts.

For example, using the syntactic trick of omitting the magnitude (in
which case it is assumed to be 1) it is very natural to write
something like the following to convert from kilobits to bytes:

@example
(poke) 24 #Kb/#B
3072
@end example

@subsection Modulus

The modulus of two offsets gives you another offset with the expected
semantics.  Examples:

@example
(poke) 9#b % 1#B
1#b
(poke) 1#B % 9#b
8#b
@end example

The unit of the result is the greatest common divisor of the units of
the operands.

@node Offset Attributes
@section Offset Attributes

The following attributes are defined for offset values.

@table @code
@item size
Gives an offset with the storage occupied by the offset.  Examples:

@example
(poke) 10#B'size
0x20UL#b
(poke) 10N#B'size
0x4UL#b
@end example
@item magnitude
Gives the magnitude part of the offset.  Examples:

@example
(poke) 10#B'magnitude
10
(poke) 2H#b'magnitude
2H
@end example
@item unit
Gives a number with the unit of the offset, expressed in bits.
Examples:

@example
(poke) 10#B'unit
8UL
(poke) 2H#b'unit
1UL
@end example
@item mapped
Always 0 for offsets.  See mapping.
@end table


@node Strings
@chapter Strings
@cindex strings

Poke supports a notion of @dfn{strings} which is very similar to the C
programming language: a string value is a sequence of characters that
is terminated by the so-called @dfn{null character}.

@menu
* String Literals::		Writing string values.
* String Types::		string.
* String Indexing::		Accessing the characters of a string.
* String Concatenation::        Building new strings.
* String Attributes::           Accessing properties of string values.
@end menu

@node String Literals
@section String Literals

NULL-terminated sequences of ASCII codes can be denoted using the
following syntax:

@example
"foo"
@end example

Poke string values are very similar to C strings.  They comprise a
sequence of 8-bit character codes, terminated by the value @code{0UB}.

The following escape sequences are supported inside string literals:

@table @code
@item \n
Denotes a new line character.
@item \t
Denotes an horizontal tab.
@item \\
Denotes a backlash @code{\} character.
@end table

@node String Types
@section String Types

Every string value in Poke is of type @code{string}.

@node String Indexing
@section String Indexing

Poke supports accessing the characters in a string using the array
indexing notation.  The indexes are in the @code{[0,@var{n}]} range,
where @var{n} is the length of the string minus one.  Note the length
doesn't include the null character, i.e. it is not possible to access
the terminating null.  Examples:

@example
(poke) "foo"[0]
0x66UB
(poke) "foo"[1]
0x6fUB
@end example

If the passed index is less than zero or it is too big, an
@code{E_out_of_bounds} exception is raised:

@example
(poke) "foo"[-1]
unhandled out of bounds exception
(poke) "foo"[3]
unhandled out of bounds exception
@end example

@node String Concatenation
@section String Concatenation

Strings can be concatenated using the @code{+} operator.  This works
like this:

@example
(poke) "foo" + "bar"
"foobar"
@end example

Note how the null character terminating the first string is removed.
Therefore, the length of the concatenation of two given strings
of lengths @code{N} and @code{M} is always @code{N+M-1}.

Concatenation and indexing are useful together for building strings.
A string can be created empty, and additional characters added to it
by means of concatenation:

@example
(poke) defvar bytes = "";
(poke) bytes = bytes + 'x' as string;
@end example

Then, we can retrieve characters from the string we built using
indexing:

@example
(poke) bytes[0]
0x78UB
@end example

@node String Attributes
@section String Attributes

The following attributes are defined for string values.

@table @code
@item length
Gives the number of characters composing the string, not counting the
terminating null.  Examples:

@example
(poke) "foo"length
3UL
(poke) ""'length
0UL
@end example

@item size
Gives an offset with the storage occupied by the string.  This
includes the terminating null.  Examples:

@example
(poke) "foo"'size
32UL#b
(poke) ""'size
8UL#b
@end example
@item mapped
Always 0 for strings.  See mapping.
@end table

@node Arrays
@chapter Arrays
@cindex arrays

Arrays are homogeneous collections of values.

@menu
* Array Literals::		Writing array values.
* Array Types::			Bounded and unbounded arrays.
* Array Indexing::		Accessing values stored in arrays.
* Array Trimming::		Working with array pieces.
* Array Attributes::		Accessing properties of array values.
@end menu

@node Array Literals
@section Array Literals

Array literals are constructed using the following syntax:

@example
[@var{exp},@var{exp}...]
@end example

Where @var{exp} is an arbitrary expression.

For example, @code{[1,2,3]} constructs an array of three signed 32-bit
integers.  Likewise, @code{['a','b','c']} constructs an array of three
unsigned 8-bit integers (characters).

The type of the array literal is inferred from the type of its
elements.  Accordingly, all the elements in an array literal must be
of the same type.  Examples of invalid array literals, that will raise
a compilation-time error if evaluated, are:

@example
[1,2u,3]
[1,0xffff_ffff,3]
['a',"b",'c']
@end example

Array literals must contain at least one element.  Accordingly,
@code{[]} is not a valid array literal.

This is how a @code{3x3} matrix could be constructed using an array of
arrays:

@example
[[1,2,3],[4,5,6],[7,8,9]]
@end example

It is possible to refer to specific elements when constructing array
literals.  For example, @code{[1,2,3,.[3] = 4]} denotes the same
array than @code{[1,2,3,4]}.

This allows creating arrays without having to specify all its
elements.  Unspecified elements have the next specified value.  For
example, @code{[.[2] = 2]} denotes the same array than
@code{[2,2,2]}.

Note that an array element can be referenced more than once.  When
that happens, the final value of the element is the last specified.
For example, @code{[1,2,3,.[1]=10]} denotes the array @code{[1,10,3]}.

@node Array Types
@section Array Types

There are three different kind of array types in Poke.

@dfn{Unbounded} arrays have no explicit boundaries.  Examples are
@code{int[]} or @code{Elf64_Shdr[]}.  Arrays can be @dfn{bounded by
number of elements} specifying a Poke expression that evaluates to an
integer value.  For example, @code{int[2]}.  Finally, arrays can be
@dfn{bounded by size} specifying a Poke expression that evaluates to
an offset value.  For example, @code{int[8#B]}.

@subsection Writing unbounded array literals

The type of an array literal is always bounded by number of elements.
For example, the type of @code{[1,2,3]} is @code{int[3]}.  If what we
want is an unbounded array literal we can obtain it with a case like
@code{[1,2,3] as int[]}.

@subsection Array boundaries and closures

Poke arrays are rather peculiar.  One of their seemingly bizarre
characteristics is the fact that the expressions calculating their
boundaries (when they are bounded) evaluate in their own lexical
environment, which is captured.  In other words: the expressions
denoting the boundaries of Poke arrays conform closures.  Also, the
way they evaluate may be surprising.  This is no capricious.

When an array type is bounded, be it by number of elements or by size,
the expression indicating the boundary doesn't need to be constant and
it can involve variables.  For example, consider the following type
definition:

@example
defvar N = 2;
deftype List = int[N*2];
@end example

@noindent
Let's map a @code{List} at some offset:

@example
(poke) List @@ 0#B
[0x746f6f72,0x303a783a,0x723a303a,0x3a746f6f]
@end example

As expected, we get an array of four integers.  Very good,
obviously the boundary expression @code{N*2} got evaluated
when defining the type @code{List}, and the result of the
evaluation was @code{4}, right?.  Typical semantics like in my
garden variety programming language... right?  Right?!?

Well, not really.  Let's modify the value of @code{N} and map
a @code{List} again...

@example
(poke) N = 1
(poke) List @@ 0#B
[0x746f6f72,0x303a783a]
@end example


Yes, The boundary of the array type changed... come on, this is Poke,
was you @strong{really} expecting something typical? ;)

What happens is that at type definition time the lexical environment
is captured and a closure is created.  The body of the closure is the
expression.  Every time the type is referred, the closure is
re-evaluated and a new value is computed.

Consequently, if the value of a variable referred in the expression
changes, like in our example, the type itself gets updated
automagically.  Very nice but, why is Poke designed like this?  Just
to impress the cat?  Nope.

In binary formats, and also in protocols, the size of some given data
is often defined in terms of some other data that should be decoded
first.  Consider for example the following definition of a
@code{Packet}:

@example
deftype Packet =
  struct
  @{
    byte size;
    byte[size] payload;
  @};
@end example

Each packet contains a 8-bit integer specifying the size of the
payload transported in the packet.  The payload, a sequence of
@code{size} bytes, follows.

In struct types like the above, the boundaries of arrays depend on
fields that have been decoded before and that exist, like variables,
in the lexical scope captured by the struct type definition (yes,
these are also closures, but that's for another article.)  This
absolutely depends on having the array types evaluate their bounding
expressions when the type is used, and not at type definition time.


@noindent
To show this property in action, let's play a bit:

@example
(poke) defvar data = byte[4] @@ 0#B
(poke) data[0] = 2
(poke) data[1] = 3
(poke) data[2] = 4
(poke) data[3] = 5
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff
00000000: 0203 0405 0000 0000 0000 0000 0000 0000
00000010: 0000 0000 0000 0000 0000 0000 0000 0000
(poke) defvar p1 = Packet @@ 0#B
(poke) defvar p2 = Packet @@ 1#B
(poke) p1
Packet @{size=0x2UB,payload=[0x3UB,0x4UB]@}
(poke) p2
Packet @{size=0x3UB,payload=[0x4UB,0x5UB,0x0UB]@}
@end example

Now, let's change the data and see how the sizes of the payloads
are adjusted accordingly:

@example
(poke) data[0] = 1
(poke) data[1] = 0
(poke) p1
Packet @{size=0x1UB,payload=[0x0UB]@}
(poke) p2
Packet @{size=0x0UB,payload=[]@}
@end example

So, as we have seen, Poke's way of handling boundaries in array types
allows data structures to adjust to the particular data they contain,
so usual in binary formats.  This is an important feature, that gives
Poke part of it's feel and magic.

@node Array Indexing
@section Array Indexing

Arrays are indexed using the usual notation, providing an index
enclosed between square brackets with @code{[} and @code{]}:

@example
(poke) [1,2,3][0]
1
(poke) [1,2,3][1]
2
@end example

The index should be an expression that evaluates to an integer value,
and it is promoted to an unsigned 64-bit integer when needed.

The valid range for the index is @code{[0,@var{n}]} where @var{n} is
the number of elements stored in the array minus one.  If the passed
integer is out of that range, an @code{E_out_of_bounds} exception is
raised:

@example
(poke) [1,2,3][-1]
unhandled out of bounds exception
(poke) [1,2,3][3]
unhandled out of bounds exception
@end example

@node Array Trimming
@section Array Trimming

Indexing is used to fetch elements from arrays.  Another operation,
called @dfn{trimming}, allows to extract a subset of the array, as
another array.

Trims use the following notation, where a range is specified between
square brackets.  Both sides of the range are included:

@example
(poke) [1,2,3][0:1]
[1,2]
(poke) [1,2,3][1:1]
[2]
(poke) [1,2,3][0:2]
[1,2,3]
@end example

If the minimum side of the range is omitted, it is assumed to be zero.
If the maximum side of the range is omitted, it is assumed to be the
length of the trimmed array minus one:

@example
(poke) [1,2,3][:1]
[1,2]
(poke) [1,2,3][1:]
[2,3]
(poke) [1,2,3][:]
[1,2,3]
@end example

The elements of the base array and the trimmed sub-array are copied by
shared value, exactly like when passing arguments to functions.  This
means that for simple types, copies of the elements are done:

@example
(poke) defvar a = [1,2,3]
(poke) defvar s = a[1:1]
(poke) s[0] = 66
(poke) a
[1,2,3]
@end example

However, for comples types like arrays and structs, the values are
shared:

@example
(poke) defvar a = Packet[] @@ 0#B
(poke) defvar s = a[1:1]
(poke) s[0].field = 66
(poke) a[1].field
66
@end example

@node Array Attributes
@section Array Attributes

The following attributes are defined for array values.

@table @code
@item size
Gives an offset with the storage occupied by the complete array.
Example:

@example
(poke) [1,2,3]'size
96UL#b
@end example
@item length
Gives the number of elements stored in the array.  Example:

@example
(poke) [1,2,3]'length
3
@end example
@item mapped
Gives 1 if the array is mapped, 0 otherwise.  Examples:

@example
(poke) defvar a = [1,2,3]
(poke) defvar b = int[3] @ 0#B
(poke) a'mapped
0
(poke) b'mapped
1
@end example
@end table


@node Endianness
@chapter Endianness
@cindex endian, endianness

Byte endianness is an important aspect of encoding data.  As a good
binary editor poke provides support for both little and big endian,
and will soon acquire the ability to encode exotic endianness like PDP
endian.  Endianness control is integrated in the Poke language, and is
designed to be easily used in type descriptions.

@menu
* .set endian::			dot-command to get and set the endianness.
* Endian built-ins::		changing endianness programmatically.
@end menu

@node .set endian
@section .set endian
@cindex commands

GNU poke maintains a global variable that holds the current
endianness.  This is the endianness that will be used when mapping
integers whose types do not specify an explicit endianness.

Like other poke global state, this global variable can be
modified using the @command{.set} dot-command:

@example
.set endian little
.set endian big
.set endian host
@end example

@noindent
The current endianness can be obtained like this:

@example
(poke) .set endian
little
@end example

We can easily see how changing The current endianness indeed impacts
the way integers are mapped:

@example
(poke) dump :from 0#B :size 4#B :ruler 0 :ascii 0
00000000: 8845 4c46
(poke) .set endian little
(poke) int @@ 0#B
0x464c4588
(poke) .set endian big
(poke) int @@ 0#B
0x88454c46
@end example

@node Endian built-ins
@section Endian built-ins

As handy as the @command {.set endian} dot-command may be, it is also
important to be able to change the current endianness programmatically
from a Poke program.  For that purpose, the PKL compiler provides a
couple of built-in functions: @code{get_endian} and @code{set_endian}.

Their definitions, along with the specific supported values, look
like:

@example
defvar ENDIAN_LITTLE = 0;
defvar ENDIAN_BIG = 1;

defun get_endian = int: @{ ... @}
defun set_endian = (int endian) int: @{ ... @}
@end example

Accessing the current endianness programmatically is especially useful
in situations where the data being poked features a different
structure, depending on the endianness.

A good (or bad) example of this is the way registers are encoded in
eBPF instructions.  eBPF is the in-kernel virtual machine of Linux,
and features an ISA with ten general-purpose registers.  eBPF
instructions generally use two registers, namely the source register
and the destination register.  Each register is encoded using 4 bits,
and the fields encoding registers are consecutive in the instructions.

Typical.  However, for reasons we won't be discussing here the order
of the source and destination register fields is switched depending on
the endianness.

@noindent
In big-endian systems the order is:

@example
dst:4 src:4
@end example

@noindent
Whereas in little-endian systems the order is:

@example
src:4 dst:4
@end example

In Poke, the obvious way of representing data whose structure depends
on some condition is using an union.  In this case, it could read like
this:

@example
deftype BPF_Insn_Regs =
  union
  @{
    struct
    @{
      BPF_Reg src;
      BPF_Reg dst;
    @} le : get_endian == ENDIAN_LITTLE;

    struct
    @{
      BPF_Reg dst;
      BPF_Reg src;
    @} be;
  @};
@end example

Note the call to the @code{get_endian} function (which takes no
arguments and thus can be called Algol68-style, without specifying an
empty argument list) in the constraint of the union alternative.  This
way, the register fields will have the right order corresponding to
the current endianness.

Nifty.  However, there is an ever better way to denote the
structure of these fields.  This is it:

@example
deftype BPF_Insn_Regs =
  struct
  @{
    defvar little_p = (get_endian == ENDIAN_LITTLE);

    BPF_Reg src @@ !little_p * 4#b;
    BPF_Reg dst @@ little_p * 4#b;
  @};
@end example

This version, where the ordering of the fields is implemented using
field labels, is not only more compact, but also has the virtue of not
requiring additional "intermediate" fields like @code{le} and
@code{be} above.  It also shows how convenient can be to declare
variables inside structs.

@noindent
Let's see it in action:

@example
(poke) BPF_Insn_Regs @@ 1#B
BPF_Insn_Regs @{src=#<%r4>,dst=#<%r5>@}
(poke) .set endian big
(poke) BPF_Insn_Regs @@ 1#B
BPF_Insn_Regs @{src=#<%r5>,dst=#<%r4>@}
@end example

Changing the current endianness in constraint expressions is useful
when dealing with binary formats that specify the endianness of the
data that follows using some sort of tag.  This is the case of ELF,
for example.

The first few bytes in an ELF header conform what is known as the
@code{e_ident}.  One of these bytes is called @code{ei_data} and its
value specifies the endianness of the data stored in the ELF file.

@noindent
This is how we handle this in Poke:

@example
defun elf_endian = (int endian) byte:
 @{
   if (endian == ENDIAN_LITTLE)
     return ELFDATA2LSB;
   else
     return ELFDAT2MSB;
 @}

[...]

deftype Elf64_Ehdr =
  struct
  @{
    struct
    @{
      byte[4] ei_mag : ei_mag[0] == 0x7fUB
                       && ei_mag[1] == 'E'
                       && ei_mag[2] == 'L'
                       && ei_mag[3] == 'F';
      byte ei_class;
      byte ei_data : (ei_data != ELFDATANONE
                      && set_endian (elf_endian (ei_data)));
      byte ei_version;
      byte ei_osabi;
      byte ei_abiversion;
      byte[6] ei_pad;
      offset<byte,B> ei_nident;
    @} e_ident;

    [...]
  @};
@end example

Note how @code{set_endian} returns an integer value...  it is always
@code{1}. This is to facilitate its usage in fields constraint
expressions.

@node Mapping
@chapter Mapping

The purpose of poke is to edit an ``IO space'', which is the file or
device being edited.  This is achieved by mapping values, which is
perhaps the most important concept in Poke.

@menu
* The Map Operator::		The @@ operator.
* Mapping Simple Types::	Mapping integers, offsets and strings.
* Mapping Structs::		Mapping collections of fields.
* Mapping Arrays::		Mapping sequences of things.
@end menu

@node The Map Operator
@section The Map Operator

XXX

@node Mapping Simple Types
@section Mapping Simple Types

XXX

@node Mapping Structs
@section Mapping Structs

XXX

@node Mapping Arrays
@section Mapping Arrays

Arrays can be mapped in IO space in three different ways, depending on
the characteristics of the type provided to the mapping operator.

@subsection Array maps bounded by number of elements

When an array type bounded by number of elements is used in a mapping
operation, the resulting mapped array is also bounded by number of
elements.

For example, this is how we would map an array of four 32-bit signed
integers in the current IO space:

@example
(poke) int[4] @@ 0#B
[10,20,30,40]
@end example

Since you can also provide a dynamic array type to the map operator,
the number of elements doesn't need to be constant.  For example,
given the variable @code{nelems} has a value of @code{2}:

@example
(poke) defvar nelems = 2
(poke) int[nelems + 1] @@ 0#B
[100,222,333]
@end example

If an end-of-file condition happens while mapping the array, because
the number of elements specified in the array type, at the given
offset, exceeds the capacity of the underlying IO device, an exception
is raised and the mapping is not completed:

@example
(poke) int[99999999999] @@ 0#B
unhandled EOF exception
@end example

Likewise, if a constraint fails while performing the mapping (while
mapping an array of structs, for example) an exception is raised and
the map is aborted.

@subsection Array maps bounded by size

While dealing with binary formats, it often happens that the number of
entities in a collection is given by the space they occupy, rather
than the count itself.

For example, consider ELF sections holding relocations.  These
sections contain a collection of zero or more relocations. The layout
of each relocation is specified by the following type:

@example
deftype Elf64_Rela =
  struct
  @{
    offset<Elf64_Addr,B> r_offset;
    Elf64_Xword r_info;
    Elf64_Sxword r_addend;
  @};
@end example

The section is described by an entry in the ELF sections header table:

@example
deftype Elf64_Shdr =
  struct
  @{
    Elf_Word sh_name;
    Elf_Word sh_type;
    Elf64_Xword sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off sh_offset;
    offset<Elf64_Xword,B> sh_size;
    Elf_Word sh_link;
    Elf_Word sh_info;
    Elf64_Xword sh_addralign;
    offset<Elf64_Xword,b> sh_entsize;
  @};
@end example

The relevant elements of @code{Elf64_Shdr} are @code{sh_offset} and
@code{sh_size}, which indicate the offset of the beginning of the
section's contents, and its size, respectively.  At this point, if we
wanted to get an array with all the relocations in the section, we
could map an array bounded by number of elements like we saw in the
previous section, like this:

@example
(poke) Elf64_Rela[sh_size / 1#Elf64_Rela]
[... relocs ...]
@end example

However, this approach adoleces from two problems.  First, it doesn't
work with any entity type.  For an offset like @code{1#Elf64_Rela} to
work, it is required to know the size of the type specified as the
unit at compile time.  In the particular case of @code{Elf64_Rela},
that condition is satisfied, but too often that's not the case.  For
example, think about a section containing @code{NULL} terminated
strings: you can't know the number of strings contained in the section
until you actually read it.

Another problem is when the data in the header is corrupted.  Using
the mapping bounded by number of elements, we wouldn't realize it.  It
would be good if the tool would tell us whether the specified size
actually holds an exact number of the requested elements.

A mapping bound by size is what we need.  Fortunately, as we saw when
discussing array types, Poke allows to specify an offset instead of an
integral value, in the array type specification.  The right amount of
entities (in this case relocations) to strictly satisfy the provided
size will be mapped in the IO space.  So, in order to obtain an array
containing all the relocations in the section, we simply write:

@example
(poke) Elf64_Rela[ehdr.sh_size] @@ ehdr.sh_offset
[... relocs ...]
@end example

The strictness mentioned above is important.  GNU poke will complain
(and abort the mapping) if it is not possible to map an exact number
of elements.  Thus the following mapping would not be successful:

@example
(poke) int[33#b] @@ 0#B
unhandled out of map bounds exception
@end example

Like in mappings bounded by number of elements, if a constraint fails
while performing the mapping, an exception is raised and the map is
aborted.

@subsection Unbounded array maps

We mentioned above that if an end-of-file condition happens while
performing a mapping (be it bounded by number of elements or bounded
by size) an EOF exception is raised, and the mapping operation is
aborted.

Unbounded array mappings are performed by using an unbounded array
type in the mapping operation, like in:

@example
@var{type}[] @@ 0#B
@end example

The above construction will map values of type @var{type} in the IO
space until there is an end-of-file condition, or a constraint fails,
whatever happens first.  When it is a constraint expression that
fails, that last element is not included in the mapped array.

Let's assume a binary file contains a series of blocks, located one
after the other, of a kind described by the following struct type:

@example
deftype Block =
  struct
  @{
     byte magic[2] : magic[0] == 'B' && magic[1] == 'K';
     ... other data ...
  @};
@end example

we can map the blocks using an unbounded array map:

@example
(poke) Block[] @@ 0#B
[ ... blocks ... ]
@end example

If the blocks extend up to the end of the IO space, that many blocks
will be mapped.  If there is some other content in the file following
the blocks, the constraint in the @code{magic} field will fail and
will delimit the map that way (provided the binary format is well
designed.)

@subsection Mapped bounds in bounded arrays

When an array map is bounded, be it by number of elements or by size,
the bounding value can be mapped itself.  To illustrate how this
works, let's go back to our ELF file and the section containing
relocations.  First, we map an @code{Elf64_Shdr} to get the section
header:

@example
(poke) defvar shdr = Elf64_Shdr @@ @var{offset}
(poke) shdr.sh_offset
120#B
(poke) shdr.sh_size
24#B
@end example

Now we map an array with the relocations themselves, using a map
bounded by size, as we learned in the last section:

@example
(poke) defvar relocs = ELF64_Rela[shdr.sh_size] @@ shdr.sh_offset
(poke) relocs'length
3
@end example

Now, observe that @code{shdr.sh_size} is mapped itself!  This means
that, should the section size be modified (to accommodate an extra
relocation, for example) the mapping of @code{relocs} will reflect
that automatically:

@example
(poke) shdr.sh_size = shdr.sh_size + 1#Elf64_Rela
(poke) relocs'length
4
@end example

This is certainly an useful idiom, that is often used while poking
around.  However, sometimes this is @emph{not} what we want.  If we
don't want the mapping bounds of @code{relocs} to be tied to
@code{shdr}, we can just use a temporary for the size:

@example
(poke) defvar s = shdr.sh_size
(poke) defvar relocs = Elf64_Rela[s] @@ shdr.sh_offset
@end example

Since simple values (such as the size above) are not mapped, this
trick works as intended.

@node Output
@chapter Output

Poke programs can print text to the standard output in two ways:
simple unformatted output, and formatted output.

@menu
* print::			simple output.
* printf::			formatted output.
* Pretty Printers::		improve the legibility of your data structures.
@end menu

@node print
@section print
@cindex print, output

The @code{print} sentence prints the given string to the standard output.
@code{print} outputs text strings verbatim.  It can be invoked using
two alternative syntaxes, which are equivalent:

@example
print (@var{str});
print @var{str};
@end example

@code{print} is simple, but fast.  It is good to use it in simple
cases where the information to print out doesn't require any kind of
formatting and styling.

@node printf
@section printf
@cindex printf, formatted output, stylized output

The @code{printf} sentence gets a format string and, optionally, a
list of values to print.  It can be invoked using two alternative
syntaxes, which are equivalent:

@example
printf (@var{fmt}[, @var{value}...])
printf @var{fmt}[, @var{value}...]
@end example

The format string @var{fmt} is printed verbatim to the standard
output, but for @dfn{format tags} which start with @code{%}.  These
format tags are interpreted especially.

Most of the format tags ``consume'' one of the specified values.
Every value in the list shall be described by a tag, or the compiler
will signal an error.  Likewise, values without a corresponding
describing tag is an error.  These tags are:

@table @code
@item %s
Print the argument as a string.
@item %i@var{bits}(d|x|o|b|c)
Print the argument as a signed integer of size @var{bits}.  The last
letter determines how the argument is printed.
@table @code
@item d
Print the integer in decimal.
@item x
Print the integer in hexadecimal.
@item o
Print the integer in octal.
@item b
Print the integer in binary.
@item c
Print the integer as an ASCII character.  This only works with 8 bit
integers.
@end table
@item %u
Same than @code{%s}, but for unsigned integers.
@item %c
A shorter way to write @code{%u8c}.
@item %v
Print the value printed representation of the argument, which can be
of any type including complex types like arrays and structs.  This is
similar to the @code{write} operation available in many Lisp systems.

This tag is mainly intended to be used in pretty-printers.
@end table

The following format tags do not consume arguments.  They support
emitting styled text using the libtextstyle approach of having styling
classes that user can customize in a @file{.css} file.

@table @code
@item %<@var{classname}:
Start the styling class with name @var{classname}.  The class name
cannot be empty.
@item %>
End the last opened styling class.  All styling classes should be
ended before finishing the format string.
@end table

Note that styling classes can be nested, but all classes should be
ended before finishing the format string.

If you use a @var{name} class, you can define how to style it in the
@file{.css} file (poke installs and uses poke-default.css but you can
set the @code{POKE_STYLE} environment variable to point to another
css) like this:

@example
.NAME @{ text-decoration: blink; color : pink; @}
@end example

Examples:

@example
(poke) printf "This is a NAME: %<NAME:xxx%>"
This is a NAME: xxx
(poke) printf "Name: %<string:%s%> Age: %<integer:%i32d%>, "Jose", 39
Name: Jose Age: 39
@end example

@node Pretty Printers
@section Pretty Printers

XXX

@node Writing Commands
@chapter Writing Commands

XXX

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
