\input texinfo
@comment %**start of header
@setfilename poke.info
@include version.texi
@settitle The Poke Book
@afourpaper
@comment %**end of header

@copying
This book describes GNU poke (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2019 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Editors
@direntry
* poke: (poke). Interactive editor for binary files.
@end direntry

@titlepage
@title The Poke Book
@subtitle for version @value{VERSION}, @value{UPDATED}
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Poke Book

@insertcopying
@end ifnottex

@c Introduction
@c
@c - Motivation, and history (first part of talk)
@c - Nomenclature
@c - The program
@c - Demo: poking a relocation
@c
@c The Language
@c
@c Values
@c Types
@c Structs
@c Arrays
@c
@c The Program
@c
@c Dump
@c Files
@c Settings
@c pokerc
@c Styling poke's output
@c
@c Hacking poke
@c
@c Writing poke commands.

@menu
@c * Motivation::			Why a binary editor?
* Nomenclature::		poke, Poke and pickles.
@c * Demo
* Endianness::			byte ordering.
* Output::			printing in Poke programs.

Appendices
* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@end menu

@node Nomenclature
@chapter Nomenclature
@cindex poke, Poke, pickle

GNU poke is a new program and it introduces many a new concept.  It is
a good idea to clarify how we call things in the poke community.
Unless everyone uses the same nomenclature to refer to pokeish
thingies, it is gonna get very confusing very soon!

First of all we have @command{poke}, the program.  Since ``poke'' is a
very common English word, when the context is not clear we either use
the full denomination @command{GNU poke}, or quote the word using some
other mean.

Then we have @dfn{Poke}, with upper case P, which is the name of the
domain-specific programming language implemented by @command{poke},
the program.

This distinction is important.  For example, when people talk about
``poke programmers'' they refer to the group of people hacking GNU
poke.  When they talk about ``Poke programmers'' they refer to the
people who write programs using the Poke programming language.

Finally, a @dfn{pickle} is a Poke source file containing definitions
of types, variables, functions, etc, that conceptually apply to some
definite domain.  For example, @file{elf.pk} is a pickle that provides
facilities to poke ELF object files.  Pickles are not necessarily
related to file formats: a set of functions to work with bit patterns,
for example, could be implemented in a pickle named
@file{bitpatterns.pk}.

We hope this helps to clarify things.

@node Endianness
@chapter Endianness
@cindex endian, endianness

Byte endianness is an important aspect of encoding data.  As a good
binary editor poke provides support for both little and big endian,
and will soon acquire the ability to encode exotic endianness like PDP
endian.  Endianness control is integrated in the Poke language, and is
designed to be easily used in type descriptions.

@menu
* .set endian::			dot-command to get and set the endianness.
* Endian built-ins::		changing endianness programmatically.
@end menu

@node .set endian
@section .set endian
@cindex commands

GNU poke maintains a global variable that holds the current
endianness.  This is the endianness that will be used when mapping
integers whose types do not specify an explicit endianness.

Like other poke global state, this global variable can be
modified using the @command{.set} dot-command:

@example
.set endian little
.set endian big
.set endian host
@end example

@noindent
The current endianness can be obtained like this:

@example
(poke) .set endian
little
@end example
      
We can easily see how changing The current endianness indeed impacts
the way integers are mapped:

@example
(poke) dump :from 0#B :size 4#B :ruler 0 :ascii 0
00000000: 8845 4c46
(poke) .set endian little
(poke) int @ 0#B
0x464c4588
(poke) .set endian big
(poke) int @ 0#B
0x88454c46
@end example

@node Endian built-ins
@section Endian built-ins

As handy as the @command {.set endian} dot-command may be, it is also
important to be able to change the current endianness programmatically
from a Poke program.  For that purpose, the PKL compiler provides a
couple of built-in functions: @code{get_endian} and @code{set_endian}.

Their definitions, along with the specific supported values, look
like:

@example
defvar ENDIAN_LITTLE = 0;
defvar ENDIAN_BIG = 1;
      
defun get_endian = int: @{ ... @}
defun set_endian = (int endian) int: @{ ... @}
@end example

Accessing the current endianness programmatically is especially useful
in situations where the data being poked features a different
structure, depending on the endianness.

A good (or bad) example of this is the way registers are encoded in
eBPF instructions.  eBPF is the in-kernel virtual machine of Linux,
and features an ISA with ten general-purpose registers.  eBPF
instructions generally use two registers, namely the source register
and the destination register.  Each register is encoded using 4 bits,
and the fields encoding registers are consecutive in the instructions.

Typical.  However, for reasons we won't be discussing here the order
of the source and destination register fields is switched depending on
the endianness.

@noindent
In big-endian systems the order is:

@example
dst:4 src:4
@end example

@noindent
Whereas in little-endian systems the order is:

@example
src:4 dst:4
@end example

In Poke, the obvious way of representing data whose structure depends
on some condition is using an union.  In this case, it could read like
this:

@example
deftype BPF_Insn_Regs =
  union
  @{
    struct
    @{
      BPF_Reg src;
      BPF_Reg dst;
    @} le : get_endian == ENDIAN_LITTLE;

    struct
    @{
      BPF_Reg dst;
      BPF_Reg src;
    @} be;
  @};
@end example

Note the call to the @code{get_endian} function (which takes no
arguments and thus can be called Algol68-style, without specifying an
empty argument list) in the constraint of the union alternative.  This
way, the register fields will have the right order corresponding to
the current endianness.

Nifty.  However, there is an ever better way to denote the
structure of these fields.  This is it:

@example
deftype BPF_Insn_Regs =
  struct
  @{
    defvar little_p = (get_endian == ENDIAN_LITTLE);
    
    BPF_Reg src @ !little_p * 4#b;
    BPF_Reg dst @ little_p * 4#b;
  @};
@end example

This version, where the ordering of the fields is implemented using
field labels, is not only more compact, but also has the virtue of not
requiring additional "intermediate" fields like @code{le} and
@code{be} above.  It also shows how convenient can be to declare
variables inside structs.

@noindent
Let's see it in action:

@example
(poke) BPF_Insn_Regs @ 1#B
BPF_Insn_Regs @{src=#<%r4>,dst=#<%r5>@}
(poke) .set endian big
(poke) BPF_Insn_Regs @ 1#B
BPF_Insn_Regs @{src=#<%r5>,dst=#<%r4>@}
@end example

Changing the current endianness in constraint expressions is useful
when dealing with binary formats that specify the endianness of the
data that follows using some sort of tag.  This is the case of ELF,
for example.

The first few bytes in an ELF header conform what is known as the
@code{e_ident}.  One of these bytes is called @code{ei_data} and its
value specifies the endianness of the data stored in the ELF file.

@noindent
This is how we handle this in Poke:

@example
defun elf_endian = (int endian) byte:
 @{
   if (endian == ENDIAN_LITTLE)
     return ELFDATA2LSB;
   else
     return ELFDAT2MSB;
 @}

[...]

deftype Elf64_Ehdr =
  struct
  @{
    struct
    @{
      byte[4] ei_mag : ei_mag[0] == 0x7fUB
                       && ei_mag[1] == 'E'
                       && ei_mag[2] == 'L'
                       && ei_mag[3] == 'F';
      byte ei_class;
      byte ei_data : (ei_data != ELFDATANONE
                      && set_endian (elf_endian (ei_data)));
      byte ei_version;
      byte ei_osabi;
      byte ei_abiversion;
      byte[6] ei_pad;
      offset<byte,B> ei_nident;
    @} e_ident;

    [...]
  @};
@end example

Note how @code{set_endian} returns an integer value...  it is always
@code{1}. This is to facilitate its usage in fields constraint
expressions.

@node Output
@chapter Output

Poke programs can print text to the standard output in two ways:
simple unformatted output, and formatted output.

@menu
* print::			simple output.
* printf::			formatted output.
@end menu

@node print
@section print
@cindex print, output

The @code{print} sentence prints the given string to the standard output.
@code{print} outputs text strings verbatim.  It can be invoked using
two alternative syntaxes, which are equivalent:

@example
print (@var{str});
print @var{str};
@end example

@code{print} is simple, but fast.  It is good to use it in simple
cases where the information to print out doesn't require any kind of
formatting and styling.

@node printf
@section printf
@cindex printf, formatted output, stylized output

The @code{printf} sentence gets a format string and, optionally, a
list of values to print.  It can be invoked using two alternative
syntaxes, which are equivalent:

@example
printf (@var{fmt}[, @var{value}...])
printf @var{fmt}[, @var{value}...]
@end example

The format string @var{fmt} is printed verbatim to the standard
output, but for @dfn{format tags} which start with @code{%}.  These
format tags are interpreted especially.

Most of the format tags ``consume'' one of the specified values.
Every value in the list shall be described by a tag, or the compiler
will signal an error.  Likewise, values without a corresponding
describing tag is an error.  These tags are:

@table @code
@item %s
Print the argument as a string.
@item %i@var{bits}(d|x|o|b|c)
Print the argument as a signed integer of size @var{bits}.  The last
letter determines how the argument is printed.
@table @code
@item d
Print the integer in decimal.
@item x
Print the integer in hexadecimal.
@item o
Print the integer in octal.
@item b
Print the integer in binary.
@item c
Print the integer as an ASCII character.  This only works with 8 bit
integers.
@end table
@item %u
Same than @code{%s}, but for unsigned integers.
@item %c
A shorter way to write @code{%u8c}.
@item %v
Print the value printed representation of the argument, which can be
of any type including complex types like arrays and structs.  This is
similar to the @code{write} operation available in many Lisp systems.

This tag is mainly intended to be used in pretty-printers.
@end table

The following format tags do not consume arguments.  They support
emitting styled text using the libtextstyle approach of having styling
classes that user can customize in a @file{.css} file.

@table @code
@item %<@var{classname}:
Start the styling class with name @var{classname}.  The class name
cannot be empty.
@item %>
End the last opened styling class.  All styling classes should be
ended before finishing the format string.
@end table

Note that styling classes can be nested, but all classes should be
ended before finishing the format string.

If you use a @var{name} class, you can define how to style it in the
@file{.css} file (poke installs and uses poke-default.css but you can
set the @code{POKE_STYLE} environment variable to point to another
css) like this:

@example
.NAME @{ text-decoration: blink; color : pink; @}
@end example

Examples:

@example
(poke) printf "This is a NAME: %<NAME:xxx%>"
This is a NAME: xxx
(poke) printf "Name: %<string:%s%> Age: %<integer:%i32d%>, "Jose", 39
Name: Jose Age: 39
@end example

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
