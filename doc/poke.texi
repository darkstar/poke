\input texinfo
@comment %**start of header
@setfilename poke.info
@include version.texi
@settitle GNU poke
@afourpaper
@comment %**end of header

@copying
This manual is for GNU poke (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2017 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Database
@direntry
* poke: (poke). Interactive editor for binary files.
@end direntry

@titlepage
@title GNU poke
@subtitle for version @value{VERSION}, @value{UPDATED}
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU poke

This manual documents version @value{VERSION} of GNU poke.

@insertcopying
@end ifnottex

@menu
Invoking Poke

Basic Editing
@c* Commands::

The Poke Language
* Data Types::			Numbers, arrays and tuples.
* Expressions::			Operators and values.
* Constants::			Named constant values.
* Variables::			Variables and scopes.
* Statements::			Basic execution units.
* Functions::			Defining and calling routines.
* Mapped Variables::            Accessing the IO stream from poke programs.
* Enumerations::		Integers with a restricted domain.
* Bitmasks::                    Integers composed of OR-ed values.
* Structs and Unions::		Structures of heterogeneous data.

Advanced Editing

Extending Poke
@c * Writing commands in C::
@c * Writing commands in Poke::

Poke Internals
* Poke Architecture::		Overall architecture.

* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@end menu

@node Data Types
@chapter Data Types

The poke language is a strongly typed programming language.  It is
(almost) always possible to infer the type of a value, and it is
always possible to infer the storage properties and needs of any type.

The following sections document how these typed values are constructed
and what are the types available for constructing numbers and arrays.

@menu
* Null::			One value to bind them all.
* Integers::			Integer numbers.
* Arrays::			Sequences of elements of the same type.
* Tuples::                      Collections of elements of arbitrary types.
* Type Conversions::		Automatic conversions between types.
@end menu

@node Null
@section Null

@code{null} is a special value in poke that can be of any type.  And
not much more can be said about it at this point, even if it is
actually used for many purposes in the language.  Patience... for now,
just remember that it can also mimic the semantics of the number
@code{0} in every context where a number is expected.

@node Integers
@section Integers

Poke supports the following primitive types for integers:

@table @code
@item char
8-bit ASCII code.
@item byte
@item uint8
Unsigned 8-bit integer.
@item int8
Signed 8-bit integer.
@item uint16
Unsigned 16-bit integer.
@item short
@item int16
Signed 16-bit integer.
@item int
@item int32
Signed 32-bit integer.
@item uint32
Unsigned 32-bit integer.
@item long
@item int64
Signed 64-bit integer.
@item uint64
Unsigned 64-bit integer.
@end table

Integers literals can be expressed in several numeration bases.

@emph{Decimal numbers} use the usual syntax @code{[1-9][0-9]*}.  For
example, @code{2345}.

@emph{Octal numbers} are expressed using a prefix of zero or more
@code{0} digits with syntax @code{0[0-9]+}.  Examples are @code{00},
@code{0100} and @code{0777}.

@emph{Hexadecimal numbers} are expressed using the syntax
@code{0[xX][0-9a-fA-F]+}.  Examples are @code{0x0} and
@code{0xfe00ffff}.  Note that both the @code{x} in the prefix and the
letters in the hexadecimal number are case insensitive.  Thus,
@code{0XdeadBEEF} is a valid (but ugly as hell) literal.

@emph{Binary numbers} are expressed using the syntax
@code{0[bB][01]+}.  Again, the @code{b} in the prefix is
case-insensitive.  Examples of binary literals are @code{0b0} and
@code{0B010}.

Note that negative numbers, of any numeration base, are constructed
using the minus operator as explained below.

@subsection Characters

8-bit unsigned integers can use an alternative literal notation that
is useful when working with @emph{ASCII character codes}.  Printable
character codes can be denoted with @code{'c'}.  Both printable and
non-printable character codes can be denoted using the notation
@code{'\NNN'} where @code{NNN} is an octal number featuring up to
three digits.  The number should be in the range @code{0-255}.

Examples:

@example
'o'
'\000'
@end example

The type of a character literal is always @code{char}.

@subsection The digits separator @code{_}

The character @code{_} can appear anywhere in a numeric literal other
than leading them.  It is ignored, and it's purpose is to make it
easier for programmers to read them:

@example
0xf000_0000_0000_0000
0b0000_0001_0000_0001
@end example

@subsection Types of integer literals

The type of a numeric literal is the smallest signed integer capable
of holding it, starting with 32 bits, in steps of powers of two and up
to 64 bits.

So, for example, the value @code{2} has type @code{int32}, but the
value @code{0xffff_ffff} has type @code{int64}, because it is out of
the range of signed 32-bit numbers.

It is possible to construct unsigned numerical literals using the
suffix @code{u} or @code{U}.  So, for example @code{0xffff_ffffU} has
type @code{uint32} and @code{0u} has type @code{int32}.

@node Arrays
@section Arrays

Arrays types are denoted using the following syntax:

@example
@var{type}[]
@end example

Where @var{type} is the type of the elements contained in the
array.

Examples:

@example
int32[]
uint64[]
string[]
char[]
@end example

The elements contained in an array can be arrays themselves.  This is
how you would declare a type of such an array:

@example
int[][]
@end example

Note that, unlike in many other programming languages, no boundaries
are expressed in the array type definitions.  This is because in poke
the actual size of an array is not part of its type.  This means that,
for example, an array containing four 32-bit integers has the same
type than an array containing four hundred 32-bit integers:
@code{int[]}.

Array literals are constructed using the following syntax:

@example
[<exp>, <exp>, ..., <exp>]
@end example

Where @code{<exp>} is an arbitrary expression.

For example, @code{[1,2,3]} constructs an array of type
@code{int32[]} containing three elements.  Likewise,
@code{['a','b','c']} constructs an array of type @code{char[]}
containing three elements.

The type of the array literal is inferred from the type of its
elements.  Accordingly, all the elements in an array literal must be
of the same type.  Examples of invalid array literals, that will raise
an error if evaluated, are:

@example
[1,2u,3]
[1,0xffff_ffff,3]
['a',"b",'c']
@end example

Arrays must contain at least one element.  Accordingly, @code{[]} is
not a valid array literal.

This is how a @code{3x3} matrix could be constructed using an array of
arrays:

@example
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
@end example

It is possible to refer to specific elements when constructing array
literals.  For example, @code{[1, 2, 3, .[3] = 4]} denotes the same
array than @code{[1, 2, 3, 4]}.

This allows creating arrays without having to specify all its
elements.  Unspecified elements have the value @code{null}.  For
example, @code{[.[2] = 2]} denotes the same array than @code{[null,
null, 20]}.

Note that an array element should only be referred once.  Accordingly,
@code{[1, 2, 3, .[1] = 10]} is not a valid array literal.

@subsection Strings

Arrays of ASCII codes can be denoted using an alternative literal
notation that is useful when working with ASCII null-terminated
strings:

@example
"foo"
@end example

The above string is of type @code{char[]} or @code{string}, and is
equivalent to:

@example
[0x66, 0x6f, 0x6f, null]
@end example

or to:

@example
[0x66, 0x6f, 0x6f, 0x0]
@end example

Note that the empty string @code{""} corresponds to the array
@code{[0x0]}, which is a valid array containing at least one
element.

The following escape sequences are supported inside string literals:

@table @code
@item \DDD
Where @var{ddd} is a one to three digits octal number.  The escape
sequence denotes the ASCII character having that code.  It must be in
the range @code{0-255}.  For example @code{\000} denotes the ASCII
@code{NULL} character.
@item \xHH
Where @var{hh} is a one to two digits hexadecimal number.  The escape
sequence denotes the ASCII character having that code.  For example
@code{\x38} denotes the @code{8} character.
@item \"
Denotes a double quote.
@item \n
Denotes a new line character.
@item \t
Denotes an horizontal tab.
@end table

@node Tuples
@section Tuples

Tuples are collections of heterogeneous values.

@subsection Tuple Types

A tuple type is
denoted using the following syntax:

@example
(<type> [<name>][,<type> [<name>]]...)
@end example

Where @code{<type>} is any type or @code{<null>}.

The type of a tuple containing three 32-bit signed integers is
@code{(int64, int64, int64)}.  Similarly, the type of a tuple
containing a string, an unsigned 8-bit number, and a character is
@code{(string, byte, char)}.

The order of the tuple elements is significant.  For example, the
tuple type @code{(int,long)} is different than the tuple type
@code{(long,int)}.

The type of an empty tuple, i.e. a tuple with no elements, is
@code{(null)}.

It is possible to name some (or all) of the tuple constituents.  For
example, if we wanted to define a tuple to store information about a
person, we could do it like @code{(int age, string name)}.  The
element names are significant, i.e. the tuple type @code{(int foo, int
bar)} denotes a different type than @code{(int baz, int quux)}.

@subsection Tuple Literals

Tuple literals are constructed using the following syntax:

@example
@{[[[.<name> =] <exp>][,[.<name> = ] <exp>]...]@}
@end example

Where @code{<exp>} are arbitrary expressions.  For example, a tuple
containing three signed 32-bit integers can be constructed as
@code{@{10, 20, 30@}} and it is of type @code{(int,int,int)}.
Similarly, @code{@{age, name@}} would construct a type
@code{int,string)} provided @code{age} and @code{string} are variable
holding values of the appropriate type.

For example:

@example
@{10, "foo", 'x'@}
@end example

An empty tuple literal is denoted by @code{@{@}}.

Casts can be used to change the type of a tuple.  The tuple
@code{@{10, 20@}} is of type @code{(int32,int32)}, but
@code{(int32,int64) @{10, 20@}} turns the second element into a 64-bit
signed integer.

It is possible to specify named elements in a tuple literal, like in
@code{@{.age = 37, .name = "Jose"@}}.  The tuple constructed this way
has type @code{(int age, string name)}, i.e. the ordering of the named
members follows their appearance in the literal.

@subsection Casting Tuples

Casts to tuples use the usual syntax @code{(<type>) <exp>} and can be
applied to tuple values.

However, when casting to tuple types featuring more than one element,
an alternative syntax can be used: @code{(int,long) <exp>} is
equivalent to @code{((int,long)) <exp>}.  This abbreviated form can't
be used to cast to tuples having one element, because it is
indistinguishable to casts to other types.  For example @code{(int)
<exp>} is a cast to type @code{int}, not to type @code{(int)}.

Casts can be used to ``augment'' a tuple.  For example
@code{(int,long,long)@{10,20@}} is augmented to the tuple
@code{@{10,20,null@}}.

Casts can be used to ``reorder'' the named elements in a tuple
literal.  For example, @code{(string name, int age) @{.age = 30, .name
= "Jose"@}} generates the tuple @code{@{"Jose", 30@}} of type
@code{(string name, int age)}.

@subsection Accessing Tuples

Tuple elements can be accessed using subscripts, pretty much like
they are used in arrays. @code{@{10, "foo", 'x'@}[0]} evaluates to
@code{10}, @code{@{10, "foo", 'x'@}[2]} evaluates to @code{'x'} and
@code{@{10, "foo", 'x'@}[3]} evaluates to @code{null}.

The number of elements of a tuple are obtained with the @code{sizeof}
operator.

@subsection Building Tuples

@c structuring operator.
@c destructuring operator.

@subsection Destructuring Tuples

Tuples can be destructured using @code{let}:

@example
let (number, name, character) = @{10, "foo", 'x'@}
@end example

XXX: no, dont like this.

@node Type Conversions
@section Type Conversions

XXX: automatic type conversions?

@node Expressions
@chapter Expressions

PCL supports expressions in a very similar way than other programming
languages.

@menu
* Arithmetic Operators::	Operating with numbers.
* Logical Operators::		Building predicates.
* Relational Operators::	Equality and ordering.
* Bitwise Operators::		Working with bits.
* Operators on Arrays::		Operating on arrays.
* Conditional Operator::	if-then-else.
* The Comma Operator::	        Sequencing expressions.
* The Cast Operator::		Changing the type of a value.
* Other Operators::		Stuff that is explained elsewhere.
* Operators Precedence::	What gets executed first.
* Parenthesized Expressions::	Grouping and changing precedence.
@end menu

@node Arithmetic Operators
@section Arithmetic Operators

The following left-associative binary arithmetic operators are
supported, in descending precedence order:

@itemize
@item Multiplication @code{*}, integer division @code{/} and modulus
      @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@end itemize

The following right-associative unary arithmetic operators are
supported:

@itemize
@item Unary minus @code{-} and unary plus @code{+}.
@end itemize

The arithmetic operators are defined on integer and character values.
Attempting to use them on another kind of value results on a run-time
error.

@node Logical Operators
@section Logical Operators

The following left-associative, short-circuited binary logical
operators are supported, in descending precedence order:

@itemize
@item Logical AND @code{&&}.
@item Inclusive OR: @code{||}.
@end itemize

The following right-associative unary logical operators are supported:

@itemize
@item Logical negation @code{!}.
@end itemize

@node Relational Operators
@section Relational Operators

The following binary relational operators are supported, in descending
precedence order:

@itemize
@item Equality @code{==} and inequality @code{!=}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=}.
@end itemize

When applied to integer and character values, these operators
implement an arithmetic ordering.  When applied to strings, these
operators implement a lexicographic ordering.

Only equality and inequality can be applied to arrays, structs and
unions.

These operators resolve in boolean values encoded as 32-bit integers:
@code{0} meaning false and @code{1} meaning true.

@node Bitwise Operators
@section Bitwise Operators

The following left-associative bitwise binary operators are supported,
in descending precedence order:

@itemize
@item Bitwise shift left @code{<<} and bitwise shift right @code{>>}.
@item Bitwise AND @code{&}.
@item Bitwise exclusive OR @code{^}.
@item Bitwise inclusive OR @code{|}.
@end itemize

The following right-associative unary bitwise operators are supported:

@itemize
@item Bitwise complement @code{~}.
@end itemize

Bitwise operators can be applied to integer values, with the expected
semantics.

@node Operators on Arrays
@section Operators on Arrays

@subsection Concatenation

The elements of two arrays can be concatenated using the
left-associative binary operator @code{+}.  For example:

@example
@{1, 2, 3@} + @{4, 5, 6@}
@end example

evaluates to @code{@{1, 2, 3, 4, 5, 6@}}

The operator can also be applied to an array and a value of the same
type than the elements of the array.  This is called a @dfn{cons}, and
it is very useful to build arrays recursively.  For example:

@example
@{1, 2, 3@} + 4
@end example

evaluates to @code{@{1, 2, 3, 4@}}.

Note that the semantics of this operator vary a bit when applied to
arrays of ASCII codes, also known as strings.  In this case, the
@code{NULL} ASCII character finishing the first array is not included
in the concatenated value.  Thus the operation:

@example
@{'a', 'b', 0x0@} + @{'c', 'd', 0x0@}
@end example

evaluates to @code{@{'a', 'b', 'c', 'd', 0x0@}}.  Or, using string
notation:

@example
"ab" + "cd"
@end example

evaluates to @code{"abcd"}.

Likewise, the semantics of the cons operator also vary with arrays of
@code{char}:

@example
@{'f', 'o', 0x0@} + 'o'
@end example

evaluates to @code{@{'f', 'o', 'o', 0x0@}}.  Or, using string
notation:

@example
"fo" + 'o'
@end example

evaluates to @code{"foo"}.

@subsection Indexing

The elements of an array can be referred to using the left-associative
unary operator @code{[@var{idx}]}, where @var{idx} is a positive
integer.

For example, the operation @code{@{1, 2, 3@}[0]} evaluates to
@code{1}, while @code{@{1, 2, 3@}[2]} evaluates to @code{2}.

If the index refers past to the last element contained in the array,
then the operation evaluates to @code{null}, i.e. @code{@{1, 2,
3@}[4]} evaluates to @code{null}.

Negative indexes are not allowed and an error is raised if they are
used.

@c XXX: play with the idea of negative indexes?  Some formats may
@c store information before pointers, like ghostscript's memory
@c allocators do.

The indexing operator can also be used to refer to a region of the
array, using a range of indexes @code{[@var{idx1}:@var{idx2}]}.  The
denoted range is @code{[@var{idx1},@var{idx2}]}, i.e. the elements in
both positions are included in the range.  Note that @var{idx1} should
be less or equal than @var{idx2}, or an error is raised.

For example, the operation @code{@{1, 2, 3@}[0:1]} evaluates to
@code{@{1,2@}} and the operation @code{@{1, 2, 3@}[2:3]} evaluates
to @code{@{2,3@}}.

If @var{idx1} equals to @var{idx2}, the result of the operation is an
array of one element.  Thus, @code{@{1, 2, 3@}[1:1]} evaluates to
@code{@{2@}} whereas @code{@{1, 2, 3@}[1]} evaluates to @code{2}.  The
indexation of an array with a range always evaluates to an array.

If the range includes indexes past the end of the array, @code{null}
values are used accordingly.  For example, the operation @code{@{1, 2,
3@}[1:3]} evaluates to @code{@{2, 3, null@}}.

Note that indexing an array range does not create a copy of the
elements.  Instead, both the operand array and the array resulting
from the operation refer to the same instance of the elements.  The
importance of this will become apparent when we talk about variables
later in this manual.

@node Conditional Operator
@section Conditional Operator

The following right-associative ternary conditional operators are
supported:

@itemize
@item Conditional operator @code{? :}.
@end itemize

The conditional operator can be applied to integer and character
values.

@node The Comma Operator
@section The Comma Operator

The comma operator @code{,} is a left-associative operator that
evaluates its operands and returns the value of the rightmost
operand.  It is used to separate expressions.

@node The Cast Operator
@section The Cast Operator

The right-associative unary operator cast @code{(type)} can be used to
derive a new value having a different type from an existing value.

Casts between integer types are always allowed.  If the new type is
narrower than the existing type, truncation may be performed to
accommodate the value in its new type.  For example, the expression
@code{(uint8) 0x8765_4321} evaluates to @code{0x4321}.  If the new type
is wider than the existing type, either zero-extension or
sign-extension is performed depending on the signedness of the
operand.

The semantics of the sign-extension operation depends on the currently
selected negative representation encoding in @code{.nencoding}. @c
XXX: xref to section documenting @code{.nencoding}.

For example, in two's complement the expression @code{(uint16) 0xffff}
evaluates to @code{0x0000_ffff}.  However, @code{(int16)0xffff}
evaluates to @code{0xffff_ffff} in two's complement, and it evaluates
to @code{0xffff_0000} in one's complement.

Casts are also used in order to construct struct, union, enumerated
and bitmask values, as it is explained later in this manual. @c XXX:
@c xref to section documenting it.

@node Other Operators
@section Other Operators

Other operators, whose meaning and purpose is explained in full later
in this manual, are summarized here.

Left-associative unary operators:

@itemize
@item Member selection operator @code{.}.
@end itemize

Right-associative unary operators:

@itemize
@item @code{sizeof}, @code{startof} and @code{typeof}
@end itemize

@node Operators Precedence
@section Operators Precedence

The following table summarizes the precedence and the associativity of
all the operators described above, in descending order:

@table @code
@item Array subscript operator @code{[ ]}.
@item Member selection operator @code{.}.
@item Postfix increment @code{++} and postfix decrement @code{--}.
@item Prefix increment @code{++} and prefix decrement @code{--}.
@item Unary minus @code{-} and unary plus @code{+}.
@item Logical negation @code{!} and bitwise complement @code{~}.
@item Cast @code{(type)}.
@item @code{sizeof}, @code{startof} and @code{typeof}.
@item Array concatenation @code{+}.
@item Multiplication @code{*}, integer division @code{/} and modulus
      @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@item Bitwise shift left @code{<<} and bitwise shift right @code{>>}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=},
@item Equality @code{==} and inequality @code{!=}.
@item Bitwise AND @code{&}.
@item Bitwise exclusive OR @code{^}.
@item Bitwise inclusive OR @code{|}.
@item Logical AND @code{&&}.
@item Inclusive OR: @code{||}.
@item Ternary conditional operator @code{? :}.
@item Comma operator @code{,}.
@end table

@node Parenthesized Expressions
@section Parenthesized Expressions

Parentheses can be used in order to change the precedence of
sub-expressions, the usual way.

@node Constants
@chapter Constants

Constants are named values that don't change during the lifetime of a
poke program.

The definition of a constant uses the following syntax:

@example
const [@var{type}] @var{name} = @var{const_exp}
      (,[@var{type}] @var{name} = @var{const_exp})*;
@end example

This declares a set of constants with the given @var{name}s having the
value of the corresponding @var{const_exp}.  The expressions must be
constant, i.e. it should be possible to compute their values at
compile-time.

If a @var{type} is specified in a constant definition then the value
computed by the assignment expression must be of the same type, or an
error is raised.  Otherwise the type of the constant is the type of
the value computed by the expression.

Examples:

@example
const limit = 256;
const balance = 23U;
const offset = (uint64) 256;
const uint64 offset = 256;
const section_name = ".text";
const x = 'x', y = 'y';
@end example

@node Variables
@chapter Variables

Variables are the association between a symbol and a value.  They are
declared using the @code{let} construction:

@example
let [<type>] <name> [= <exp>]
    (,[<type>] <name> [= <exp>)*;
@end example

Where @code{<name>} is a literal with the form
@code{[a-zA-Z_][a-zA-Z0-9_]*}.

The variable can be initialized with a value, which is the result of
computing the expression @code{<exp>}.  If no initial value is
provided then it is @code{null}.

Generally a variable can hold values of different types during its
life time.  However, if @code{<type>} is specified in a variable
declaration then only values of that type are allowed to be stored in
the variable.

It is important to note that poke variables are not stored in
addressable memory; and if they are, that is none of the business of
the poke programmer!

@section Variables Lifetime

Variables exist until the execution flow exits the scope where they
are declared:

@itemize
@item Variables declared in the top-level exist until poke exists.
@item Variables declared in the body of a function exist until the
      function exits.
@item Variables declared in the body of a struct or an union exist
      until the execution flow exits the struct or union.
@end itemize

@section Variables Scope

A variable is accessible in the lexical scope where they are declared,
and in the lexical scopes nested in the lexical scope where they are
declared.

For example, this is an error:

@example
@{
  let i;
@}

i = 30;
@end example

But this is not:

@example
@{
  let i;

  @{
    i = 30;
  @}
@}
@end example

Note that variables defined in inner scopes ghost variables with the
same symbol defined in an outer scope.

@node Statements
@chapter Statements

Statements are the basic execution units of poke programs.  Executing
a program means executing its statements one by one.  Their main
purpose is to perform some side-effect.

@menu
* Assignments::			Setting the value of a variable.
* Statement Blocks::		Sequences of statements.
* If::				Simple conditional.
* Switch::			Multiple conditional.
* While::			Iterating while some condition is met.
* For::				Iterating on indexes.
* For-in::			Iterating on arrays.
* Continue::			Jumping to the next iteration.
* Break::			Escaping a loop or a switch.
* Function Calls::		Calling a subroutine.
@end menu

@node Assignments
@section Assignments

The assignment statement stores a value in a variable.  It's syntax
is:

@example
<variable> = <exp>;
@end example

Where @code{<variable>} is the name of the variable and @code{<exp>}
is an expression.  The value computed by the expression can be of any
type, unless the variable is declared with a fixed type.

The value previously stored in the variable is lost, unless there are
other references to it. (This can happen with arrays, structs and
unions.)

There are several variants of the assignment statement that are
provided to shorten common idioms:

@example
<variable> <op>= <exp>;
@end example

which is equivalent to:

@example
<variable> = <variable> <op> <exp>;
@end example

Valid @code{<op>}s are addition @code{+}, subtraction @code{-},
multiplication @code{*}, integer division @code{/}, modulus @code{%},
bit-wise AND @code{&}, bit-wise exclusive OR @code{^}, bit-wise
inclusive OR @code{|}, bit-wise shift left @code{<<} and bit-wise
shift right @code{>>}.  @c xref to operators chapter.

@node Statement Blocks
@section Statement Blocks

Statements that are to be executed sequentially can be grouped in
@dfn{blocks} using curly brackets:

@example
@{
  <stmt>
  <stmt>
  ...
  <stmt>
@}
@end example

Syntactically a block is equivalent to a single statement.  This means
that in every place where a statement is valid, a block is also valid.

Statement blocks introduce a new lexical scope.

@node If
@section If

The @code{if} statement has the following form:

@example
if (<exp>) <then_stmt> [else <else_stmt>]
@end example

The expression @code{<exp>} is evaluated.  If it evaluates to
@code{true} then @code{<then_stmt>} is executed.  If
@code{<else_stmt>} is specified and @code{<exp>} evaluates to either
@code{false} or @code{null} then @code{<else_stmt>} is executed
instead.

@node Switch
@section Switch

The @code{switch} statement looks like:

@example
switch (<exp>)
@{
   case <exp>:
   <stmt>
   ...
   <stmt>
   case <exp>:
   <stmt>
   ...
   <stmt>
   ...
   default:
   <stmt>
@}
@end example

The expression @code{<exp>} is evaluated and the case expressions are
evaluated in order.  Whenever the value of a ase expression matches
the value of @code{<exp>}, the statements following it are executed.
More than one case may be entered.  The statements following
@code{default:} are always executed if the control flow reaches there.

If the special statement @code{break} is found, the control flow jumps
to the end of the switch statement.

@node While
@section While

@code{while} statements have the form:

@example
while (<exp>) <stmt>
@end example

@code{do-while} statements have the form:

@example
do <stmt> while (<exp>);
@end example

@code{for} statements have the form:

@node For
@section For

@example
for ([<exp>];[<exp>];[<exp>]) <stmt>
@end example

@node For-in
@section For-in

@code {for} statements have the form:

@example
for ([variable] in <exp>) <stmt>
@end example

@node Continue
@section Continue

The @code{continue} statement makes the control flow to jump to the
beginning of the nearest loop instruction.  If no such loop
instruction is found an error is raised.

@node Break
@section Break

The @code{break} statement makes the control flow to exit the nearest
containing loop or switch statement.

@node Function Calls
@section Function Calls

Functions are called:

@example
<name> ((<arg>[,<arg>])*);
@end example

Where @code{<name>} is the name of a defined function.  When called as
a statement, a warning is issued if a function returns anything but
@code{null}, because in that case the return value is discarded.

It is possible to name specific function arguments in a function call:

@example
printf (fmt = "this is %d", number);
@end example

@node Functions
@chapter Functions

Functions are defined using the following syntax:

@example
function <name> ((<arg> [,<arg>]*)*) [<return_type>]
@{
  <function_body>
@}
@end example

Function arguments follow the following syntax:

@example
[<type>] <name> [= <exp>]
@end example

Where @code{<name>} is the name of the argument.  If a @code{<type>}
is indicated, the value in the argument must be of that type.

The body of a function introduces a new lexical scope.

A @code{return} statement with the form:

@example
return [<value>];
@end example

may be used to return a value for the function.  If the function
doesn't return any value, it returns @code{null}.

A function can be defined at top-level scope, or inside a lexical
scope.  This included another functions.  This is useful to write
auxiliary functions without polluting the global name space (Poke is a
truly block-oriented language.)

@section Optional Arguments

If an assignment operator and an expression is included, then the
argument is optional and has the value of @code{<exp>} should it not
be specified in a function call.

@section Variadic Functions

If the last argument of a function is initialized to an empty tuple,
then it will contain any extra argument.

@example
function printf (string fmt, args = @{@})
@{
   let i;
   for (i = 0; i < sizeof (args); i++)
   @{
      /* Process argument.  */
   @}
@}
@end example

@section Recursive Functions

Functions can be recursive, both directly and indirectly.  For
example, this is a factorial implementation in poke:

@example
function factorial (n)
@{
  if (n == 0)
     return 1;
  else
     return n * factorial (n - 1);
@}
@end example

GNU poke supports tail-recursion.  This means that if a recursive
function is written in certain way, it is equivalent to iteration with
no memory allocated in each iteration.  This is important, since it
allows writing recursive functions operating on large structures in IO
space.

@node Mapped Variables
@chapter Mapped Variables

The idea is that the same poke code will execute on mapped and
non-mapped variables, with no changes.

@section Endianness and Negative Encoding

The encoding of a mapped variable depends on its value, its type, the
current endianness and the current negative encoding method.

The current endianness is determined by the value of the special
variable @code{.endian}.  If @code{.endian == msb} then the encoding is
big-endian.  If @code{.endian == lsb} then the encoding is
little-endian.  The default endianness is determined by the endianness
used by the machine where GNU poke is running.

The current negative encoding method is determined by the value of the
special variable @code{.nencoding}.  If @code{.nencoding == 1} the
negative quantities in integer values are encoded using one's
complement.  If @code{.nencoding == 2} then they are encoded using
two's complement.  The default is @code{2}.

@section Encoding

Integer values are de/encoded as follows:

@itemize
@item @code{char}, @code{byte}, @code{uint8} values are encoded as 8-bit
      unsigned stored values.  Nulls of this type are encoded to
      @code{0x00}.
@item @code{uint16}, @code{uint32} and @code{uint64} values map to
      16-bit, 32-bit and 64-bit unsigned stored values, respectively,
      with endianness @code{.endian}.  Nulls of this type are encoded
      to @code{0x0000}, @code{0x0000_0000} and
      @code{0x0000_0000_0000_0000} respectively.
@item @code{int8} maps to a 8-bit signed stored values with negative
      encoding @code{.nencoding}.  Nulls of this type are encoded to
      @code{0x00}.
@item @code{short}, @code{int16}, @code{int},
      @code{int32}, @code{long} and @code{int64} values map to 16-bit,
      16-bit, 32-bit, 32-bit, 64-bit and 64-bit signed stored values,
      respectively, with negative encoding @code{.nencoding} and
      endianness @code{.endian}.  Nulls of this type are encoded to
      @code{0x0000}, @code{0x0000_0000} and
      @code{0x0000_0000_0000_0000} respectively.
@end itemize

@node Enumerations
@chapter Enumerations

Enumerations are collections of related constants.  They use the
following syntax:

@example
enum @var{type} @var{tag}
@{
   @var{enumerator1} [= @var{value1}],
   @var{enumerator2} [= @var{value2}],
   ...
   @var{enumeratorN} [= @var{valueN}][,]
@}
@end example

Where:

@table @var
@item type
Is the base type of the enumeration.  It should be an integer type.
@item tag
Is the name of the enumeration.  It should be unique in the global
scope.
@item enumeratorN
Are the names of the enumerators.
@item valueN
Are initialization values.  They should be expressions evaluating to
constant values valid for @var{type}.

If an explicit initialization value is not specified for an
enumerator, an implicit value is used.  The implicit value is
initially @code{0}, and increased by one every time it is used.
@end table

An enumeration  must contain at least one enumerator.

Enumerations do not provide its own lexical scope.  The enumerators
should be unique in the global scope.  It is highly recommended to use
prefixes to avoid conflicts.

@node Bitmasks
@chapter Bitmasks

@example
bitmask elf_xword elf_sh_flags
@{
  /** Section contains data that should be writable during process
      execution.  */
  SHF_WRITE = 0x1,

  /** Section occupies memory during process execution.  */
  SHF_ALLOC = 0x2,

  /** Section contains executable machine instructions.  */
  SHF_EXECINSTR = 0x4,
@}
@end example

@node Structs and Unions
@chapter Structs and Unions

Structs are programs whose execution generate tuple types.

   - Structs and unions: programs that generate tuple types with sophisticated
     physical layouts that can't be expressed using tuple notation.


A tuple can be casted into a tuple type generated by a struct, using
the rules documented above in Tuples, using the following syntax:

@example
(struct foo) @{10, "name"@}
@end example

A struct defines the layout of an area in IO space.  They are defined
as follows:

@example
struct @var{tag} [@var{qualifiers}]
@{
  @var{field1};
  @var{field2};
  ...
  @var{fieldN};
@};
@end example

where @var{field1}..@var{fieldN} are the definitions of fields.  It is
legal to have an empty struct, i.e. with no field defined.

@var{qualifiers} is a list of optional qualifiers for the struct
contents:

@table @code
@item lsb
The default endianness of the struct contents is little-endian.
@item msb
The default endianness of the struct contents is big-endian.
@end table

Each field is defined as follows:

@example
[@var{label}:] [@var{qualifiers}] @var{type} @var{field}[: @var{constraint}];
@end example

where @var{label} is an optional offset relative to the beginning of
the struct.  The field is located @var{label} bytes in the struct.

@var{qualifiers} is a list of optional qualifiers for the field:

@table @code
@item lsb
The contents of the field are stored in little-endian.
@item msb
The contents of the field are stored in big-endian.
@end table

@var{type} is the type of the field.  @var{field} is the name of the
field, which must be unique in the containing struct.

@node Poke Architecture
@chapter Poke Architecture

PKL stands for ``Poke Language''.  It is pronounced ``pickle''.

@verbatim

      +----------+
      | compiler |
      +----------+
           |
           v
      +----------+      +-------+
      |   PVM    | <--->|       |
      +----------+      |       |
           ^            |       |
           |            | data  |
           v            |       |
      +----------+      |       |
      | command  | <--->|       |
      +----------+      +-------+

@end verbatim

Files:

@table @file
@item pkl.h
PKL compiler header file.
@item pkl-ast.h pkl-ast.c
PKL abstract syntax tree.
@item pkl-gen.c
PKL code generator.
@item pkl-lex.l pkl-lex.y
PKL parser and lexer.
@item pvm.h pvm.c
Poke virtual machine.
@end table

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi


@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
