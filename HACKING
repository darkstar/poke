========================
GNU Poke - Hacking Notes
========================

Welcome, adventurous poker! This file contains useful information for
you.

Copyright (C) 2019 Jose E. Marchesi

This file is part of GNU poke.

GNU poke is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU poke is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU poke.  If not, see <https://www.gnu.org/licenses/>.


..  Please be as good as to update the table of contents below if you
    modify the sectioning of the document.  If in Emacs,
    M-xrst-toc-update should take care of it automatically.

.. contents:: 
..
     1  Nomenclature
     2  Development Environment
       2.1  Autotools
       2.2  Flex
       2.3  readline
       2.4  Jitter
       2.5  Building
       2.6  Gettext
       2.7  Running an Uninstalled Poke
     3  Coding Style and Conventions
       3.1  Writing C
       3.2  Writing Poke
     4  Deciding on What to Work on
     5  Submitting a Patch
     6  Maintenance
     7  Poke Architecture
     8  The Poke Compiler
       8.1  Compiler Overview
       8.2  The bison Parser in pkl-tab.y
       8.3  The AST
       8.4  Compiler Passes and Phases
         8.4.1  Naming Conventions for Phases
         8.4.2  Naming Conventions for Handlers
         8.4.3  Transformation Phases
         8.4.4  Analysis Phases
         8.4.5  Type System Phases
       8.5  The Type System
         8.5.1  Type Expressions
       8.6  Adding Compiler Built-Ins
     9  The Poke Virtual Machine
       9.1  Exception Handling
       9.2  Offsets and bit-offsets in the PVM
    10  Memory Management
      10.1  Using ASTREF
      10.2  Using ASTDEREF
      10.3  PVM values in PVM programs
      10.4  PVM values in AST nodes
    11  Debugging Poke
      11.1  Building with Debugging support
      11.2  Using GDB extensions
      11.3  Valgrind and Poke
      11.4  Debugging PVM Assembly Code
    12  Future Developments
    13  Appendix: The Source Tree
      13.1  The Compiler
      13.2  The Poke Virtual Machine
      13.3  The IO Subsystem
      13.4  Poke Program
      13.5  Pickles and Libraries
      13.6  Test Suite
      13.7  Documentation
      13.8  Other Stuff


Nomenclature
------------

We call ``poke`` the program.  When the context may induce confusion
(since ``poke`` is a pretty common word) then we use ``GNU poke``.

``Poke`` (with upper case ``P``) is the name of the domain-specific
language implemented by ``poke``.

A ``pickle`` is a Poke source file containing definitions of types,
variables, functions, etc, that conceptually apply to some definite
domain.  For example, ``elf.pk`` is a pickle that provides facilities
to poke ELF object files.  Pickles are not necessarily related to file
formats: a set of functions to work with bit patterns, for example,
could be implemented in a pickle ``bitpatterns.pk``.

Development Environment
-----------------------

Autotools
~~~~~~~~~

This distribution uses whatever versions of Automake, Autoconf, and
Gettext are listed in NEWS; usually the latest ones released.  If you
are getting the sources from git (or change configure.ac), you'll need
to have these tools installed to (re)build.  You'll also need
help2man.  All of these programs are available from
ftp://ftp.gnu.org/gnu.

Flex
~~~~

You will need a recent version of flex, since we are using some recent
options like "reentrant" or "bison-bridge".  flex version 2.6.1 works
fine.

readline
~~~~~~~~

Poke uses libreadline in order to provide a nice line editor in the
``(poke)`` prompt.  The ideal version of use is GNU readline.  Any
recent version will suffice.

However, in case you don't have libreadline installed, a minimum
version from gnulib is used instead.

Jitter
~~~~~~

In order to build and run poke, you need Luca Saiu's jitter.  Jitter
is available in http://ageinghacker.net/git/cgit.cgi/jitter.  The
specific revision you need is
745ba29c15dd56c60a7ab0320e09c1ca705018b7.

Configure and install jitter in some prefix.  When configuring poke,
specify the location of the jitter installation with --with-jitter.

For the time being, you should also use when configuring jitter::

  --disable-dispatch-minimal-threading --disable-dispatch-no-threading

or, alternatively, use ``--enable-debug`` when configuring poke.

Building
~~~~~~~~

After getting the git sources, and installing the tools above, you can
run::
  
  $ ./bootstrap --skip-po

Then, you can run ``configure``::

  $ mkdir build/ && cd build
  $ ../configure --with-jitter=PATH_TO_JITTER_INSTALL OTHER_OPTIONS...

Note that, for now, it is necessary to specify ``--with-jitter`` even
if Jitter is installed in a standard location.
  
Finally::

  $ make
  $ make check

Gettext
~~~~~~~

When updating gettext, besides the normal installation on the system,
it is necessary to run gettextize -f in this hierarchy to update the
po/ infrastructure.  After doing so, rerun gnulib-tool --import since
otherwise older files will have been imported.  See the Gnulib manual
for more information.

Running an Uninstalled Poke
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once poke is compiled, you can run it before installing by defining
the ``POKEDATADIR`` environment variable to point to the ``src/``
directory in the sources tree.  For example::

  $ pwd
  /home/jemarch/gnu/hacks/poke/build/
  $ export POKEDATADIR=../src
  $ ./src/poke

Coding Style and Conventions
----------------------------

Writing C
~~~~~~~~~

In Poke we follow the GNU Coding Standards.  Please see
http://www.gnu.org/prep/standards/.

Writing Poke
~~~~~~~~~~~~

- Do not separate magnitudes and units when writing offsets.  Do it
  like this::

    16#B

  instead of::

    16 #B

- Use CamelCase for type names, but do not use CamelCase for
  variable/function names!

Deciding on What to Work on
---------------------------

We maintain a detailed task list in the ``TODO`` file at the root of
the source tree.  Please take a look.
    
Submitting a Patch
------------------

If you hack a feature/improvement/bugfix for poke and want to get it
integrated upstream, please keep the following points in mind:

- If your patch changes the user-visible characteristics of poke,
  please include an update for the user manual.

- If your patch adds or changes the way poke works internally, in a
  significant way, please consider including an update for the
  ``HACKING`` file.

- Please include a GNU-style ChangeLog in the patch description, but
  do not include it in the thunks.  This is to ease reviewers to apply
  your patch for testing.  Of course, include the thunk in the final
  push!  (We will get rid of manually ChangeLog entries soon.)

- Make sure to run ``make syntax-check`` before submitting the patch,
  and fix any reported problem.  Note that the maintainer reviewing
  your patch will also do this, so this is a great time to save an
  iteration ;)

- Let's keep poke.git master linear... no merges please.  Pull with
  ``--ff-only``.

- Send the patch to the ``poke-devel`` mailing list.

- Use text email only.  No html please.

- Inline the patch in the body of your email, or alternatively attach
  it as ``text/x-diff`` or ``text/x-patch``.  This is to ease
  reviewers to quote parts of the patch.
    
Maintenance
-----------

This section describes ``make`` targets that performs several
maintenance tasks.

syntax-check
  Run several syntax-related checks in the source files.  It is useful
  to run this target before submitting code to be reviewed, and while
  reviewing other people's code.

  Note that sometimes the results have to be taken with a pinch of
  salt.  This happens, for example, when a rule oriented to C is
  applied to, say, an AWK file.  In these cases, consider adding a
  ``.x-sc_*`` fine-tuning file.  But please ask in poke-devel first.

coverage
  This target builds *poke* with code coverage support, runs the
  testsuite, and generates a nice html report under
  ``$(top_builddir)/doc/coverage/``.  It is necessary to have the
  ``lcov`` program for this to work.

refresh-po
  This target download the latest available translations from the
  translationproject and installs them in the source tree.

update-copyright
  Run this rule once per year (usually early in January) to update all
  the copyright years in the project.  By default this excludes all
  variants of COPYING.  Exceptions to this procedure (such as
  ``ChangeLog..*`` for rotated change logs) can be added in the file
  ``.x-update-copyright``.

Poke Architecture
-----------------

This figure depicts the overall architecture of Poke::
  
  +----------+
  | compiler |      
  +----------+      +------+
       |            |      |
       v            |      |
  +----------+      |      |
  |   PVM    | <--->|  IO  |
  +----------+      |      |
       ^            |      |
       |            |      |
       v            +------+
  +----------+
  | command  |
  +----------+

The Poke Compiler
-----------------

Compiler Overview
~~~~~~~~~~~~~~~~~

This figure depicts the architecutre of the compiler::
  
      /--------\
      | source |
      \---+----/
          |
          v
  +-----------------+
  |      Parser     |
  +-----------------+
  |  analysis and   |
  | transformation  |
  |     phases      |
  +-----------------+    
  | code generation |
  |      phase      |
  +-----------------+
  | Macro assembler |
  +-----------------+
          |
          v
     /---------\
     | program |
     \---------/

The bison Parser in pkl-tab.y
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The only purpose of the bison parser in pkl-tab.y is to do the
syntactic analysis, build the initial AST, and set the locations of
the AST nodes.

Unfortunately, currently it also does some extra work, due to
limitations in the LARL parser:

- It builds the compile-time environment and register type, variable
  and function declarations.
- It annotates variables with their lexical addresses.
- It links return statements with their containing functions.
- It annotates return statements with he number of lexical frames they
  should pop before exitting the function.

As we shall see below, any further analysis and transformations on the
AST are performed by the compiler phases, which are implemented
elsewhere.  This greatly helps to keep the parser code clean and easy
to read, and also eases changing the syntactic structure of poke
programs.

The AST
~~~~~~~

Compiler Passes and Phases
~~~~~~~~~~~~~~~~~~~~~~~~~~

These are the phases currently implemented in the poke compiler (the
phases marked with a * are optional)::

    [parser]
    --- Front-end pass
    trans1     Transformation phase 1.
    anal1      Analysis phase 1.
    typify1    Type analysis and transformation 1.
    promo      Operand promotion phase.
    trans2     Transformation phase 2.
  * fold       Constant folding.
    typify2    Type analysis and transformation 2.
    trans3     Transformation phase 3.
    anal2      Analysis phase 2.
    --- Middle-end pass
    trans4     Transformation phase 4.
    --- Back-end pass
    analf      Analysis final phase.
    gen        Code generation.

The phases above are organized in several passes:

Pass1
  anal1 typify1 promo trans2 fold typify2 trans3 anal2
Pass2
  trans4
Pass3
  analf gen

Naming Conventions for Phases
.............................

We use the following convention to name phases::

  {NAME}{SUFFIX}

where ``NAME`` reflects a phase category (see below) and ``SUFFIX`` is
usually an integer that specifies the order in which the phases are
applied.  Thus, for example, ``name4`` is performed after ``name1``.
Sometimes, ``SUFFIX`` is ``f`` (meaning "final").

The suffix is not used if there is only one phase in the given
category.

We use the following phase categories:

anal
  For phases whose main purpose is to perform checks on the AST,
  and/or the contents of the AST nodes, and emit errors/warnings.

trans
  For phases whose main purpose is to alter the structure of the AST,
  and/or the contents of the AST nodes.

typify
  For phases whose main purpose is to perform type checks, and
  otherwise do work on types.

promo
  For phases whose main purpose is to perform coercions wherever
  appropriate.  Currently there is only one phase in this category.

fold
  For phases whose main purpose is to pre-compute areas of the AST
  whenever it is possible to do so at compile-time.  Currently there
  is only one phase in this category, that performs constant folding.

gen
  For phases whose main purpose is to generate PVM code.  Currently
  there is only one phase in this category.

The phases in category ``NAME`` are implemented in the source files
``src/pkl-NAME.[ch]``.


Naming Conventions for Handlers
...............................

We use the following convention to name phase handlers::

  pkl_PHASE_{ps,pr}_NODE

where ``PHASE`` can be a complete phase name (like ``typify1``) if the
handler is to be installed in that phase only, or a phase category
name (like ``typify``) if the handler is to be installed in several
phases in that category.  If the phase is to be executed in pre-order,
``pr`` follows, otherwise, ``ps``.  Finally, ``NODE`` is the name of
the AST node.

For example, the handler::

  pkl_anal1_ps_comp_stmt

is installed in the phase ``anal1``, executes in post-order, and
serves the AST nodes with code ``PKL_AST_COMP_STMT``.


Transformation Phases
.....................

trans1
  - Finishes strings by expanding \-sequences, emitting diagnostics if
    an invalid \-sequence is found.

trans4
  - Reverses the list of actual arguments in function calls, so the
    code generator tackles them in the right (reversed) order, as it
    is expected by the callee.

Analysis Phases
...............

anal1
  - Checks that every return statement is linked to a function.
  - Checks that no return statement is linked to a void function.

Type System Phases
..................

typify1
  - Checks that the expression in which a funcall is applied is a
    function, and that the types of the formal parameters mach the
    types of the funcall arguments.
  - Checks that void functions are not called in contexts where a
    value is expected.

typify2
  - Checks that the type of the expression in a return statement
    matches the return type of its containing function.


The Type System
~~~~~~~~~~~~~~~

This section describes the type system implemented in the 'poke'
language.

Type Expressions
................

A *type expression* denotes some particular type.  Type expressions
can be one of:

A *simple type*
  Simple types are types that are not composed of other types.  In
  this discussion we use the following sexp-like notations for them:

  (int N)
    Signed integer of N bits, where 0 < N <= 64.
  (uint N)
    Likewise, but the integer is unsigned.
  string
    NULL-terminated C-like string.
  void
    This is the null type.  Used for several purposes.

A *product*
  Products of two type expressions are used to aggregate types in more
  complex structures, such as lists.  We denote them by using the
  following sexp-like notation:

  (T1 . T2)
    product of the type expressions T1 and T2.

  In order to simplify, we use the same list abbreviation used by Lisp
  in order to denote aggregations of types built with products::

    (T1 . (T2 . (T3 . T4))) -> (T1 T2 T3 T4)
  
  Note that type products are not really valid types by themselves.

An *array type*

A *struct type*
  Type expressions for structs are characterized by many attributes.
  We denote these expressions by using the following sexp-like
  notation.

  (struct PINNED ((L1 N1 T1 C1)...))
     where L1 is the label of the first element: a poke expression
     evaluating to an offset.  N1 is the name of the element, which is
     optional.  T1 is a type expression denoting the type of the
     element.  C1 is a poke expression evaluating to a boolean; it is
     the constraint associated to the element.   Of all these
     attributes, only T1 is mandatory.  PINNED is a boolean indicating
     whether structs having this type are pinnned.

A *function type*
  Type expressions for functions are characterized by a type
  expression denoting the types of it's arguments and the type of the
  value returned by the function.  We denote them using the following
  sexp-like notation:

  (fun T1 T2)
    where T1 is the type of the arguments to the function, and T2 is
    the type of the value returned by the function.

  Usually T1 will be an aggregation of types built as nested
  products.  For example, the type expression for a function that
  takes three 32-bit signed integers and returns a string is::

    (fun ((int 32) (int 32) (int 32)) string)

  If a type expression denotes the type of a function which doesn't
  take any argument, T1 should be 'void'.  Likewise, if the function
  doesn't return a value, T2 should be 'void'.

Adding Compiler Built-Ins
~~~~~~~~~~~~~~~~~~~~~~~~~

Compiler built-ins are predefined functions, provided by the compiler,
that generate particular assembler instructions.

The first step in defining a new built-in is to make the lexer to
recognize tokens of the form ``__PKL_BUILTIN_NAME__`` where ``NAME``
is some meaningful name, like for example ``RAND``::

  "__PKL_BUILTIN_RAND__" { return BUILTIN_RAND; }

Then, add a new rule to the rule ``comp_stmt`` in the bison parser.
Built-ins are equivalent to compound statements.  For example, this is
the rule for the rand built-in::

          | pushlevel BUILTIN_RAND
        {
          $$ = pkl_ast_make_builtin (pkl_parser->ast,
                                     PKL_AST_BUILTIN_RAND);
          PKL_AST_LOC ($$) = @$;
          
          /* Pop the frame pushed by the `pushlevel' above.  */
          pkl_parser->env = pkl_env_pop_frame (pkl_parser->env);
        }

Next step is to generate the code for the built-in.  This is done
expanding the ``pkl_gen_ps_comp_stmt`` rule in the code generation.
Keep in mind that the generated code should conform a valid function
body.  For example, this is the code generation part for rand::

          case PKL_AST_BUILTIN_RAND:
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAND);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RETURN);
          break;

The final step is to define the built-in function proper, in the
compiler run-time, in ``pkl-rt.pk``::

  defun rand = int<32>: __PKL_BUILTIN_RAND__;


The Poke Virtual Machine
------------------------

Exception Handling
~~~~~~~~~~~~~~~~~~

Exception types are signed 32-bit integers, and are defined in
``src/pkl-rt.pkl``.

There are two ways an exception can be raised in the PVM:

- Explicitly, when the instruction ``raise`` is executed.
- Implicitly, when some instruction needs to fail.  For example,
  an integer division instruction divides by zero.

In either case, the treatment of a raised exception is the same:

1. Pop an exception handler from the exception handler stack.
2. If the exception handler matches the raised exception type, then
   i. Restore the heights of the main and return stacks.
   ii. Restore the dynamic environment.
   iii. Push the cached exception type to the stack.
   iv. Branch to the exception handler.
3. Repeat.

The default exception handler, which catches "unhandled" exceptions,
is installed by the macro-assembler in ``src/pkl-asm.c:pkl_asm_new``
and ``src/pkl-asm.c:pkl_asm_finish``.  It calls the function
``_pkl_exception_handler``, that is defined in the compiler runtime in
``src/pkl-rt.pkl``.

Offsets and bit-offsets in the PVM
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The PVM supports a ``pvm_off`` boxed value, to denote pairs of
magnitudes and units.  Both accessor macros (in ``pvm-val.h``) and PVM
instructions (``ogetm``, ``ogetu``) are provided to access their
components.

Many other PVM entities need to denote offsets in a way or another.
For example, struct fields in ``pvm_struct`` values need to record
their relative offset with respect the beginning of the struct.

It may come to mind, quite naturally, to use ``pvm_off`` values to
denote these offsets.  It is very elegant.  However, we decided to use
"bit offsets" instead, stored in 64-bit ``pvm_long`` values.

There are two reasons for this:

- First of all, performance.  It is fairly common to operate with the
  absolute value of these offsets, in bits.  In fact, in most cases
  that is the only purpose of maintaining them.  Having them stored in
  ``pvm_off`` values means we have to multiply every time we want to
  get their magnitude.  This is a waste, for no good reason.

- To avoid code coupling.  PVM offsets are very cool, but they are
  also complex: the unit is arbitrary.  This means in many cases we
  have to assume the nature of the unit, mainly bits.  This is very
  fragile.

So, the take-home message is: in the PVM, restrict the presence of
``pvm_off`` values to the ones generated by the code generator.
Whenever an offset is needed in some internal PVM structure, use
bit-offsets instead encoded as ``ulong<64>`` values.

Memory Management
-----------------

Different parts of poke use different strategies for memory
management:

- The compiler front-end uses reference counting to handle AST nodes.

- The PVM uses the Boehm GC collector for values and the run-time
  environment.

- Everything else uses ``malloc``/``free``.

This sometimes leads to tricky situations, some of which are
documented in the subsections below.

Using ASTREF
~~~~~~~~~~~~

The AST uses reference counting in order to manage the memory used by
the nodes.  Every time you store a pointer to an AST node, you should
use the macro ``ASTREF`` in order to increase it's counter::

  pkl_ast_node foo = ASTREF (node);

Note that the ``pkl_ast_make_*`` constructors do ``ASTREF``
internally, so you don't need to use it in calls like::

  pkl_ast_node new = pkl_ast_make_struct (ast, 5, elems_node);

There is a little caveat: the way ASTREF is defined, it requires a
l-value to work properly.  Therefore, this doesn't work::

  pkl_ast_node foo = ASTREF (PKL_AST_TYPE (node));

instead, write::

  pkl_ast_node type = PKL_AST_TYPE (node);
  pkl_ast_node foo = ASTREF (type);


Using ASTDEREF
~~~~~~~~~~~~~~

``ASTDEREF`` decreases the reference counter of the provided AST
node.  The passed value should be a l-value.

In practice you will seldom find yourself in the need to use
``ASTDEREF``.  Just make sure that every ``ASTREF`` is paired with a
``pkl_ast_node_free``.

However, there are situations where ``ASTDEREF`` is necessary in order
toavoid a memory leak.  For example, consider transformations like ``a
-> b`` to ``a -> x -> b``.  In that case, you sould use something
like::

  b = PKL_AST_KIND_WHAT (node);
  x = pkl_ast_make_xxx (ast, ASTDEREF (b));
  PKL_AST_KIND_WHAT (node) = ASTREF (x);

This works because ``pkl_ast_make_xxx`` does an ``ASTREF`` to ``b``
internally.  The final result is that the reference counter of ``b``
doesn't change at all.
  
PVM values in PVM programs
~~~~~~~~~~~~~~~~~~~~~~~~~~

The PVM programs (data structures of type ``pvm_program``) are
allocated by Jitter, using ``malloc``.  Therefore, they are not
traversed by the GC.

Now, the instructions in a program can contain literal PVM values, and
some of these values will be boxed.  For example, the following
program contains a pointer to a ``pvm_val_box``::

  ;; Initialize the element index to 0UL, and put it
  ;; in a local.
  push ulong<64>0
  regvar $eidx

There are two places where PVM programs are stored in other data
structures: in closures, and in the compiler.

A closure is a kind of PVM value itself, and therefore allocated by
the GC.  It is composed by a PVM program, a run-time environment and
an entry point into the program::

  struct pvm_cls
  {
    struct jitter_program *program;
    const void *entry_point;
    struct pvm_env *env;
  };

However, since ``program`` is malloc-allocated, the GC can't traverse
it.  Consequently, the references to contained boxed values won't be
accounted, and these values will be collected if there are no more
refences to them!

The solution, recommended by Luca Saiu, is to keep an array of
pointers in the closure structure, containing the pointers to every
boxed value used in ``program``::

  struct pvm_cls
  {
    struct jitter_program *program;
    void **pointers;
    const void *entry_point;
    struct pvm_env *env;
  };

The subsystem responsible for collecting the pointers is the
macro-assembler in ``pkl-asm.c``.  ``pkl_asm_finish`` will return the
array of pointers, and it is up to the caller (in the code generator)
to install it the corresponding closure structure.

The second place where a PVM program is stored in other data
structures is the compiler functions ``pkl_compile_file`` and
``pkl_compile_buffer``.  In both functions, the compiled PVM program
is executed and then discarded.  However, it is still required to have
the ``pointers`` array linked from the C stack, to avoid the GC to
collect the values from the program.  That's the purpose of the weird
local variables, which are set but never used::

  int
  pkl_compile_buffer (pkl_compiler compiler,
                      char *buffer, char **end)
  {
    ...
    /* Note that the sole purpose of `pointers' is to serve as a root
       (in the stack) for the GC, to prevent the boxed values in PROGRAM
       to be collected.  Ugly as shit, but conservative garbage
       collection doesn't really work.  */
    void *pointers;
    ...
    program = rest_of_compilation (compiler, ast, &pointers);
    ...
  }

PVM values in AST nodes
~~~~~~~~~~~~~~~~~~~~~~~

Storing a PVM value (whose memory is handled by GC) in an AST node
(reference-counted) lead to a problem: the GC is unable to see the
reference to values, and will collect the memory if there are no other
references.

Let's see an example of this.  Both array and struct types contain
closures for mappers, writers, bounders, and the like.  For example,
let's take arrays::

    struct pkl_ast_type
    {
        ...
        struct
        {
          union pkl_ast_node *bound;
          union pkl_ast_node *etype;
          pvm_val mapper;
          pvm_val writer;
          pvm_val bounder;
        } array;
    }

In this case, ``mapper``, ``writer`` and ``bounder`` are managed by
GC.  However, the contained ``struct pkl_ast_type`` is not.  There is
no way the GC can find these nodes thru the AST node.

The solution is to declare the relevant pointers in the containing AST
node as GC roots.  The right place to do that is in the corresponding
constructor in ``pkl-ast.c``.  For example::

  pkl_ast_node
  pkl_ast_make_array_type (pkl_ast ast, pkl_ast_node etype, pkl_ast_node bound)
  {
    ...
    /* The closure slots are GC roots.  */
    pvm_alloc_add_gc_roots (&PKL_AST_TYPE_A_MAPPER (type), 1);
    pvm_alloc_add_gc_roots (&PKL_AST_TYPE_A_WRITER (type), 1);
    pvm_alloc_add_gc_roots (&PKL_AST_TYPE_A_BOUNDER (type), 1);
    ...
  }

And of course, before the memory of the AST node is freed, these roots
should be unregistered from the GC.  The right place to do this is in
``pkl_ast_node_free``::

  void
  pkl_ast_node_free (pkl_ast_node ast)
  {
    ...
    case PKL_AST_TYPE:
      switch (PKL_AST_TYPE_CODE (ast))
        {
        ...
        case PKL_TYPE_ARRAY:
          /* Remove GC roots.  */
          pvm_alloc_remove_gc_roots (&PKL_AST_TYPE_A_MAPPER (ast), 1);
          pvm_alloc_remove_gc_roots (&PKL_AST_TYPE_A_WRITER (ast), 1);
          pvm_alloc_remove_gc_roots (&PKL_AST_TYPE_A_BOUNDER (ast), 1);
        }
  }

So if you add PVM values or PVM environments to an AST node, please
follow the strategy above.

Debugging Poke
--------------

Building with Debugging support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Configure the sources with ``--enable-debug``.  This will:

1. Use a threaded jitter dispatching model.
2. Build the sources with ``-O0 -g3`` in CFLAGS.

Using GDB extensions
~~~~~~~~~~~~~~~~~~~~

In order to use the GDB pretty-printers and other goodies brought to
you courtesy of the poke hackers, just source the poke-gdb.scm file
from your debugger::

  (gdb) source etc/poke-gdb.scm

Valgrind and Poke
~~~~~~~~~~~~~~~~~

The PVM uses the Boehm conservative garbage collector in order to
manage the memory used by the VM values.  Other parts of poke, such as
the PKL compiler, manage their own memory.

Valgrind gets easily confused by the GCs tampering with the stack, and
emits a lot of spurious warnings.  Fortunately it is possible to tell
memcheck to omit these warnings: the file etc/boehm-gc.suppresions
contains a list of suppresions.

Invoke valgrind with ``--suppressions=etc/boehm-gc.suppressions``.

If despite using the suppressions file you see some spurious warning,
please use::

  $ valgrind --tool=memcheck --gen-suppressions=all --log-file=raw.log


Then process raw.log with the ``etc/parse-valgrind-suppressions.sh``
script, wilcard the result as much as you can, and append the results
to ``etc/boehm-gc.suppressions``.

In order to run the testsuite with valgring, edit lib/poke-dg.exp and
uncomment the lines::

 set VALGRIND "valgrind --quiet \
               --suppressions=${srcdir}/../etc/boehm-gc.suppressions \
               --tool=memcheck --gen-suppressions=all"

Then run ``make check`` as usual.

Debugging PVM Assembly Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hacking some areas of the compiler, such as the code generator pass,
involves meta-programming PVM assembler.  It is easy to find examples
anywhere in ``src/pkl-gen.c``::

  pkl_asm_insn (pasm, PKL_INSN_ROT);
  pkl_asm_insn (pasm, PKL_INSN_MULLU);
  pkl_asm_insn (pasm, PKL_INSN_NIP2);

Or, alternatively, the code may be written in RAS in a ``.pks`` file.
Like::

  .loop:
        bz @type, .endloop      ; ... A B
        mod @type               ; ... A B A%B
        rot                     ; ... B A%B A
        drop                    ; ... B A%B
        ba .loop

Often, a run-time problem becomes apparent while the PVM executes the
generated code.  Typical cases are when a PVM value doesn't contain
what it's supposed to contain, and accessing the wrong boxed value
causes a segmentation fault (if we are lucky) or a non-crashing
invalid memory access (if we are very unlucky.)  Whenever that kind of
crap happens, we find ourselves in the need of debugging the PVM code,
which is a big PITA.

Bad news are: we don't have a PVM debugger (yet).
Good news are: we have a couple of tools that may help.

The first of such tools is the ``prints`` instruction.  This
instructions basically prints in the standard output the string value
on the TOS, and then drops it.  It is a wonderful way to trace PVM
code.

For example, let's say we are trying to find out how many times the
loop above gets executed.  We can install traces like::

        push "XXX entering loop\n"
        prints
  .loop:
        push "XXX in loop\n"
        prints
        mod @type
        rot
        drop
        ba .loop

The other tool is the ``strace`` instruction.  It prints the contents
of the stack (one value per line) from the TOS.  It gets the number of
stack values to print as an argument, 0 meaning all of them.  It is
very useful in many situations, like when a loop is composing values
in the stack and something is going banana.  It is also useful to
determine what kind of value is being accessed by a given instruction.

For example, lets say that we are hunting some segmentation fault.  We
highly suspect the code generated in the first example in this
section, above.  Of the three instructions, ``mullu`` is the only one
that could conceivably generate a segfault, so we add a stack trace
instruction right before it to inspect it's two arguments::

  pkl_asm_insn (pasm, PKL_INSN_ROT);
  pkl_asm_insn (pasm, PKL_INSN_STRACE, 2); /* XXX remove me */
  pkl_asm_insn (pasm, PKL_INSN_MULLU);
  pkl_asm_insn (pasm, PKL_INSN_NIP2);

We recompile, re-run, and we find out that the elements at the TOS
when ``mullu`` is executed are a pair of stupid signed integers, which
are not boxed and not what the instruction expects.  Mystery solved.

Future Developments
-------------------

- Allow variable expressions in array initializer indexes.  Something
  like::

    [1,[foo*2]=666]

  this will of course mean that the types of literal arrays won't be
  necessarily be bounded by a constant number of elements.  No big
  deal.

- Allow anonymous initializers in struct constructors.  Something
  like::

    deftype Foo = struct { int i; long j; }
    Foo { i = 10, j = 20L }

- Allow coercions in struct constructors.  Currently this is not
  supported::

    deftype Foo = struct { int i; }
    Foo { i = 10L }
    

Appendix: The Source Tree
-------------------------

The Compiler
~~~~~~~~~~~~
Support for abstract syntax trees
  ``src/pkl-ast.c``, ``src/pkl-ast.h``, ``src/pkl-ops.def``,
  ``src/pkl-attrs.def``

The compiler driver
  ``src/pkl.h``, ``src/pkl.c``, ``src/pkl-pass.c``,
  ``src/pkl-pass.h``
   
The lexer, and parser
  ``src/pkl-lex.l``, ``src/pkl-tab.y``, ``src/pkl-parser.c``,
  ``src/pkl-parser.h``
   
Compile-time lexical environment
  ``src/pkl-env.h, ``src/pkl-env.c``

Analysis phases
  ``src/pkl-anal.c``, ``src/pkl-anal.h``

Transformation phases
  ``src/pkl-trans.c``, ``src/pkl-trans.h``

Type system related phases
  ``src/pkl-typify.c``, ``src/pkl-typify.h``

Constant folding phase
  ``src/pkl-fold.c``, ``src/pkl-fold.h``

Coercions phases
  ``src/pkl-promo.c``, ``src/pkl-promo.h``

The code generator
  ``src/pkl-gen.h``, ``src/pkl-gen.c``, ``src/pkl-gen.pks``
  
The macro-assembler
  ``src/pkl-insn.def``, ``src/pkl-asm.h``, ``src/pkl-asm.c``,
  ``src/pkl-asm.pks``
  
Our good friend ras
  ``src/ras``

Compiler run-time library
  ``src/pkl-rt.pk``

The Poke Virtual Machine
~~~~~~~~~~~~~~~~~~~~~~~~

Virtual machine driver
  ``src/pvm.c``, ``src/pvm.h``

Virtual machine values
  ``src/pvm-val.c``, ``src/pvm-val.h``

Memory allocator with garbage collection
  ``src/pvm-alloc.c``, ``src/pvm-alloc.h``

Run-time environment
  ``src/pvm-env.c``, ``src/pvm-env.h``

Virtual machine instructions
  ``src/pvm.jitter``

The IO Subsystem
~~~~~~~~~~~~~~~~

Support for IO spaces
  ``src/ios.h``, ``src/ios.c``

Support for IO devices
  ``src/ios-dev.h``

Supported IO devices
  ``src/ios-dev-file.c``

Poke Program
~~~~~~~~~~~~

Main program
  ``src/poke.h``, ``src/poke.c``

Infrastructure for writing poke commands
  ``src/pk-cmd.h``, ``src/pk-cmd.c``

Terminal stuff
  ``src/pk-term.h``, ``src/pk-term.c``

Commands
  ``src/pk-def.c``, ``src/pk-dump.pk``, ``src/pk-file.c``,
  ``src/pk-help.c``, ``src/pk-info.c``, ``src/pk-misc.h``,
  ``src/pk-set.c``, ``src/pk-vm.c``

Pickles and Libraries
~~~~~~~~~~~~~~~~~~~~~

Standard library
  ``src/std.pk``

Pickles
  ``pickles/elf.pk``, ``pickles/ctf.pk``

Test Suite
~~~~~~~~~~
Target-specific dejagnu configuration
 ``testsuite/config/default.exp``, ``testsuite/config/unix.exp``
 
Poke test drivers
 ``testsuite/lib/poke.exp``, ``testsuite/lib/poke-dg.exp``

Compiler test suite
  ``testsuite/poke.pkl/pkl.exp``, ``testsuite/poke.pkl/*.pk``

Compiler test suite (mapping)
  ``testsuite/poke.map/map.exp``, ``testsuite/poke.pkl/*.pk``

Standard library test suite
  ``testsuite/poke.std/std.exp``, ``testsuite/poke.std/*.pk``

Tests for Poke commands
  ``testsuite/poke.cmd/cmd.exp``, ``testsuite/poke.cmd/*.pk``

Documentation
~~~~~~~~~~~~~
The Poke book
  ``doc/poke.texi``

Other Stuff
~~~~~~~~~~~

GDB extensions to better debug poke
  ``etc/poke-gdb.scm``

Suppression list for memcheck
  ``etc/boehm-gc.suppressions``

..
  Local Variables:
  mode: rst
  End:
