========================
GNU Poke - Hacking Notes
========================

Welcome, adventurous poker! This file contains useful information for
you.

..  Please be as good as to update the table of contents below if you
    modify the sectioning of the document.  If in Emacs,
    M-xrst-toc-update should take care of it automatically.

.. contents:: 
..
    1  Development Environment
      1.1  Autotools
      1.2  Flex
      1.3  Building
      1.4  Gettext
    2  The Source Tree
      2.1  The Compiler
      2.2  The Poke Virtual Machine
      2.3  The IO Subsystem
      2.4  Poke Program
      2.5  Pickles and Libraries
      2.6  Test Suite
      2.7  Documentation
      2.8  Other Stuff
    3  Coding Style and Conventions
      3.1  When writing Poke
    4  Poke Architecture
    5  The Poke Compiler
      5.1  Compiler Overview
      5.2  The bison Parser in pkl-tab.y
      5.3  The AST
        5.3.1  Using ASTREF
      5.4  Compiler Passes and Phases
        5.4.1  Naming Conventions for Phases
        5.4.2  Naming Conventions for Handlers
        5.4.3  Transformation Phases
        5.4.4  Analysis Phases
        5.4.5  Type System Phases
      5.5  The Type System
        5.5.1  Type Expressions
    6  The Poke Virtual Machine
      6.1  Exception Handling
    7  Debugging Poke
      7.1  Building with Debugging support
      7.2  Using GDB extensions
      7.3  Valgrind and Poke
      7.4  Debugging PVM Assembly Code
    8  Future Developments


Development Environment
-----------------------

Autotools
~~~~~~~~~

This distribution uses whatever versions of Automake, Autoconf, and
Gettext are listed in NEWS; usually the latest ones released.  If you
are getting the sources from git (or change configure.ac), you'll need
to have these tools installed to (re)build.  You'll also need
help2man.  All of these programs are available from
ftp://ftp.gnu.org/gnu.

Flex
~~~~

You will need a recent version of flex, since we are using some recent
options like "reentrant" or "bison-bridge".  flex version 2.6.1 works
fine.

Building
~~~~~~~~

After getting the git sources, and installing the tools above, you can
run::
  
  ./bootstrap

to do a fresh build.  After that first time, running make should
suffice.

Gettext
~~~~~~~

When updating gettext, besides the normal installation on the system,
it is necessary to run gettextize -f in this hierarchy to update the
po/ infrastructure.  After doing so, rerun gnulib-tool --import since
otherwise older files will have been imported.  See the Gnulib manual
for more information.


The Source Tree
---------------

The Compiler
~~~~~~~~~~~~
Support for abstract syntax trees:

- src/pkl-ast.c
- src/pkl-ast.h
- src/pkl-ops.def
- src/pkl-attrs.def

The compiler driver:

- src/pkl.h
- src/pkl.c
- src/pkl-pass.c
- src/pkl-pass.h

The lexer, and parser:

- src/pkl-lex.l
- src/pkl-tab.y
- src/pkl-parser.c
- src/pkl-parser.h

Compile-time lexical environment:

- src/pkl-env.h
- src/pkl-env.c

Analysis phases:

- src/pkl-anal.c
- src/pkl-anal.h

Transformation phases:

- src/pkl-trans.c
- src/pkl-trans.h

Type system related phases:

- src/pkl-typify.c
- src/pkl-typify.h

Constant folding phase:

- src/pkl-fold.c
- src/pkl-fold.h

Coercions phases:

- src/pkl-promo.c
- src/pkl-promo.h

The code generator:

- src/pkl-gen.h
- src/pkl-gen.c
- src/pkl-gen.pks

The macro-assembler:

- src/pkl-insn.def
- src/pkl-asm.h
- src/pkl-asm.c
- src/pkl-asm.pks

Our good friend ras:

- src/ras.

Compiler run-time library:

- src/pkl-rt.pk

The Poke Virtual Machine
~~~~~~~~~~~~~~~~~~~~~~~~

Virtual machine driver:

- src/pvm.c
- src/pvm.h

Virtual machine values:

- src/pvm-val.c
- src/pvm-val.h

Run-time environment:

- src/pvm-env.c
- src/pvm-env.h

Virtual machine instructions:

- src/pvm.jitter

The IO Subsystem
~~~~~~~~~~~~~~~~

Support for IO spaces:

- src/ios.h
- src/ios.c

Support for IO devices:

- src/ios-dev.h

Supported IO devices:

- src/ios-dev-file.c

Poke Program
~~~~~~~~~~~~

Main program:

- src/poke.h
- src/poke.c

Infrastructure for writing poke commands:

- src/pk-cmd.h
- src/pk-cmd.c

Terminal stuff:

- src/pk-term.h

Commands:

- src/pk-def.c
- src/pk-dump.pk
- src/pk-file.c
- src/pk-help.c
- src/pk-info.c
- src/pk-misc.h
- src/pk-set.c
- src/pk-vm.c

Pickles and Libraries
~~~~~~~~~~~~~~~~~~~~~

Standard library:

- src/std.pk

Pickles:

- pickles/elf.pk
- pickles/ctf.pk

Test Suite
~~~~~~~~~~
Target-specific dejagnu configuration:

- testsuite/config/default.exp
- testsuite/config/unix.exp

Poke test drivers:

- testsuite/lib/poke.exp
- testsuite/lib/poke-dg.exp

Compiler test suite:

- testsuite/poke.pkl/pkl.exp
- testsuite/poke.pkl/\*.pk

Compiler test suite (mapping):

- testsuite/poke.map/map.exp
- testsuite/poke.pkl/\*.pk

Standard library test suite:

- testsuite/poke.std/std.exp
- testsuite/poke.std/\*.pk

Tests for Poke commands:

- testsuite/poke.cmd/cmd.exp
- testsuite/poke.cmd/\*.pk

Documentation
~~~~~~~~~~~~~
The Poke book:

- doc/poke.texi

Other Stuff
~~~~~~~~~~~

GDB extensions to better debug poke:

- etc/poke-gdb.scm

Suppression list for memcheck:

- etc/boehm-gc.suppressions

Coding Style and Conventions
----------------------------

When writing Poke
~~~~~~~~~~~~~~~~~

- Do not separate magnitudes and units when writing offsets.  Do it
  like this::

    16#B

  instead of::

    16 #B


Poke Architecture
-----------------

This figure depicts the overall architecture of Poke::
  
  +----------+
  | compiler |      
  +----------+      +------+
       |            |      |
       v            |      |
  +----------+      |      |
  |   PVM    | <--->|  IO  |
  +----------+      |      |
       ^            |      |
       |            |      |
       v            +------+
  +----------+
  | command  |
  +----------+

The Poke Compiler
-----------------

Compiler Overview
~~~~~~~~~~~~~~~~~

This figure depicts the architecutre of the compiler::
  
      /--------\
      | source |
      \---+----/
          |
          v
  +-----------------+
  |      Parser     |
  +-----------------+
  |  analysis and   |
  | transformation  |
  |     phases      |
  +-----------------+    
  | code generation |
  |      phase      |
  +-----------------+
  | Macro assembler |
  +-----------------+
          |
          v
     /---------\
     | program |
     \---------/

The bison Parser in pkl-tab.y
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The only purpose of the bison parser in pkl-tab.y is to do the
syntactic analysis, build the initial AST, and set the locations of
the AST nodes.

Unfortunately, currently it also does some extra work, due to
limitations in the LARL parser:

- It builds the compile-time environment and register type, variable
  and function declarations.
- It annotates variables with their lexical addresses.
- It links return statements with their containing functions.
- It annotates return statements with he number of lexical frames they
  should pop before exitting the function.

As we shall see below, any further analysis and transformations on the
AST are performed by the compiler phases, which are implemented
elsewhere.  This greatly helps to keep the parser code clean and easy
to read, and also eases changing the syntactic structure of poke
programs.

The AST
~~~~~~~

Using ASTREF
............

The AST uses reference counting in order to manage the memory used by
the nodes.  Every time you store a pointer to an AST node, you should
use the macro ``ASTREF`` in order to increase it's counter::

  pkl_ast_node foo = ASTREF (node);

Note that the ``pkl_ast_make_*`` constructors do ``ASTREF``
internally, so you don't need to use it in calls like::

  pkl_ast_node new = pkl_ast_make_struct (ast, 5, elems_node);

There is a little caveat: the way ASTREF is defined, it requires a
l-value to work properly.  Therefore, this doesn't work::

  pkl_ast_node foo = ASTREF (PKL_AST_TYPE (node));

instead, write::

  pkl_ast_node type = PKL_AST_TYPE (node);
  pkl_ast_node foo = ASTREF (type);


Compiler Passes and Phases
~~~~~~~~~~~~~~~~~~~~~~~~~~

These are the phases currently implemented in the poke compiler (the
phases marked with a * are optional)::

    [parser]
    --- Front-end pass
    trans1     Transformation phase 1.
    anal1      Analysis phase 1.
    typify1    Type analysis and transformation 1.
    promo      Operand promotion phase.
    trans2     Transformation phase 2.
  * fold       Constant folding.
    typify2    Type analysis and transformation 2.
    trans3     Transformation phase 3.
    anal2      Analysis phase 2.
    --- Middle-end pass
    trans4     Transformation phase 4.
    --- Back-end pass
    analf      Analysis final phase.
    gen        Code generation.

The phases above are organized in several passes:

Pass1
  anal1 typify1 promo trans2 fold typify2 trans3 anal2
Pass2
  trans4
Pass3
  analf gen

Naming Conventions for Phases
.............................

We use the following convention to name phases::

  {NAME}{SUFFIX}

where ``NAME`` reflects a phase category (see below) and ``SUFFIX`` is
usually an integer that specifies the order in which the phases are
applied.  Thus, for example, ``name4`` is performed after ``name1``.
Sometimes, ``SUFFIX`` is ``f`` (meaning "final").

The suffix is not used if there is only one phase in the given
category.

We use the following phase categories:

anal
  For phases whose main purpose is to perform checks on the AST,
  and/or the contents of the AST nodes, and emit errors/warnings.

trans
  For phases whose main purpose is to alter the structure of the AST,
  and/or the contents of the AST nodes.

typify
  For phases whose main purpose is to perform type checks, and
  otherwise do work on types.

promo
  For phases whose main purpose is to perform coercions wherever
  appropriate.  Currently there is only one phase in this category.

fold
  For phases whose main purpose is to pre-compute areas of the AST
  whenever it is possible to do so at compile-time.  Currently there
  is only one phase in this category, that performs constant folding.

gen
  For phases whose main purpose is to generate PVM code.  Currently
  there is only one phase in this category.

The phases in category ``NAME`` are implemented in the source files
``src/pkl-NAME.[ch]``.


Naming Conventions for Handlers
...............................

We use the following convention to name phase handlers::

  pkl_PHASE_{ps,pr}_NODE

where ``PHASE`` can be a complete phase name (like ``typify1``) if the
handler is to be installed in that phase only, or a phase category
name (like ``typify``) if the handler is to be installed in several
phases in that category.  If the phase is to be executed in pre-order,
``pr`` follows, otherwise, ``ps``.  Finally, ``NODE`` is the name of
the AST node.

For example, the handler::

  pkl_anal1_ps_comp_stmt

is installed in the phase ``anal1``, executes in post-order, and
serves the AST nodes with code ``PKL_AST_COMP_STMT``.


Transformation Phases
.....................

trans1
  - Finishes strings by expanding \-sequences, emitting diagnostics if
    an invalid \-sequence is found.

trans4
  - Reverses the list of actual arguments in function calls, so the
    code generator tackles them in the right (reversed) order, as it
    is expected by the callee.

Analysis Phases
...............

anal1
  - Checks that every return statement is linked to a function.
  - Checks that no return statement is linked to a void function.

Type System Phases
..................

typify1
  - Checks that the expression in which a funcall is applied is a
    function, and that the types of the formal parameters mach the
    types of the funcall arguments.
  - Checks that void functions are not called in contexts where a
    value is expected.

typify2
  - Checks that the type of the expression in a return statement
    matches the return type of its containing function.


The Type System
~~~~~~~~~~~~~~~

This section describes the type system implemented in the 'poke'
language.

Type Expressions
................

A *type expression* denotes some particular type.  Type expressions
can be one of:

A *simple type*
  Simple types are types that are not composed of other types.  In
  this discussion we use the following sexp-like notations for them:

  (int N)
    Signed integer of N bits, where 0 < N <= 64.
  (uint N)
    Likewise, but the integer is unsigned.
  string
    NULL-terminated C-like string.
  void
    This is the null type.  Used for several purposes.

A *product*
  Products of two type expressions are used to aggregate types in more
  complex structures, such as lists.  We denote them by using the
  following sexp-like notation:

  (T1 . T2)
    product of the type expressions T1 and T2.

  In order to simplify, we use the same list abbreviation used by Lisp
  in order to denote aggregations of types built with products::

    (T1 . (T2 . (T3 . T4))) -> (T1 T2 T3 T4)
  
  Note that type products are not really valid types by themselves.

An *array type*

A *struct type*
  Type expressions for structs are characterized by many attributes.
  We denote these expressions by using the following sexp-like
  notation.

  (struct PINNED ((L1 N1 T1 C1)...))
     where L1 is the label of the first element: a poke expression
     evaluating to an offset.  N1 is the name of the element, which is
     optional.  T1 is a type expression denoting the type of the
     element.  C1 is a poke expression evaluating to a boolean; it is
     the constraint associated to the element.   Of all these
     attributes, only T1 is mandatory.  PINNED is a boolean indicating
     whether structs having this type are pinnned.

A *function type*
  Type expressions for functions are characterized by a type
  expression denoting the types of it's arguments and the type of the
  value returned by the function.  We denote them using the following
  sexp-like notation:

  (fun T1 T2)
    where T1 is the type of the arguments to the function, and T2 is
    the type of the value returned by the function.

  Usually T1 will be an aggregation of types built as nested
  products.  For example, the type expression for a function that
  takes three 32-bit signed integers and returns a string is::

    (fun ((int 32) (int 32) (int 32)) string)

  If a type expression denotes the type of a function which doesn't
  take any argument, T1 should be 'void'.  Likewise, if the function
  doesn't return a value, T2 should be 'void'.

The Poke Virtual Machine
------------------------

Exception Handling
~~~~~~~~~~~~~~~~~~

Exception types are signed 32-bit integers, and are defined in
``src/pkl-rt.pkl``.

There are two ways an exception can be raised in the PVM:

- Explicitly, when the instruction ``raise`` is executed.
- Implicitly, when some instruction needs to fail.  For example,
  an integer division instruction divides by zero.

In either case, the treatment of a raised exception is the same:

1. Pop an exception handler from the exception handler stack.
2. If the exception handler matches the raised exception type, then
   i. Restore the heights of the main and return stacks.
   ii. Restore the dynamic environment.
   iii. Push the cached exception type to the stack.
   iv. Branch to the exception handler.
3. Repeat.

The default exception handler, which catches "unhandled" exceptions,
is installed by the macro-assembler in ``src/pkl-asm.c:pkl_asm_new``
and ``src/pkl-asm.c:pkl_asm_finish``.  It calls the function
``_pkl_exception_handler``, that is defined in the compiler runtime in
``src/pkl-rt.pkl``.

Debugging Poke
--------------

Building with Debugging support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Configure the sources with ``--enable-debug``.  This will:

1. Use a threaded jitter dispatching model.
2. Build the sources with ``-O0 -g3`` in CFLAGS.

Using GDB extensions
~~~~~~~~~~~~~~~~~~~~

In order to use the GDB pretty-printers and other goodies brought to
you courtesy of the poke hackers, just source the poke-gdb.scm file
from your debugger::

  (gdb) source etc/poke-gdb.scm

Valgrind and Poke
~~~~~~~~~~~~~~~~~

The PVM uses the Boehm conservative garbage collector in order to
manage the memory used by the VM values.  Other parts of poke, such as
the PKL compiler, manage their own memory.

Valgrind gets easily confused by the GCs tampering with the stack, and
emits a lot of spurious warnings.  Fortunately it is possible to tell
memcheck to omit these warnings: the file etc/boehm-gc.suppresions
contains a list of suppresions.

Invoke valgrind with ``--suppressions=etc/boehm-gc.suppressions``.

If despite using the suppressions file you see some spurious warning,
please use::

  $ valgrind --tool=memcheck --gen-suppressions=all --log-file=raw.log


Then process raw.log with the ``etc/parse-valgrind-suppressions.sh``
script, wilcard the result as much as you can, and append the results
to ``etc/boehm-gc.suppressions``.

In order to run the testsuite with valgring, edit lib/poke-dg.exp and
uncomment the lines::

 set VALGRIND "valgrind --quiet \
               --suppressions=${srcdir}/../etc/boehm-gc.suppressions \
               --tool=memcheck --gen-suppressions=all"

Then run ``make check`` as usual.

Debugging PVM Assembly Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hacking some areas of the compiler, such as the code generator pass,
involves meta-programming PVM assembler.  It is easy to find examples
anywhere in ``src/pkl-gen.c``::

  pkl_asm_insn (pasm, PKL_INSN_ROT);
  pkl_asm_insn (pasm, PKL_INSN_MULLU);
  pkl_asm_insn (pasm, PKL_INSN_NIP2);

Or, alternatively, the code may be written in RAS in a ``.pks`` file.
Like::

  .loop:
        bz @type, .endloop      ; ... A B
        mod @type               ; ... A B A%B
        rot                     ; ... B A%B A
        drop                    ; ... B A%B
        ba .loop

Often, a run-time problem becomes apparent while the PVM executes the
generated code.  Typical cases are when a PVM value doesn't contain
what it's supposed to contain, and accessing the wrong boxed value
causes a segmentation fault (if we are lucky) or a non-crashing
invalid memory access (if we are very unlucky.)  Whenever that kind of
crap happens, we find ourselves in the need of debugging the PVM code,
which is a big PITA.

Bad news are: we don't have a PVM debugger (yet).
Good news are: we have a couple of tools that may help.

The first of such tools is the ``prints`` instruction.  This
instructions basically prints in the standard output the string value
on the TOS, and then drops it.  It is a wonderful way to trace PVM
code.

For example, let's say we are trying to find out how many times the
loop above gets executed.  We can install traces like::

        push "XXX entering loop\n"
        prints
  .loop:
        push "XXX in loop\n"
        prints
        mod @type
        rot
        drop
        ba .loop

The other tool is the ``strace`` instruction.  It prints the contents
of the stack (one value per line) from the TOS.  It gets the number of
stack values to print as an argument, 0 meaning all of them.  It is
very useful in many situations, like when a loop is composing values
in the stack and something is going banana.  It is also useful to
determine what kind of value is being accessed by a given instruction.

For example, lets say that we are hunting some segmentation fault.  We
highly suspect the code generated in the first example in this
section, above.  Of the three instructions, ``mullu`` is the only one
that could conceivably generate a segfault, so we add a stack trace
instruction right before it to inspect it's two arguments::

  pkl_asm_insn (pasm, PKL_INSN_ROT);
  pkl_asm_insn (pasm, PKL_INSN_STRACE, 2); /* XXX remove me */
  pkl_asm_insn (pasm, PKL_INSN_MULLU);
  pkl_asm_insn (pasm, PKL_INSN_NIP2);

We recompile, re-run, and we find out that the elements at the TOS
when ``mullu`` is executed are a pair of stupid signed integers, which
are not boxed and not what the instruction expects.  Mystery solved.

Future Developments
-------------------

- Allow variable expressions in array initializer indexes.  Something
  like::

    [1,[foo*2]=666]

  this will of course mean that the types of literal arrays won't be
  necessarily be bounded by a constant number of elements.  No big
  deal.

..
  Local Variables:
  mode: rst
  End:
