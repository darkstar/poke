========================
GNU Poke - Hacking Notes
========================

Welcome, adventurous poker!
This file contains useful information for you.

Please be as good as to update the table of contents below if you
modify the sectioning of the document.  If in Emacs, M-xrst-toc-update
should take care of it automatically.

.. contents:: 
..
    1  The Source Tree
      1.1  The Compiler
      1.2  The Poke Virtual Machine
      1.3  The IO Subsystem
      1.4  Poke Program
      1.5  Pickles and Libraries
      1.6  Test Suite
      1.7  Documentation
      1.8  Other Stuff
    2  Poke Architecture
    3  The Poke Compiler
      3.1  Compiler Overview
      3.2  The bison Parser in pkl-tab.y
      3.3  Compiler Passes and Phases
      3.4  The Type System
        3.4.1  Type Expressions
    4  The Poke Virtual Machine
      4.1  Exception Handling
    5  Debugging Poke
      5.1  Building with Debugging support
      5.2  Using GDB extensions
      5.3  Valgrind and Poke
      5.4  Debugging PVM Assembler
    6  Future Developments


The Source Tree
---------------

The Compiler
~~~~~~~~~~~~
Support for abstract syntax trees:

- src/pkl-ast.c
- src/pkl-ast.h
- src/pkl-ops.def
- src/pkl-attrs.def

The compiler driver:

- src/pkl.h
- src/pkl.c
- src/pkl-pass.c
- src/pkl-pass.h

The lexer, and parser:

- src/pkl-lex.l
- src/pkl-tab.y
- src/pkl-parser.c
- src/pkl-parser.h

Compile-time lexical environment:

- src/pkl-env.h
- src/pkl-env.c

Analysis phases:

- src/pkl-anal.c
- src/pkl-anal.h

Transformation phases:

- src/pkl-trans.c
- src/pkl-trans.h

Type system related phases:

- src/pkl-typify.c
- src/pkl-typify.h

Constant folding phase:

- src/pkl-fold.c
- src/pkl-fold.h

Coercions phases:

- src/pkl-promo.c
- src/pkl-promo.h

The code generator:

- src/pkl-gen.h
- src/pkl-gen.c
- src/pkl-gen.pks

The macro-assembler:

- src/pkl-insn.def
- src/pkl-asm.h
- src/pkl-asm.c
- src/pkl-asm.pks

Our good friend ras:

- src/ras.

Compiler run-time library:

- src/pkl-rt.pk

The Poke Virtual Machine
~~~~~~~~~~~~~~~~~~~~~~~~

Virtual machine driver:

- src/pvm.c
- src/pvm.h

Virtual machine values:

- src/pvm-val.c
- src/pvm-val.h

Run-time environment:

- src/pvm-env.c
- src/pvm-env.h

Virtual machine instructions:

- src/pvm.jitter

The IO Subsystem
~~~~~~~~~~~~~~~~

Support for IO spaces:

- src/ios.h
- src/ios.c

Support for IO devices:

- src/ios-dev.h

Supported IO devices:

- src/ios-dev-file.c

Poke Program
~~~~~~~~~~~~

Main program:

- src/poke.h
- src/poke.c

Infrastructure for writing poke commands:

- src/pk-cmd.h
- src/pk-cmd.c

Terminal stuff:

- src/pk-term.h

Commands:

- src/pk-def.c
- src/pk-dump.pk
- src/pk-file.c
- src/pk-help.c
- src/pk-info.c
- src/pk-misc.h
- src/pk-set.c
- src/pk-vm.c

Pickles and Libraries
~~~~~~~~~~~~~~~~~~~~~

Standard library:

- src/std.pk

Pickles:

- pickles/elf.pk
- pickles/ctf.pk

Test Suite
~~~~~~~~~~
Target-specific dejagnu configuration:

- testsuite/config/default.exp
- testsuite/config/unix.exp

Poke test drivers:

- testsuite/lib/poke.exp
- testsuite/lib/poke-dg.exp

Compiler test suite:

- testsuite/poke.pkl/pkl.exp
- testsuite/poke.pkl/\*.pk

Compiler test suite (mapping):

- testsuite/poke.map/map.exp
- testsuite/poke.pkl/\*.pk

Standard library test suite:

- testsuite/poke.std/std.exp
- testsuite/poke.std/\*.pk

Tests for Poke commands:

- testsuite/poke.cmd/cmd.exp
- testsuite/poke.cmd/\*.pk

Documentation
~~~~~~~~~~~~~
The Poke book:

- doc/poke.texi

Other Stuff
~~~~~~~~~~~

GDB extensions to better debug poke:

- etc/poke-gdb.scm

Suppression list for memcheck:

- etc/boehm-gc.suppressions

Poke Architecture
-----------------

This figure depicts the overall architecture of Poke::
  
  +----------+
  | compiler |      
  +----------+      +------+
       |            |      |
       v            |      |
  +----------+      |      |
  |   PVM    | <--->|  IO  |
  +----------+      |      |
       ^            |      |
       |            |      |
       v            +------+
  +----------+
  | command  |
  +----------+

The Poke Compiler
-----------------

Compiler Overview
~~~~~~~~~~~~~~~~~

This figure depicts the architecutre of the compiler::
  
      /--------\
      | source |
      \---+----/
          |
          v
  +-----------------+
  |      Parser     |
  +-----------------+
  |  analysis and   |
  | transformation  |
  |     phases      |
  +-----------------+    
  | code generation |
  |      phase      |
  +-----------------+
  | Macro assembler |
  +-----------------+
          |
          v
     /---------\
     | program |
     \---------/

The bison Parser in pkl-tab.y
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The only purpose of the bison parser in pkl-tab.y is to do the
syntactic analysis, build the initial AST, and set the locations of
the AST nodes.

Unfortunately, currently it also does some extra work, due to
limitations in the LARL parser:

- It builds the compile-time environment and register type, variable
  and function declarations.
- It annotates variables with their lexical addresses.
- It links return statements with their containing functions.
- It annotates return statements with he number of lexical frames they
  should pop before exitting the function.

As we shall see below, any further analysis and transformations on the
AST are performed by the compiler phases, which are implemented
elsewhere.  This greatly helps to keep the parser code clean and easy
to read, and also eases changing the syntactic structure of poke
programs.

Compiler Passes and Phases
~~~~~~~~~~~~~~~~~~~~~~~~~~

These are the phases currently implemented in the poke compiler (the
phases marked with a * are optional)::

    [parser]
    --- Front-end pass
    trans1     Transformation phase 1.
    anal1      Analysis phase 1.
    typify1    Type analysis and transformation 1.
    promo      Operand promotion phase.
    trans2     Transformation phase 2.
  * fold       Constant folding.
    typify2    Type analysis and transformation 2.
    trans3     Transformation phase 3.
    anal2      Analysis phase 2.
    --- Middle-end pass
    trans4     Transformation phase 4.
    --- Back-end pass
    analf      Analysis final phase.
    gen        Code generation.

The phases above are organized in several passes:

Pass1
  anal1 typify1 promo trans2 fold typify2 trans3 anal2
Pass2
  trans4
Pass3
  analf gen

Follows a brief but complete description of the tasks performed by
each phase.  Please keep it up to date.

trans1

- Finishes strings by expanding \-sequences, emitting diagnostics if
  an invalid \-sequence is found.

anal1

- Checks that every return statement is linked to a function.
- Checks that no return statement is linked to a void function.

typify1

- Checks that the expression in which a funcall is applied is a
  function, and that the types of the formal parameters mach the types
  of the funcall arguments.
- Checks that void functions are not called in contexts where a value
  is expected.

typify2

- Checks that the type of the expression in a return statement matches
  the return type of its containing function.

trans4

- Reverses the list of actual arguments in function calls, so the code
  generator tackles them in the right (reversed) order, as it is
  expected by the callee.

The Type System
~~~~~~~~~~~~~~~

This section describes the type system implemented in the 'poke'
language.

Type Expressions
................

A *type expression* denotes some particular type.  Type expressions
can be one of:

A *simple type*
  Simple types are types that are not composed of other types.  In
  this discussion we use the following sexp-like notations for them:

  (int N)
    Signed integer of N bits, where 0 < N <= 64.
  (uint N)
    Likewise, but the integer is unsigned.
  string
    NULL-terminated C-like string.
  void
    This is the null type.  Used for several purposes.

A *product*
  Products of two type expressions are used to aggregate types in more
  complex structures, such as lists.  We denote them by using the
  following sexp-like notation:

  (T1 . T2)
    product of the type expressions T1 and T2.

  In order to simplify, we use the same list abbreviation used by Lisp
  in order to denote aggregations of types built with products::

    (T1 . (T2 . (T3 . T4))) -> (T1 T2 T3 T4)
  
  Note that type products are not really valid types by themselves.

An *array type*

A *struct type*
  Type expressions for structs are characterized by many attributes.
  We denote these expressions by using the following sexp-like
  notation.

  (struct PINNED ((L1 N1 T1 C1)...))
     where L1 is the label of the first element: a poke expression
     evaluating to an offset.  N1 is the name of the element, which is
     optional.  T1 is a type expression denoting the type of the
     element.  C1 is a poke expression evaluating to a boolean; it is
     the constraint associated to the element.   Of all these
     attributes, only T1 is mandatory.  PINNED is a boolean indicating
     whether structs having this type are pinnned.

A *function type*
  Type expressions for functions are characterized by a type
  expression denoting the types of it's arguments and the type of the
  value returned by the function.  We denote them using the following
  sexp-like notation:

  (fun T1 T2)
    where T1 is the type of the arguments to the function, and T2 is
    the type of the value returned by the function.

  Usually T1 will be an aggregation of types built as nested
  products.  For example, the type expression for a function that
  takes three 32-bit signed integers and returns a string is::

    (fun ((int 32) (int 32) (int 32)) string)

  If a type expression denotes the type of a function which doesn't
  take any argument, T1 should be 'void'.  Likewise, if the function
  doesn't return a value, T2 should be 'void'.

The Poke Virtual Machine
------------------------

Exception Handling
~~~~~~~~~~~~~~~~~~

Exception types are signed 32-bit integers, and are defined in
src/pkl-rt.pkl.

There are two ways an exception can be raised in the PVM:

- Explicitly, when the instruction 'raise' is executed.
- Implicitly, when some instruction needs to fail.  For example,
  an integer division instruction divides by zero.

In either case, the treatment of a raised exception is the same:

1. Pop an exception handler from the exception handler stack.
2. If the exception handler matches the raised exception type, then
   i. Restore the heights of the main and return stacks.
   ii. Restore the dynamic environment.
   iii. Push the cached exception type to the stack.
   iv. Branch to the exception handler.
3. Repeat.

The default exception handler, which catches "unhandled" exceptions,
is installed by the macro-assembler in src/pkl-asm.c:pkl_asm_new and
src/pkl-asm.c:pkl_asm_finish.  It calls the function
'_pkl_exception_handler', that is defined in the compiler runtime in
src/pkl-rt.pkl.

Debugging Poke
--------------

Building with Debugging support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Configure the sources with --enable-debug.  This will:

1. Use a threaded jitter dispatching model.
2. Build the sources with -O0 -g3 in CFLAGS.

Using GDB extensions
~~~~~~~~~~~~~~~~~~~~

In order to use the GDB pretty-printers and other goodies brought to
you courtesy of the poke hackers, just source the poke-gdb.scm file
from your debugger::

  (gdb) source etc/poke-gdb.scm

Valgrind and Poke
~~~~~~~~~~~~~~~~~

The PVM uses the Boehm conservative garbage collector in order to
manage the memory used by the VM values.  Other parts of poke, such as
the PKL compiler, manage their own memory.

Valgrind gets easily confused by the GCs tampering with the stack, and
emits a lot of spurious warnings.  Fortunately it is possible to tell
memcheck to omit these warnings: the file etc/boehm-gc.suppresions
contains a list of suppresions.

Invoke valgrind with --suppressions=etc/boehm-gc.suppressions.

If despite using the suppressions file you see some spurious warning,
please use::

  $ valgrind --tool=memcheck --gen-suppressions=all --log-file=raw.log


Then process raw.log with the etc/parse-valgrind-suppressions.sh
script, wilcard the result as much as you can, and append the results
to etc/boehm-gc.suppressions.

In order to run the testsuite with valgring, edit lib/poke-dg.exp and
uncomment the lines::

      set VALGRIND "valgrind --quiet --suppressions=${srcdir}/../etc/boehm-gc.suppressions \
                           --tool=memcheck --gen-suppressions=all"

Then run ``make check`` as usual.

Debugging PVM Assembler
~~~~~~~~~~~~~~~~~~~~~~~

Hacking some areas of the compiler, such as the code generator pass,
involves meta-programming PVM assembler.  It is easy to find examples
anywhere in src/pkl-gen.c::

  pkl_asm_insn (pasm, PKL_INSN_ROT);
  pkl_asm_insn (pasm, PKL_INSN_MULLU);
  pkl_asm_insn (pasm, PKL_INSN_NIP2);

Or, alternatively, the code may be written in RAS in some of the .pks
files.  Like::

  .loop:
        bz @type, .endloop      ; ... A B
        mod @type               ; ... A B A%B
        rot                     ; ... B A%B A
        drop                    ; ... B A%B
        ba .loop

Often, a run-time problem becomes apparent while the PVM executes the
generated code.  Typical cases are when a PVM value doesn't contain
what it's supposed to contain, and accessing the wrong boxed value
causes a segmentation fault (if we are lucky) or a non-crashing
invalid memory access (if we are very unlucky.)  Whenever that kind of
crap happens, we find ourselves in the need of debugging the PVM code,
which is a big PITA.

Bad news are: we don't have a PVM debugger (yet).
Good news are: we have a couple of tools that may help.

The first of such tools is the ``prints`` instruction.  This
instructions basically prints in the standard output the string value
on the TOS, and then drops it.  It is a wonderful way to trace PVM
code.

For example, let's say we are trying to find out how many times the
loop above gets executed.  We can install traces like::

        push "XXX entering loop\n"
        prints
  .loop:
        push "XXX in loop\n"
        prints
        mod @type
        rot
        drop
        ba .loop

The other tool is the ``strace`` instruction.  It prints the contents
of the stack (one value per line) from the TOS to it's very beginning.
It is very useful in many situations, like when a loop is composing
values in the stack and something is going banana.  It is also useful
to determine what kind of value is being accessed by a given
instruction.

For example, lets say that we are hunting some segmentation fault.  We
highly suspect the code generated in the first example in this
section, above.  Of the three instructions, ``mullu`` is the only one
that could conceivably generate a segfault, so we add a stack trace
instruction right before it::

  pkl_asm_insn (pasm, PKL_INSN_ROT);
  pkl_asm_insn (pasm, PKL_INSN_STRACE); /* XXX remove me */
  pkl_asm_insn (pasm, PKL_INSN_MULLU);
  pkl_asm_insn (pasm, PKL_INSN_NIP2);

We recompile, re-run, and we find out that the elements at the TOS
when ``mullu`` is executed are a pair of stupid signed integers, which
are not boxed and not what the instruction expects.  Mystery solved.

Future Developments
-------------------

- Allow variable expressions in array initializer indexes.  Something
  like::

    [1,[foo*2]=666]

  this will of course mean that the types of literal arrays won't be
  necessarily be bounded by a constant number of elements.  No bid
  deal.

Local Variables:
mode: rst
End:
