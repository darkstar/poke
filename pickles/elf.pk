/* elf.pk - ELF implementation for GNU poke.  */

/* Copyright (C) 2017 Jose E. Marchesi.  */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* This file contains a PCL (poke command language) description of the
 * ELF (Executable and Linking Format) object file format.  The ELF
 * format is described in the chapter 4 of the SysV ABI.
 *
 * Both ELF32 and ELF64 are supported.
 *
 * In general, we use the same field names used in the C structs
 * documented in the gABI, that are also used in the widely used ELF
 * implementations like in the GNU binutils and also in elfutils.
 * This makes life easier for system hackers who are already familiar
 * with these names.
 */

deftype elf_word = uint32;
deftype elf_sword = int32;
deftype elf_half = uint16;

deftype elf32_addr = uint32;
deftype elf32_off = uint32;
deftype elf32_sword = uint32;

deftype elf64_addr = uint64;
deftype elf64_off = uint64;
deftype elf64_xword = uint64;
deftype elf64_sword = int32;
deftype elf64_sxword = int64;

deftype elf_e_flags =
  bitmask<elf_word> (elf_e_machine mach)
  {
    if (mach == EM_SPARC
        || mach == EM_SPARCV9
        || mach == EM_SPARC32PLUS)
      {
        EF_SPARC_TSO = 0,
        EF_SPARCV9_PSO = 1,
        EF_SPARCV9_RMO = 2,
        EF_SPARCV9_MM = 3,
        EF_SPARC_LEDATA = 0x80_0000
          <doc="Little-endian data.">,
        EF_SPARC_EX_MASK = 0xff_ff00
          <doc="Generic V8+ features.">,
        EF_SPARC_32PLUS = 0x00_0100
          <doc="Generic V8+ features.">,
        EF_SPARC_SUN_US1 = 0x00_0200
          <doc="Sun UltraSPARC1 extensions.">,
        EF_SPARC_HAL_R1 = 0x00_0400
          <doc="HAL R1 extensions.">,
        EF_SPARC_SUN_US3 = 0x00_0800
          <doc="Sun UltraSPARCIII extensions.">
      }
  };

defset elf_class =
  enum
    {
      /* Invalid class.  */
      ELFCLASSNONE = 0x0,
      /* 32-bit object.  */
      ELFCLASS32 = 0x1,
      /* 64-bit object.  */
      ELFCLASS64 = 0x2
    };

deftype elf_ei_class = elf_class<byte>;

deftype elf_ei_data =
  enum<byte>
    {
      ELFDATANONE = 0
        <doc="Invalid data encoding.">,
      
      ELFDATA2LSB = 1
        <doc="2's complement values, with the least significant\n\
              byte occupying the lowest address.">,
      
      ELFDATA2MSB = 2
        <doc="2's complement values, with the most significant\n\
              byte occupying the lowest address.">;
    };

deftype elf_e_type =
  enum<elf_half>
    {
      ET_NONE = 0x0000 <doc="No file type.">,
      ET_REL  = 0x0001 <doc="Relocatable file.">,
      ET_EXEC = 0x0002 <doc="Executable file.">,
      ET_DYN  = 0x0003 <doc="Shared object file.">,
      ET_CORE = 0x0004 <doc="Core file.">,
      
      ET_LOOS = 0xFE00,
      ET_HIOS = 0xFEFF,
      ET_LOPROC = 0xFF00,
      ET_HIPROC = 0xFFFF
    };

/* ELF relocation type.  */

defset elf_r_type =
  enum (elf_e_machine mach)
  {
    /* No reloc.  */
    R_SPARC_NONE = 0,
    /* Direct 8 bit.  */
    R_SPARC_8 = 1,
    /* Direct 16 bit.  */
    R_SPARC_16 = 2,
    /* Direct 32 bit.  */
    R_SPARC_32 = 3,
    /* PC relative 8 bit.  */
    R_SPARC_DISP8 = 4,
    /* PC relative 16 bit.  */
    R_SPARC_DISP16 = 5,
    /* PC relative 32 bit.  */
    R_SPARC_DISP32 = 6,
    /* PC relative 30 bit shifted.  */
    R_SPARC_WDISP30 = 7,
    /* PC relative 22 bit shifted.  */
    R_SPARC_WDISP22 = 8,
    /* High 22 bit.  */
    R_SPARC_HI22 = 9,
    /* Direct 22 bit.  */
    R_SPARC_22 = 10,
    /* Direct 13 bit.  */
    R_SPARC_13 = 11,
    /* Truncated 10 bit.  */
    R_SPARC_LO10 = 12,
    /* Truncated 10 bit GOT entry.  */
    R_SPARC_GOT10 = 13,
    /* 13 bit GOT entry.  */
    R_SPARC_GOT13 = 14,
    /* 22 bit GOT entry shifted.  */
    R_SPARC_GOT22 = 15,
    /* PC relative 10 bit truncated.  */
    R_SPARC_PC10 = 16,
    /* PC relative 22 bit shifted.  */
    R_SPARC_PC22 = 17,
    /* 30 bit PC relative PLT address.  */
    R_SPARC_WPLT30 = 18,
    /* Copy symbol at runtime.  */
    R_SPARC_COPY = 19,
    /* Create GOT entry.  */
    R_SPARC_GLOB_DAT = 20,
    /* Create PLT entry.  */
    R_SPARC_JMP_SLOT = 21,
    /* Adjust by program base.  */
    R_SPARC_RELATIVE = 22,
    /* Direct 32 bit unaligned.  */
    R_SPARC_UA32 = 23,
    /* Direct 32 bit ref to PLT entry.  */
    R_SPARC_PLT32 = 24,
    /* High 22 bit PLT entry.  */
    R_SPARC_HIPLT22 = 25,
    /* Truncated 10 bit PLT entry.  */
    R_SPARC_LOPLT10 = 26,
    /* PC rel 32 bit ref to PLT entry.  */
    R_SPARC_PCPLT32 = 27,
    /* PC rel high 22 bit PLT entry.  */
    R_SPARC_PCPLT22 = 28,
    /* PC rel trunc 10 bit PLT entry.  */
    R_SPARC_PCPLT10 = 29,
    /* Direct 10 bit.  */
    R_SPARC_10 = 30,
    /* Direct 11 bit.  */
    R_SPARC_11 = 31,
    /* Direct 64 bit.  */
    R_SPARC_64 = 32,
    /* 10bit with secondary 13bit addend.  */
    R_SPARC_OLO10 = 33,
    /* Top 22 bits of direct 64 bit.  */
    R_SPARC_HH22 = 34,
    /* High middle 10 bits of ....  */
    R_SPARC_HM10 = 35,
    /* Low middle 22 bits of .... */
    R_SPARC_LM22 = 36,
    /* Top 22 bits of pc rel 64 bit.  */
    R_SPARC_PC_HH22 = 37,
    /* High middle 10 bit of ....  */
    R_SPARC_PC_HM10 = 38,
    /* Low miggle 22 bits of ....  */
    R_SPARC_PC_LM22 = 39,
    /* PC relative 16 bit shifted.  */
    R_SPARC_WDISP16 = 40,
    /* PC relative 19 bit shifted.  */
    R_SPARC_WDISP19 = 41,
    /* Was part of v9 ABI but was removed.  */
    R_SPARC_GLOB_JM = 42,
    /* Direct 7 bit.  */
    R_SPARC_7 = 43,
    /* Direct 5 bit.  */
    R_SPARC_5 = 44,
    /* Direct 6 bit.  */
    R_SPARC_6 = 45,
    /* PC relative 64 bit.  */
    R_SPARC_DISP64 = 46,
    /* Direct 64 bit ref to PLT entry.  */
    R_SPARC_PLT64 = 47,
    /* High 22 bit complemented.  */
    R_SPARC_HIX22 = 48,
    /* Truncated 11 bit complemented.  */
    R_SPARC_LOX10 = 49,
    /* Direct high 12 of 44 bit.  */
    R_SPARC_H44 = 50,
    /* Direct mid 22 of 44 bit.  */
    R_SPARC_M44 = 51,
    /* Direct low 10 of 44 bit.  */
    R_SPARC_L44 = 52,
    /* Global register usage.  */
    R_SPARC_REGISTE = 53,
    /* Direct 64 bit unaligned.  */
    R_SPARC_UA64 = 54,
    /* Direct 16 bit unaligned.  */
    R_SPARC_UA16 = 55,
    R_SPARC_TLS_GD_HI2 = 56,
    R_SPARC_TLS_GD_LO1 = 57,
    R_SPARC_TLS_GD_AD = 58,
    R_SPARC_TLS_GD_CAL = 59,
    R_SPARC_TLS_LDM_HI2 = 60,
    R_SPARC_TLS_LDM_LO1 = 61,
    R_SPARC_TLS_LDM_AD = 62,
    R_SPARC_TLS_LDM_CAL = 63,
    R_SPARC_TLS_LDO_HIX2 = 64,
    R_SPARC_TLS_LDO_LOX1 = 65,
    R_SPARC_TLS_LDO_AD = 66,
    R_SPARC_TLS_IE_HI2 = 67,
    R_SPARC_TLS_IE_LO1 = 68,
    R_SPARC_TLS_IE_L = 69,
    R_SPARC_TLS_IE_LD = 70,
    R_SPARC_TLS_IE_AD = 71,
    R_SPARC_TLS_LE_HIX2 = 72,
    R_SPARC_TLS_LE_LOX1 = 73,
    R_SPARC_TLS_DTPMOD3 = 74,
    R_SPARC_TLS_DTPMOD6 = 75,
    R_SPARC_TLS_DTPOFF3 = 76,
    R_SPARC_TLS_DTPOFF6 = 77,
    R_SPARC_TLS_TPOFF3 = 78,
    R_SPARC_TLS_TPOFF6 = 79,
    R_SPARC_GOTDATA_HIX2 = 80,
    R_SPARC_GOTDATA_LOX1 = 81,
    R_SPARC_GOTDATA_OP_HIX2 = 82,
    R_SPARC_GOTDATA_OP_LOX1 = 83,
    R_SPARC_GOTDATA_O = 84,
    R_SPARC_H34 = 85,
    R_SPARC_SIZE32 = 86,
    R_SPARC_SIZE64 = 87,
    R_SPARC_WDISP10 = 88,
    R_SPARC_JMP_IRE = 248,
    R_SPARC_IRELATIV = 249,
    R_SPARC_GNU_VTINHERI = 250,
    R_SPARC_GNU_VTENTR = 251,
    R_SPARC_REV32 = 252,
  } : (mach == EM_SPARC || mach == EM_SPARCV9
       || mach == EM_SPARC32PLUS);

};

deftype elf_e_machine =
  enum<elf_half>
    {
      EM_NONE  = 0, /* No machine.  */
      EM_M32   = 1, /* AT&T WE 32100.  */
      EM_SPARC = 2, /* SPARC.  */
      EM_386   = 3, /* Intel 80386.  */
      EM_68K   = 4, /* Motorola 68000.  */
      EM_88K   = 5, /* Motorola 88000.  */
      EM_IAMCU = 6, /* Intel MCU.  */
      EM_860   = 7, /* Intel 80860.  */
      EM_MIPS  = 8, /* MIPS I Architecture.  */
      EM_S370  = 9, /* IBM System/370 Processor.  */
      EM_MIPS_RS3_LE = 10, /* MIPS RS3000 Little-endian.  */
      /* 11-14 are reserved. */
      EM_PARISC = 15, /* Hewlett-Packard PA-RISC.  */
      /* 16 is reserved.  */
      EM_VPP500 = 1, /* Fujitsu VPP500.  */
      EM_SPARC32PLUS = 18, /* 32-bit on V9 SPARC.  */
      EM_960 = 19, /* Intel 80960.  */
      EM_PPC = 20, /* PowerPC.  */
      EM_PPC64 = 21, /* 64-bit PowerPC.  */
      EM_S390 = 22, /* IBM System/390 Processor.  */
      EM_SPU = 23, /* IBM SPU/SPC.  */
      /* 24-35 are reserved.  */
      EM_V800 = 36, /* NEC V800.  */
      EM_FR20 = 37, /* Fujitsu FR20.  */
      EM_RH32 = 38, /* TRW RH-32.  */
      EM_RCE = 39, /* Motorola RCE.  */
      EM_ARM = 40, /* ARM 32-bit architecture (AARCH32).  */
      EM_ALPHA = 41, /* Digital Alpha.  */
      EM_SH = 42, /* Hitachi SH.  */
      EM_SPARCV9 = 43, /* SPARC Version 9.  */
      EM_TRICORE = 44, /* Siemens TriCore embedded processor.  */
      EM_ARC = 45, /* Argonaut RISC Core, Argonaut Technologies
                      Inc..  */
      EM_H8_300 = 46, /* Hitachi H8/300.  */
      EM_H8_300H = 47, /* Hitachi H8/300H.  */
      EM_H8S = 48, /* Hitachi H8S.  */
      EM_H8_500 = 49, /* Hitachi H8/500.  */
      EM_IA_64 = 50, /* Intel IA-64 processor architecture.  */
      EM_MIPS_X = 51, /* Stanford MIPS-X.  */
      EM_COLDFIRE = 52, /* Motorola ColdFire.  */
      EM_68HC12 = 53, /* Motorola M68HC12.  */
      EM_MMA = 54, /* Fujitsu MMA Multimedia Accelerator.  */
      EM_PCP = 55, /* Siemens PCP.  */
      EM_NCPU = 56, /* Sony nCPU embedded RISC processor.  */
      EM_NDR1 = 57, /* Denso NDR1 microprocessor.  */
      EM_STARCORE = 58, /* Motorola Star*Core processor.  */
      EM_ME16 = 59, /* Toyota ME16 processor.  */
      EM_ST100 = 60, /* STMicroelectronics ST100 processor.  */
      EM_TINYJ = 61, /* Advanced Logic Corp. TinyJ embedded processor
                        family.  */
      EM_X86_64 = 62, /* AMD x86-64 architecture.  */
      EM_PDSP = 63, /* Sony DSP Processor.  */
      EM_PDP10 = 64, /* Digital Equipment Corp. PDP-10.  */
      EM_PDP11 = 65, /* Digital Equipment Corp. PDP-11.  */
      EM_FX66 = 66, /* Siemens FX66 microcontroller.  */
      EM_ST9PLUS = 67, /* STMicroelectronics ST9+ 8/16 bit
                          microcontroller.  */
      EM_ST7 = 68, /* STMicroelectronics ST7 8-bit
                       microcontroller.  */
      EM_68HC16 = 69, /* Motorola MC68HC16 Microcontroller.  */
      EM_68HC11 = 70, /* Motorola MC68HC11 Microcontroller.  */
      EM_68HC08 = 71, /* Motorola MC68HC08 Microcontroller.  */
      EM_68HC05 = 72, /* Motorola MC68HC05 Microcontroller.  */
      EM_SVX = 73, /* Silicon Graphics SVx.  */
      EM_ST19 = 74, /* STMicroelectronics ST19 8-bit
                       microcontroller.  */
      EM_VAX = 75, /* Digital VAX.  */
      EM_CRIS = 76, /* Axis Communications 32-bit embedded
                       processor.  */
      EM_JAVELIN = 77, /* Infineon Technologies 32-bit embedded
                          processor.  */
      EM_FIREPATH = 78, /* Element 14 64-bit DSP Processor.  */
      EM_ZSP = 79, /* LSI Logic 16-bit DSP Processor.  */
      EM_MMIX = 80, /* Donald Knuth's educational 64-bit
                       processor.  */
      EM_HUANY = 81, /* Harvard University machine-independent object
                        files.  */
      EM_PRISM = 82, /* SiTera Prism.  */
      EM_AVR = 83, /* Atmel AVR 8-bit microcontroller.  */
      EM_FR30 = 84, /* Fujitsu FR30.  */
      EM_D10V = 85, /* Mitsubishi D10V.  */
      EM_D30V = 86, /* Mitsubishi D30V.  */
      EM_V850 = 87, /* NEC v850.  */
      EM_M32R = 88, /* Mitsubishi M32R.  */
      EM_MN10300 = 89, /* Matsushita MN10300.  */
      EM_MN10200 = 90, /* Matsushita MN10200.  */
      EM_PJ = 91, /* picoJava.  */
      EM_OPENRISC = 92, /* OpenRISC 32-bit embedded processor.  */
      EM_ARC_COMPACT = 93, /* ARC International ARCompact processor.  */
      EM_XTENSA = 94, /* Tensilica Xtensa Architecture.  */
      EM_VIDEOCORE = 95, /* Alphamosaic VideoCore processor.  */
      EM_TMM_GPP = 96, /* Thompson Multimedia General Purpose
                          Processor.  */
      EM_NS32K = 97, /* National Semiconductor 32000 series.  */
      EM_TPC = 98, /* Tenor Network TPC processor.  */
      EM_SNP1K = 99, /* Trebia SNP 1000 processor.  */
      EM_ST200 = 100, /* STMicroelectronics (www.st.com) ST200
                         microcontroller.  */
      EM_IP2K = 101, /* Ubicom IP2xxx microcontroller family.  */
      EM_MAX = 102, /* MAX Processor.  */
      EM_CR = 103, /* National Semiconductor CompactRISC
                      microprocessor.  */
      EM_F2MC16 = 104, /* Fujitsu F2MC16.  */
      EM_MSP430 = 105, /* Texas Instruments embedded microcontroller
                          msp430.  */
      EM_BLACKFIN = 106, /* Analog Devices Blackfin (DSP)
                            processor.  */
      EM_SE_C33 = 107, /* S1C33 Family of Seiko Epson processors.  */
      EM_SEP = 108, /* Sharp embedded microprocessor.  */
      EM_ARCA = 109, /* Arca RISC Microprocessor.  */
      EM_UNICORE = 110, /*  Microprocessor series from
                            PKU-Unity. .  */
      EM_EXCESS = 111, /* eXcess: 16/32/64-bit configurable embedded
                          CPU.  */
      EM_DXP = 112, /* Icera Semiconductor Inc. Deep Execution
                       Processor.  */
      EM_ALTERA_NIOS2 = 113, /* Altera Nios II soft-core processor.  */
      EM_CRX = 114, /* National Semiconductor CompactRISC CRX
                       microprocessor.  */
      EM_XGATE = 115, /* Motorola XGATE embedded processor.  */
      EM_C166 = 116, /* Infineon C16x/XC16x processor.  */
      EM_M16C = 117, /* Renesas M16C series microprocessors.  */
      EM_DSPIC30F = 118, /* Microchip Technology dsPIC30F Digital
                            Signal Controller.  */
      EM_CE = 119, /* Freescale Communication Engine RISC core.  */
      EM_M32C = 120, /* Renesas M32C series microprocessors.  */
      /* 121-130 are reserved.  */
      EM_TSK3000 = 131, /* Altium TSK3000 co,re.  */
      EM_RS08 = 132, /* Freescale RS08 embedded processor.  */
      EM_SHARC = 133, /* Analog Devices SHARC family of 32-bit DSP
                         processors.  */
      EM_ECOG2 = 134, /* Cyan Technology eCOG2 microprocessor.  */
      EM_SCORE7 = 135, /* Sunplus S+core7 RISC processor.  */
      EM_DSP24 = 136, /* New Japan Radio (NJR) 24-bit DSP Processor.  */
      EM_VIDEOCORE3 = 137, /* Broadcom VideoCore III processor.  */
      EM_LATTICEMICO32 = 138, /* RISC processor for Lattice FPGA
                                 architecture. .  */
      EM_SE_C17 = 139, /* Seiko Epson C17 family.  */
      EM_TI_C6000 = 140, /* The Texas Instruments TMS320C6000 DSP
                            family.  */
      EM_TI_C2000 = 141, /* The Texas Instruments TMS320C2000 DSP
                            family.  */
      EM_TI_C5500 = 142, /* The Texas Instruments TMS320C55x DSP
                            family.  */
      EM_TI_ARP32 = 143, /* Texas Instruments Application Specific
                            RISC Processor, 32bit fetch.  */
      EM_TI_PRU = 144, /* Texas Instruments Programmable Realtime
                          Unit.  */
      /* 145-159 are reserved.  */
      EM_MMDSP_PLUS = 160, /* STMicroelectronics 64bit VLIW Data
                              Signal Processor.  */
      EM_CYPRESS_M8C = 161, /* Cypress M8C microprocessor.  */
      EM_R32C = 162, /* Renesas R32C series microprocessors.  */
      EM_TRIMEDIA = 163, /* NXP Semiconductors TriMedia architecture
                            family.  */
      EM_QDSP6 = 164, /* QUALCOMM DSP6 Processor.  */
      EM_8051 = 165, /* Intel 8051 and variants.  */
      EM_STXP7X = 166, /* STMicroelectronics STxP7x family of
                          configurable and extensible RISC
                          processors.  */
      EM_NDS32 = 167, /* Andes Technology compact code size embedded
                         RISC processor family.  */
      EM_ECOG1 = 168, /* Cyan Technology eCOG1X family.  */
      EM_ECOG1X = 168, /* Cyan Technology eCOG1X family.  */
      EM_MAXQ30 = 169, /* Dallas Semiconductor MAXQ30 Core
                          Micro-controllers.  */
      EM_XIMO16 = 170, /* New Japan Radio (NJR) 16-bit DSP
                          Processor.  */
      EM_MANIK = 171, /* M2000 Reconfigurable RISC Microprocessor.  */
      EM_CRAYNV2 = 172, /* Cray Inc. NV2 vector architecture.  */
      EM_RX = 173, /* Renesas RX family.  */
      EM_METAG = 174, /* Imagination Technologies META processor
                         architecture.  */
      EM_MCST_ELBRUS = 175, /* MCST Elbrus general purpose hardware
                               architecture.  */
      EM_ECOG16 = 176, /* Cyan Technology eCOG16 family.  */
      EM_CR16 = 177, /* National Semiconductor CompactRISC CR16 16-bit
                        microprocessor.  */
      EM_ETPU = 178, /* Freescale Extended Time Processing Unit.  */
      EM_SLE9X = 179, /* Infineon Technologies SLE9X core.  */
      EM_L10M = 180, /* Intel L10M.  */
      EM_K10M = 181, /* Intel K10M.  */
      /* 182 is reserved.  */
      EM_AARCH64 = 183, /* ARM 64-bit architecture (AARCH64).  */
      /* 184 is reserved.  */
      EM_AVR32 = 185, /* Atmel Corporation 32-bit microprocessor
                         family.  */
      EM_STM8 = 186, /* STMicroeletronics STM8 8-bit
                        microcontroller.  */
      EM_TILE64 = 187, /* Tilera TILE64 multicore architecture
                          family.  */
      EM_TILEPRO = 188, /* Tilera TILEPro multicore architecture
                           family.  */
      EM_MICROBLAZE = 189, /* Xilinx MicroBlaze 32-bit RISC soft
                              processor core.  */
      EM_CUDA = 190, /* NVIDIA CUDA architecture.  */
      EM_TILEGX = 191, /* Tilera TILE-Gx multicore architecture
                          family.  */
      EM_CLOUDSHIELD = 192, /* CloudShield architecture family.  */
      EM_COREA_1ST = 193, /* KIPO-KAIST Core-A 1st generation
                             processor family.  */
      EM_COREA_2ND = 194, /* KIPO-KAIST Core-A 2nd generation
                             processor family.  */
      EM_ARC_COMPACT2 = 195, /* Synopsys ARCompact V2.  */
      EM_OPEN8 = 196, /* Open8 8-bit RISC soft processor core.  */
      EM_RL78 = 197, /* Renesas RL78 family.  */
      EM_VIDEOCORE5 = 198, /* Broadcom VideoCore V processor.  */
      EM_78KOR = 199, /* Renesas 78KOR family.  */
      EM_56800EX = 200, /* Freescale 56800EX Digital Signal Controller
                           (DSC).  */
      EM_BA1 = 201, /* Beyond BA1 CPU architecture.  */
      EM_BA2 = 202, /* Beyond BA2 CPU architecture.  */
      EM_XCORE = 203, /* XMOS xCORE processor family.  */
      EM_MCHP_PIC = 204, /* Microchip 8-bit PIC(r) family.  */
      EM_INTEL205 = 205, /* Reserved by Intel.  */
      EM_INTEL206 = 206, /* Reserved by Intel.  */
      EM_INTEL207 = 207, /* Reserved by Intel.  */
      EM_INTEL208 = 208, /* Reserved by Intel.  */
      EM_INTEL209 = 209, /* Reserved by Intel.  */
      EM_KM32 = 210, /* KM211 KM32 32-bit processor.  */
      EM_KMX32 = 211, /* KM211 KMX32 32-bit processor.  */
      EM_KMX16 = 212, /* KM211 KMX16 16-bit processor.  */
      EM_KMX8 = 213, /* KM211 KMX8 8-bit processor.  */
      EM_KVARC = 214, /* KM211 KVARC processor.  */
      EM_CDP = 215, /* Paneve CDP architecture family.  */
      EM_COGE = 216, /* Cognitive Smart Memory Processor.  */
      EM_COOL = 217, /* Bluechip Systems CoolEngine.  */
      EM_NORC = 218, /* Nanoradio Optimized RISC.  */
      EM_CSR_KALIMBA  = 219, /* CSR Kalimba architecture family.  */
      EM_Z80  = 220, /* Zilog Z80.  */
      EM_VISIUM  = 221, /* Controls and Data Services VISIUMcore
                           processor.  */
      EM_FT32  = 222, /* FTDI Chip FT32 high performance 32-bit RISC
                         architecture.  */
      EM_MOXIE = 223, /* Moxie processor family.  */
      EM_AMDGPU = 224, /* AMD GPU architecture.  */
      /* 225 - 242 are reserved.  */
      EM_RISCV = 243, /* RISC-V.  */
      EM_LANAI = 244, /* Lanai processor.  */
      EM_CEVA = 245, /* CEVA Processor Architecture Family.  */
      EM_CEVA_X2 = 246, /* CEVA X2 Processor Family.  */
      EM_BPF = 247, /* Linux BPF â€“ in-kernel virtual machine.  */
      EM_GRAPHCORE_IPU = 248, /* Graphcore Intelligent Processing
                                 Unit.  */
      EM_IMG1 = 249, /* Imagination Technologies.  */
      EM_NFP = 250, /* Netronome Flow Processor (NFP) */
    };

deftype elf_e_version =
  enum<elf_word>
  {
    EV_NONE = 0, /* Invalid version.  */
    EV_CURRENT = 1 /* Current version.  */
  };

deftype elf_sh_type =
  enum<elf_word>
  {
    /* Inactive section.  */
    SHT_NULL = 0,
    /* Section holds information defined by the program whose format
       and meaning are determined solely by the program.  */
    SHT_PROGBITS = 1,
    /* Section holds a symbol table.  */
    SHT_SYMTAB = 2,
    /* Section holds a string table.  */
    SHT_STRTAB = 3,
    /* Section holds relocation entries with explicit addends.  */
    SHT_RELA = 4,
    /* Section holds a symbol hash table.  */
    SHT_HASH = 5,
    /* Section holds the dynamic section.  */
    SHT_DYNAMIC = 6,
    /* Section holds information that marks the file in some way.  */
    SHT_NOTE = 7,
    /* Section occupies no space in the file but otherwise resembles
       SHT_PROGBITS.  */
    SHT_NOBITS = 8,
    /* Section contains relocation entries without explicit
       addends.  */
    SHT_REL = 9,
    /* Section reserved with undefined semantics.  */
    SHT_SHLIB = 10,
    /* Section holds a symbol table.  */
    SHT_DYNSYM = 11,

    /* Entries 12 and 13 are unused.  */

    /* Section contains an array of pointers to initialization
       functions.  */
    SHT_INIT_ARRAY = 14,
    /* Section contains an array of pointers to termination
       functions.  */
    SHT_FINI_ARRAY = 15,
    /* Section contains an array of pointers to functions that are
       invoked before all other initialization functions.  */
    SHT_PREINIT_ARRAY = 16,
    /* Section defines a section group.  */
    SHT_GROUP = 17,
    /* Section is associated with a symbol table section.  */
    SHT_SYMTAB_SHNDX = 18,
    
    SHT_LOOS = 0x60000000,
    SHT_HIOS = 0x6fffffff,
    SHT_LOPROC = 0x70000000,
    SHT_HIPROC = 0x7fffffff,
    SHT_LOUSER = 0x80000000,
    SHT_HIUSER = 0xffffffff
  };

defset elf_sh_flags =
  bitmask
  {
    /* Section contains data that should be writable during process
       execution.  */
    SHF_WRITE = 0x1,
    /* Section occupies memory during process execution.  */
    SHF_ALLOC = 0x2,
    /* Section contains executable machine instructions.  */
    SHF_EXECINSTR = 0x4,
    /* The data in the section may be merged to eliminate
       duplication.  */
    SHF_MERGE = 0x10,
    /* The data elements in the section consist of null-terminated
       character strings.  */
    SHF_STRINGS = 0x20,
    /* The sh_info field of this section header holds a section header
       table index.  */
    SHF_INFO_LINK = 0x40,
    /* Special ordering requirements for link editors.  */
    SHF_LINK_ORDER = 0x80,
    /* This section requires special OS-specific processing, beyond
       standard linking rules, to avoid incorrect behavior.  */
    SHF_OS_NONCONFORMING = 0x100,
    /* This section is a member of a section group.  */
    SHF_GROUP = 0x200,
    /* This section holds thread-local storage.  */
    SHF_TLS = 0x400,
    /* This section holds compressed data.  */
    SHF_COMPRESSED = 0x800,

    SHF_MASKOS = 0x0ff00000,
    SHF_MASKPROC = 0xf0000000
  };

deftype elf_p_type =
  enum<elf_word>
  {
    /* Array element is unused.  */
    PT_NULL = 0,
    /* Loadable segment.  */
    PT_LOAD = 1,
    /* Dynamic linking information.  */
    PT_DYNAMIC = 2,
    /* Location and size of a null-terminated path name to invoke as
       an interpreter.  */
    PT_INTERP = 3,
    /* Location and size of auxiliary information.  */
    PT_NOTE = 4,
    /* Reserved.  Unspecified semantics.  */
    PT_SHLIB = 5,
    /* Location and size of the program header table itself.  */
    PT_PHDR = 6,
    /* Thread-local storage template.  */
    PT_TLS = 7,
    
    PT_LOOS = 0x60000000,
    PT_HIOS = 0x6fffffff,
    PT_LOPROC = 0x70000000,
    PT_HIPROC = 0x7fffffff
  };

deftype elf_p_flags =
  bitmask<elf_word>
  {
    PF_X = 0x1, /* Segment is executable.  */
    PF_W = 0x2, /* Segment is writeable.  */
    PF_R = 0x4, /* Segment is readable.  */
    
    PF_MASKOS = 0xff00000,
    PF_MASKPROC = 0xf0000000
  };

deftype elf_ch_type =
  enum<elf_word>
  {
    ELFCOMPRESS_ZLIB = 1, /* Section is compressed with ZLIB.  */

    ELFCOMPRESS_LOOS = 0x60000000,
    ELFCOMPRESS_HIOS = 0x6fffffff,
    ELFCOMPRESS_LOPROC = 0x70000000,
    ELFCOMPRESS_HIPROC = 0x7fffffff
  };

defset elf_sym_binding =
  enum
    {
      /* Local symbols are not visible outside the object file
         containing their definition.  Local symbols of the same name
         exist in multiple files without interfering with each
         other.  */
      STB_LOCAL = 0,
      /* Global symbols are visible to all object files being
         combined.  One file's definition of a global symbol will
         satisfy another file's undefined reference to the same global
         symbol.  */
      STB_GLOBAL = 1,
      /* Weak symbols resemble global symbols, but their definitions
         have lower precedence.  */
      STB_WEAK = 2,

      STB_LOOS = 10,
      STB_HIOS = 12,
      STB_LOPROC = 13,
      STB_HIPROC = 15
    };

defset elf_st_type =
  enum (elf_e_machine mach)
    {
      /* The symbol's type is not specified.  */
      STT_NOTYPE = 0,
      /* The symbol is associated with a data object, such as a
         variable, an array, and so on.  */
      STT_OBJECT = 1,
      /* The symbol is associated with a function or other executable
         code.  */
      STT_FUNC = 2,
      /* The symbol is associated with a section.  Symbol table
         entries of this type exist primarily for relocation and
         normally have STB_LOCAL binding.  */
      STT_SECTION = 3,
      /* Conventionally, the symbol's name gives the name of the
         source file associated with the object file.  A file symbol
         has STB_LOCAL binding, its section index is SHN_ABS and it
         precedes the other STB_LOCAL symbols for the file, if it is
         present.  */
      STT_FILE = 4,
      /* This symbol labels an uninitialized common block.  */
      STT_COMMON = 5,
      /* The symbol specifies a Thread-Local Storage entity.  When
         defined, it gives the assigned offset for the symbol, not the
         actual address.  */
      STT_TLS = 6,

      STT_LOOS = 10,
      STT_HIOS = 12,
      STT_LOPROC = 13,

      /* XXX
         if (mach == EM_SPARCV9 || mach == EM_SPARC32PLUS)
         {
          STT_SPARC_REGISTER = 13,
        }
      */
    
      STT_HIPROC = 15
};

defset elf_sym_visibility =
  enum
    {
      /* The visibility of this symbol is specified by the symbol's
         binding type.  That is, global and weak symbols are visible
         outside of their defining component (executable file or
         shared object).  Local symbols are hidden.  Global and weak
         symbols area also preemptable, taht is, they may be preempted
         by definitions of the same name in another component.  */
      STV_DEFAULT = 0,
      /* The visibility of this symbol is defined by processor
         supplements, to further constrain hidden symbols.  */
      STV_INTERNAL = 1,
      /* This symbol is not visible to other components.  */
      STV_HIDDEN = 2,
      /* This symbol is visible in other components but not
         preemptable, meaning that any reference to such a symbol from
         within the defining component must be resolved to the
         definition in that component, even if there is a definition
         in another component that would preempt by the default
         rules.  */
      STV_PROTECTED = 3
    };

defset elf_d_tag_flag =
  bitmask
  {
    /* This flag signifies that the object being loaded may make
       reference to the $ORIGIN substitution string.  */
    DF_ORIGIN = 0x1,
    /* If this flag is set in a shared object library, the dynamic
       linker's symbol resolution algorithm for references within the
       library is changed.  Instead of starting a symbol search with
       the executable file, the dynamic linker starts from the shared
       object itself.  If the shared object fails to supply the
       referened symbol, the dynamic linker then searches the
       executable file and other shared objects as usual.  */
    DF_SYMBOLIC = 0x2,
    /* If this flag is not set, no relocation entry should cause a
       modification to a non-writable segment, as specified by the
       segment permissions in the program header table.  If this flag
       is set, one or more relocation entries might request
       modifications to a non-writable segment, and the dynamic linker
       can prepare accordingly.  */
    DF_TEXTREL = 0x4,
    /* If set in a shared object or executable, this flag instructs
       the dynamic linker to process all relocations for the object
       containing this entry before transferring control to the
       program.  */
    DF_BIND_NOW = 0x8,
    /* If set in a shared object or executable, this flag instructs
       the dynamic linker to reject attempts to load this file
       dynamically.  */
    DF_STATIC_TLS = 0x10
  };

deftype elf_group_flags =
  bitmask<elf_word>
  {
    GRP_COMDAT = 0x0000_0001, /* COMDAT group.  */
    GRP_MASKOS = 0x0ff0_0000,
    GRP_MASKPROC = 0xf000_0000
  };

defset elf_d_tag =
  enum (elf_e_machine mach)
    {
      /* Tags the end of the dynamic array.  */
      DT_NULL = 0,
      /* d_val holds the string table offset of a null-terminated
         string, giving the name of a needed library.  The dynamic
         array may.  contain multiple entries with this type.  */
      DT_NEEDED = 1,
      /* d_val holds the total size, in bytes, of the relocation
         entries associated with the procedure linkage table.  If an
         entry of type DT_JMPREL is present, a DT_PLTRELSZ must
         accompany it.  */
      DT_PLTRELSZ = 2,
      /* d_ptr holds an address associated with the procedure linkage
         table and/or the global offset table.  */
      DT_PLTGOT = 3,
      /* d_ptr holds the address of the symbol hash table.  This hash
         table refers to the symbol table referenced by the DT_SYMTAB
         element.  */
      DT_HASH = 4,
      /* d_ptr holds the address of the string table.  Symbol names,
         library names, and other strings reside in this table.  */
      DT_STRTAB = 5,
      /* d_ptr holds the address of the symbol table.  */
      DT_SYMTAB = 6,
      /* d_ptr holds the address of a relocation table.  Entries in
         the table have explicit addends.  An object file may have
         multiple relocation sections.  If this element is present,
         the dynamic vector must also have DT_RELASZ and DT_RELAENT
         elements.  */
      DT_RELA = 7,
      /* d_val holds the total size, in bytes, of the DT_RELA
         relocation entry.  */
      DT_RELASZ = 8,
      /* d_val holds the size, in bytes, of the DT_RELA relocation
         entry.  */
      DT_RELAENT = 9,
      /* d_val holds the size, in bytes, of the string table.  */
      DT_STRSZ = 10,
      /* d_val holds the size, in bytes, of a symbol table entry.  */
      DT_SYMENT = 11,
      /* d_ptr holds the addresss of the initialization function.  */
      DT_INIT = 12,
      /* d_ptr holds the address of the finalization function.  */
      DT_FINI = 13,
      /* d_val holds the string table offset of a null-terminated
         string, giving the name of the shared object.  The offset is
         an index into the table recorded in the DT_STRTAB entry.  */
      DT_SONAME = 14,
      /* d_val holds the string table offset of a null-terminated
         search library search path string.  The offset is an index
         into the table recorded in the DT_STRTAB entry.  This entry
         is at level 2.  Its use has been superseded by
         DT_RUNPATH.  */
      DT_RPATH = 15,
      /* This element's presence in a shared object library alters the
         dynamic linker's symbol resolution algorithm for references
         within the library.  */
      DT_SYMBOLIC = 16,
      /* d_ptr holds the address of a relocation table containing rela
         relocations.  If this element is present, the dynamic
         structure must also have DT_RELSZ and DT_RELENT elements.  */
      DT_REL = 17,
      /* d_val holds the total size, in bytes, of the DT_REL
         relocation table.  */
      DT_RELSZ = 18,
      /* d_val holds the size, in bytes, of the DT_REL relocation
         entry.  */
      DT_RELENT = 19,
      /* d_val specifies the type of relocation entry to which the
         procedure linkage table refers: DT_REL or DT_RELA.  */
      DT_PLTREL = 20,
      /* This tag is used for debugging.  Its contents are not
         specified for the ABI.  */
      DT_DEBUG = 21,
      /* This tag's absence signifies that no relocation entry should
         cause a modification to a non-writable segment, as specified
         by the segment permissions in the program header table.  If
         this tag is present, one or more relocation entries might
         request modifications to a non-writable segement, and the
         dynamic linker can prepare accordingly.  This entry is at
         level 2.  Its use has been superseded by the DF_TEXTREL
         flag.  */
      DT_TEXTREL = 22,
      /* d_ptr holds the address of relocation entries associated
         solely with the procedure linkage table.  If this tag is
         present, the related entries of types DT_PLTRELSZ and
         DT_PLTREL must also be present.  */
      DT_JMPREL = 23,
      /* If present, this tag instructs the dynamic linker to process
         all relocations for the object containing this entry before
         transferring control to the program.  */
      DT_BIND_NOW = 24,
      /* d_ptr holds the address of the array of pointers to
         initialization functions.  */
      DT_INIT_ARRAY = 25,
      /* d_ptr holds the address of the array of pointers to
         finalization functions.  */
      DT_FINI_ARRAY = 26,
      /* d_val holds the size in bytes of the array of initialization
         functions pointed to by the DT_INIT_ARRAY entry.  If an
         object has a DT_INIT_ARRAY entry, it must also have a
         DT_INIT_ARRAYSZ entry.  */
      DT_INIT_ARRAYSZ = 27,
      /* d_val holds the size in bytes of the array of termination
         functions pointed to by the DT_FINI_ARRAY entry.  If an
         object has a DT_fINI_ARRAY entry, it must also have a
         DT_FINI_ARRAYSZ entry.  */
      DT_FINI_ARRAYSZ = 28,
      /* d_val holds the string table offset of a null-terminated
         library search path string.  The offset is an index into the
         table recorded in the DT_STRTAB entry.  */
      DT_RUNPATH = 29,
      /* d_val holds flag values specific to the object being
         loaded.  */
      DT_FLAGS = 30,
      DT_ENCODING = 32,
      /* d_ptr holds the address of the array of pointers to
         pre-initialization functions.  */
      DT_PREINIT_ARRAY = 32,
      /* d_val holds the size in bytes of the array of
         pre-initialization functions pointed to by the
         DT_PREINIT_ARRAY entry.  */
      DT_PREINIT_ARRAYSZ = 33,
      /* d_ptr holds the address of the SHT_SYMTAB_SHNDX section
         associated with the dynamic symbol table referenced by the
         DT_SYMTAB element.  */
      DT_SYMTAB_SHNDX = 34,
    
      DT_LOOS = 0x6000_000d,
      DT_HIOS = 0x6fff_f000,
      DT_LOPROC = 0x7000_0000,

      /* XXX
      if (mach == EM_SPARCV9 || mach == EM_SPARC32PLUS)
        {
          DT_SPARC_REGISTER = 0x7000_0001,
        }
      */
    
      DT_HIPROC = 0x7fff_ffff
    };

/* ELF relocation.  */

deftype elf_rel =
  struct (elf_e_machine mach, elf_ei_class class)
  {
    union
    {
      struct
      {
        elf32_addr r_offset;
        pinned struct
        {
          elf_word r_info;
          struct
          {
            bit<24> r_sym;
            elf_r_type<uint8> (mach) r_type;
          };
        };
      } : class == ELFCLASS32;

      struct
      {
        elf64_addr r_offset;
        pinned struct
        {
          elf64_xword r_info;
          struct
          {
            bit<32> r_sym;
            elf_r_type<uint32> (mach) r_type;
          };
        };
      } : class == ELFCLASS64;
    }
  };

/* ELF relocation with addend.  */

deftype elf_rela =
  struct (elf_e_machine mach, elf_ei_class class)
  {
    union
    {
      struct
      {
        elf32_addr r_offset;
        pinned struct
        {
          elf_word r_info;
          struct
          {
            bit<24> r_sym;
            elf_r_type<uint8> (mach) r_type;
          };
        };
      } : class == ELFCLASS32;

      struct
      {
        elf64_addr r_offset;
        pinned struct
        {
          elf64_xword r_info;
          struct
          {
            bit<32> int r_sym;
            elf_r_type<uint32> (mach) r_type;
          };
        };
      } : class == ELFCLASS64;
    }

    /* Constant addend used to compute the value to be stored into the
       relocatable field.  */
    elf_sword r_addend;
  };

deftype elf_ident =
  struct
  {
    byte[4] ei_mag = {0x7fUB, 'E', 'L', 'F'};

    elf_ei_class ei_class; /* File class.  */
    /* Data encoding.  This specifies both endianness and negative
       encoding.  */
    byte ei_data : ei_data == ELFDATA2LSB ? little_endian() : big_endian();
    byte ei_version; /* File version.  */
    byte ei_osabi; /* Operating system/ABI identification.  */
    byte ei_abiversion; /* ABI version.  */
    byte ei_pad; /* Start of padding bytes.  */
  #16:
    byte ei_nident; /* Size of e_ident, in bytes.  */
  };

deftype elf_ehdr =
  struct
  {
    elf_ident e_ident;

    /* Set the endianness for the data stored in the ELF file using
       the data encoding information in the header.  This applies to
       every field defined from this point on.  */
    /*
    switch (e_ident.ei_data)
      {
      case ELFDATANONE:
        assert (1);
        break;
      case ELFDATA2LSB:
        .endian = lsb;
        .nencoding = 2;
        break;
      case ELFDATA2MSB:
        .endian = msb;
        .nencoding = 2;
        break;
      };
    */
  
    elf_e_type e_type; /* File type.  */
    elf_e_machine e_machine; /* Required architecture.  */
    elf_e_version e_version; /* Object file version.  */

    union
    {
      struct
      {
        elf32_addr e_entry;
        elf32_off e_phoff;
        elf32_off e_shoff;
      } : ehdr.e_ident.ei_class == ELFCLASS32;
      
      struct
      {
        elf64_addr e_entry;
        elf64_off e_phoff;
        elf64_off e_shoff;
      } : ehdr.e_ident.ei_class == ELFCLASS64;
    };

    elf_e_flags (e_machine) e_flags;
    elf_half e_ehsize;  /* ELF header size in bytes.  */

    /* Size in bytes of one entry in the file's program header
       table.  */
    elf_half e_phentsize;

    /* Number of entries in the program header table.  If the file has
       no program header table, holds zero.  */
    elf_half e_phnum;

    /* Size in bytes of one entry in the file's section header
       table.  */
    elf_half e_shentsize;

    /* Number of entries in the section header table.  If the file has
       no section header table, holds zero.  */
    elf_half e_shnum;

    /* Section header table index of the entry associated with the
       section name string table, or SHN_UNDEF.  */
    elf_half e_shstrndx;
};

/* ELF program header.  */

deftype elf_phdr =
  struct (elf_ei_class class)
  {
    /* Type of entry in the table.  This determines the nature of the
       segment described in the entry.  */
    elf_p_type p_type;

    /* p_offset is the offset into the beginning of the file at which
       the first byte of the segment resides.

       p_vaddr is the virtual address at which the first byte of the
       segment resides in memory.
     
       On systems for which physical addressing is relevant, p_paddr
       is reserved for the segment's physical address.  Becase System
       V ignores physical addressing for application programs, this
       member has unspecified contents for executable files and shared
       objects.

       p_filesz is the number of bytes in the file image of the
       segment; it may be zero.

       p_memsz is the number of bytes in the memory image of the
       segment; it may be zero.

       p_align gives the value to which the segments are aligned in
       memory and in the file.  VAlues 0 and 1 mean no alignment is
       required.  Otherwise, p_align should be a positive, integral
       power of 2, and p_vaddr should equal p_offset, modulo
       p_align.  */

    union
    {
      struct
      {
        elf32_off p_offset;
        elf32_addr p_vaddr;
        elf32_addr p_paddr;
        elf_word p_filesz;
        elf_word p_memsz;
        elf_word p_align;
      } : class == ELFCLASS32;

      struct
      {
        elf_p_flags p_flags;
        elf64_off p_offset;
        elf64_addr p_vaddr;
        elf64_addr p_paddr;
        elf64_xword p_filesz;
        elf64_xword p_memsz;
        elf64_xword p_align;
      } : class == ELFCLASS64;
    };
};

/* ELF section header.  */

deftype elf_shdr =
  struct (elf_ei_class class)
  {
    /* Index of the section's name into the section header string
       table section.  */
    elf_word sh_name;

    /* Type of entry in the table.  This determines the nature of the
       segment described in this entry.  */
    elf_sh_type sh_type;

    /* Section flags.  */
    union
    {
      elf_sh_flags<uint32> sh_flags : ELFCLASS == 32;
      elf_sh_flags<uint64> sh_flags : ELFCLASS == 64;
    };

    /* If the section will appear in the memory image of a process,
       sh_addr gives the address at which the section's first byte
       should reside.  Otherwise the member contains 0.

       sh_offset is the byte offset from the beginning of the file to
       the first byte in the section.  For SHT_NOBITS sections, this
       is the conceptual placement on the file.

       sh_size is the section size in bytes.  */
  
    union
    {
      struct
      {
        elf32_addr sh_addr;
        elf32_off sh_offset;
        elf_word sh_size;
      } : class == ELFCLASS32;

      struct
      {
        elf64_addr sh_addr;
        elf64_off sh_offset;
        elf64_xword sh_size;
      } : class == ELFCLASS64;
    };

    /* Section header table index link.  */
    elf_word sh_link;

    /* Extra information, whose interpretation depends on the section
       type.  */
    elf_word sh_info;

    /* sh_addralign_doc reflects the alignment constraint for the
       section.

       If the section holds a table of fixed-size entries,
       sh_entsize_doc holds the size of each entry in bits.  Holds 0
       if the section does not hold a table of fixed-size entries.  */

    union
    {
      struct
      {
        elf_word sh_addralign;
        elf_word sh_entsize;
      } : class == ELFCLASS32;

      struct
      {
        elf64_xword sh_addralign;
        elf64_xword sh_entsize;
      } : class == ELFCLASS64;
    };
};

/* structs for the contents of certain ELF sections.  */

/* ELF compressed section header.  Used in sections with
   SHF_COMPRESSED.  */

deftype elf_chdr =
  union (elf_ei_class class)
  {
    /* ch_type is the compression algorithm.
       ch_size is the size in bytes of the uncompressed data.
       ch_addralign is the required alignment of the uncompressed
       data.  */
    
    struct
    {
      elf_ch_type ch_type;
      elf_word ch_size;
      elf_word ch_addralign;
    } : class == ELFCLASS32;

    struct
    {
      elf_ch_type ch_type;
      elf64_word ch_reserved;
      elf64_xword ch_size;
      elf64_xword ch_addralign;
    } : class == ELFCLASS64;
  };

/* ELF symbol table entry.  */

deftype elf_sym =
  struct (elf_e_machine mach, elf_ei_class class)
{
  /* st_name_ is the index into the object file's symbol string table,
     which holds the character representations of the symbol
     names.

     st_value is the value of the associated symbol.  st_size is the
     size associated with this symbol.

     st_shndx is the section header table index of the section related
     to this symbol.  */

  union
  {
    struct
    {
      elf32_word st_name;
      elf32_addr st_value;
      elf32_word st_size;

      pinned struct
      {
        uint32 st_info;
        struct
        {
          elf_sym_binding<bit<28>> st_bind;
          elf_st_type<bit<4>> (mach) st_type;
        };
      };

      pinned struct
      {
        byte st_other;
        struct
        {
          elf_sym_visibility<bit<3>> st_visibility;
          bit<5>;
        };
      };
      
      elf32_half st_shndx;
    } : class == ELFCLASS32;
    
    struct
    {
      elf64_word st_name;

      pinned struct
      {
        uint64 st_info;
        struct
        {
          elf_sym_binding<bit<60>> st_bind;
          elf_st_type<bit<4>> (mach) st_type;
        };
      };

      pinned struct
      {
        byte st_other;
        struct
        {
          elf_sym_visibility<bit<3>> st_visibility;
          bit<5>;
        };
      };

      elf64_half st_shndx;
      elf64_addr st_value;
      elf64_xword st_size;
    } : class == ELFCLASS64;
  };
};

/* ELF hash table.  */

deftype elf_hash =
  struct
  {
    elf_word nbucket;
    elf_word nchain;
    
    elf_word[nbucket] bucket;
    elf_word[nchain] chain;
  };

/* ELF dynamic section.  */

deftype elf_dyn =
  struct (elf_e_machine mach, elf_ei_class class)
  {
    union
    {
      elf_d_tag<uint32> (mach) d_tag : class == ELFCLASS32;
      elf_d_tag<uint64> (mach) d_tag : class == ELFCLASS64;
    };

    union
    {
      union
      {
        elf_word d_val : class == ELFCLASS32;
        elf64_xword d_val : class == ELFCLASS64;
      } : d_tag in [DT_NEEDED, DT_PLTRELSZ, DT_RELASZ, DT_RELAENT,
                    DT_STRSZ, DT_SYMENT, DT_SONAME, DT_RPATH,
                    DT_SYMBOLIC, DT_RELSZ, DT_RELENT, DT_PLTREL,
                    DT_TEXTREL, DT_BIND_NOW, DT_INIT_ARRAYSZ,
                    DT_FINI_ARRAYSZ, DT_RUNPATH, DT_PLTGOT,
                    DT_HASH, DT_STRTAB, DT_SYMTAB, DT_RELA,
                    DT_INIT, DT_FINI, DT_REL, DT_DEBUG,
                    DT_JMPREL, DT_INIT_ARRAY, DT_FINI_ARRAY];

      union
      {
        elf_d_tag_flag<uint32> d_val : class == ELFCLASS32;
        elf_d_tag_flag<uint64> d_val : class == ELFCLASS64;
      } : d_tag == DT_FLAGS;

      /* Entries in the dynamic tags in a position >= DT_ENCODING
         follow an uniform rule regarding what field is used for the
         data: even entries use d_ptr while odd entries use d_val.  */

      union
      {
        union
        {
          elf32_addr d_ptr : class == ELFCLASS32;
          elf64_addr d_ptr : class == ELFCLASS64;
        } : d_tag % 2 == 0;

        union
        {
          elf_word d_val : class == ELFCLASS32;
          elf_xword d_val : class == ELFCLASS64;
        };
      };
    };
      
    /* Support for elf32_addr/elf64_addr to have different size than
       elf_word/elf64_xword.  */

    defvar pad_size
      = sizeof (d_tag) + max (sizeof (d_val), sizeof (d_ptr)) - .;

    byte[pad_size] pad if pad_size > 0;
};

/* ELF note section.  */

deftype elf_note =
  struct (elf_ei_class class)
  {
    /* The first namesz bytes in name contain a null-terminated
       character representation of the entry's owner or originator.
  
       The first descsz bytes in desc hold the note descriptor. The
       ABI places no constraints on a descriptor's contents.

       type gives the interpretation of the descriptor.  */

    union
    {
      struct
      {
        elf_word namesz;
        elf_word descsz;
        elf_word type;
        byte[namesz] name;
        byte[alignto(., 4)];
        byte[descsz] desc;
        byte[alignto(., 4)];
      } : class == ELFCLASS32;

      struct
      {
        elf64_xword namesz;
        elf64_xword descsz;
        elf64_xword type;
        byte[namesz] name;
        byte[alignto(., 8)];
        byte[descsz] desc;
        byte[alignto(., 8)];
      } : class == ELFCLASS64;
    };
};

deftype elf_group =
  struct (elf_off num_idxs)
{
  elf_group_flags flags;
  elf32_word[num_idxs] shidx;
};

deftype elf_section =
  union (elf_e_machine mach,
         elf_ei_class class,                    
         elf_shdr shdr)
  {
    defvar nents = ((shdr.sh_entsize != 0)
                    ? shdr.sh_size / shdr.sh_entsize : 0);

    struct {}
      : shdr.sh_type == SHT_NULL;

    byte[shdr.sh_size] progbits
      : shdr.sh_type == SHT_PROGBITS;

    elf_sym(mach, class)[nents] symtab
      : shdr.sh_type == SHT_SYMTAB;

    byte[shdr.sh_size] strtab
      : (shdr.sh_size > 0 && shdr.sh_type == SHT_STRTAB
         && warn_nofail_if (strtab[0] == '\0' && strtab[shdr.sh_size - 1] == '\0'));

    elf_rel(mach, class)[nents] rel
      : shdr.sh_type == SHT_REL;

    elf_rela(mach, class)[nents] rela
      : shdr.sh_type == SHT_RELA;

    elf_hash hash
      : shdr.sh_type == SHT_HASH;

    elf_dyn(mach, class)[nents] dynamic
      : (shdr.sh_type == SHT_DYNAMIC
         && warn_nofail_if (elf_dyn_section_constraints (dynamic)));
  
    elf_note(class)[nents] note
      : shdr.sh_type == SHT_NOTE;
  
    struct {}
      : shdr.sh_type == SHT_NOBITS;
  
    byte[shdr.sh_size] shlib
      : shdr.sh_type == SHT_SHLIB;
  
    elf_sym(mach, class)[nents] dynsym
      : shdr.sh_type == SHT_DYNSYM;
  
    elf_addr[nents] preinit_array
      : shdr.sh_type == SHT_PREINIT_ARRAY; /* XXX: and the 32bit? */
  
    elf_addr[nents] init_array
      : shdr.sh_type == SHT_INIT_ARRAY;
  
    elf_addr[nents] fini_array
      : shdr.sh_type == SHT_FINI_ARRAY;
  
    elf_group[nents] group
      : shdr.sh_type == SHT_GROUP;
  
    elf32_word[nents] symtab_shndx
      : shdr.sh_type == SHT_SYMTAB_SHNDX;
  };

deftype elf_segment =
  union (elf_ei_class class,
         elf_phdr phdr)
  {
    struct {} : phdr.p_type == PT_NULL;
    struct {} : phdr.p_type == PT_LOAD;
    struct {} : phdr.p_type == PT_DYNAMIC;
    struct {} : phdr.p_type == PT_INTERP;
    struct {} : phdr.p_type == PT_NOTE;
    struct {} : phdr.p_type == PT_SHLIB;
    struct {} : phdr.p_type == PT_PHDR;
    struct {} : phdr.p_type == PT_TLS;
  };

/* Finally, the ELF object file itself.  */

deftype elf =
  struct
  {
    elf_ehdr ehdr;
    
    /* Both the section header table and the program header table are
       optional.  */

  ehdr.e_shoff:
    elf_shdr(ehdr.e_ident.ei_class)[ehdr.e_shnum] shdr if ehdr.e_shnum > 0;

  ehdr.e_phoff:
    elf_phdr(ehdr.e_ident.ei_class)[ehdr.e_phnum] phdr if ehdr.e_phnum > 0;

    /* The sections and segments themselves are defined in terms of the
       contents of the two tables defined above.  Note that sections and
       segments usually overlap. */

  shdr[sections$index].sh_offset:
    elf_section (ehdr.e_machine,
                 ehdr.e_ident.ei_class,
                 shdr[sections$index]) [ehdr.e_shnum] sections;

  phdr[segments$index].p_offset:    
    elf_segment (ehdr.e_machine,
                 edhr.e_ident.ei_class,
                 phdr[segments$index]) [ehdr.e_phnum] segments;
  };

/*
Local variables:
mode:c
End:
*/
