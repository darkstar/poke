/* Useful idiom: a struct containing common fields can be defined and
   used as a flattening inside the union alternatives.  The type
   `packet_epilogue' is not visible from outside the union.  */

deftype packet =
  union
  {
    deftype packet_epilogue = struct { uint32 quux; };

    struct
    {
      uint32 type = 0x0;
      byte[1024] data;
      packet_epilogue;
    } audio;

    struct
    {
      uint32 type = 0x1;
      byte[2048] data;
      packet_epilogue;
    } video;
  };

/* The desugared version of a conditional struct field is a flattened
   union with an empty alternative.  */

deftype foo =
  struct
  {
    int f1;
    int f2 if f1 > 0;
  };

/* is equivalent to  */

deftype foo =
  struct
  {
    int f1;
    union
    {
      int f2 : f1 > 0;
      struct {};
    };
  };

/* Flattened structs can also be conditional:  */

deftype foo =
  struct
  {
    int f1;
    struct
    {
      int f2;
      int f3;
    } if f1 > 0;
  };

/* is equivalent to */

deftype foo =
  struct
  {
    int f1;
    union
    {
      struct { int f2; int f3; } : f1 > 0;
      struct {};
    };
  };

/* Video file example.  */

deftype vfile = tag [];

deftype tag =
  union
  {
    deftype tag_common =
      struct
      {
        int flags;
        int reserved;
      };
    
    struct
    {
      int tag_type = TAG_VIDEO;
      tag_common;
      uint64 time;
      byte[1024] data;
    } video;

    struct
    {
      int tag_type = TAG_SCRIPT;
      tag_common;
      string code;
    } script;

    struct
    {
      int tag_type = TAG_NULL;
      tag_common;
    } null;
  };

/* Compare the above with the following version where flattening is not
   used at all.  The type `tag' is changed to a struct and an
   additional union is nested, very C-like.  */

deftype tag =
  struct
  {
    int tag_type;
    int flags;
    int reserved;

    union
    {
      struct
      {
        uint64 time;
        byte[1024] data;
      } video : tag_type == TAG_VIDEO;

      struct
      {
        string code;
      } script : tag_type == TAG_SCRIPT;

      struct
      {
      } null : tag_type = TAG_NULL;
      
    } data;
  };

/* Flattening also works with enums.  */

deftype relocs =
  enum <int> (int mach)
  {
    enum <int>
    {
      R_SPARC_FOO = 1,
      R_SPARC_BAR = 2
    } if mach == SPARC;

    enum <int>
    {
      R_ALPHA_FOO = 1,
      R_ALPHA_BAR = 2
    } if mach == ALPHA;
  };

/*
Local variables:
mode:c
End:
*/
