/* The arguments to structs and unions should be preserved, because
   they can be part of the tag of contained unions.

   They can be accessed using foo'attr, and are read_only.

   Attributes are inheritable in structs/unions lexical scopes.

   Support for initial values for default arguments.  */

union elf_chdr (enum elf_ei_class class = ELFCLASS64)
{
  struct
  {
    enum elf_ch_type ch_type;
    elf_word ch_size;
    elf_word ch_addralign;
    
  } : class == ELFCLASS32;

  struct
  {
    enum elf_ch_type ch_type;
    elf64_word ch_reserved;
    elf64_xword ch_size;
    elf64_xword ch_addralign;
    
  } : class == ELFCLASS64;

  struct {};
}

(poke) let c = elf_chdr(ELFCLASS64) @ 0xff;
(poke) print c'class
ELFCLASS64
(poke) set c'class = ELFCLASS32
error: struct attributes are not mutable

(poke) let c = elf_chdr(ELFCLASS64) {ELFCOMPRESS_ZLIB, .ch_addralign=8}
(poke) print c
{.ch_type=ELFCOMPRESS_ZLIB, .ch_type=0, .ch_reserved=0, .ch_addralign=8}
(poke) print c'class
ELFCLASS64

/* Struct with anonymous components:

   Used for padding.
   Anonymous structs and unions also used
   to compose other structs unions without introducing
   useless intermediate names.  */

struct foo
{
  int;
  long;
  struct
  {
    byte;
  };
}

/* value: {1, 2L, {'a'}} */

/* This is NOT valid:  {.foo=1, {.foo=2}}
   because it is ambiguous.

   Should be detected at run-time.  */

/* Constraints also valid in struct literals.  */

  {.foo = 1 : foo != 1}  /* This fails!  */

struct packet (int version)
{
  struct
  {
    byte magic;

    union
    {
      uint32 resv : version > 1;
      struct
      {
        byte flags;
        byte attrs;
        uint16 resv;
      } : version == 2;
      struct {};
    };
  } header;

  byte[header.size] data;
}

/* if EXPR is syntactic sugar for an anonymous union with a value and
   an empty alternative. */

struct foo
{
  int one;
  int opt if one > 0;
}

/* Is equivalent to:  */

struct foo
{
  int one;
  union
  {
    int opt : one > 0;
    struct {};
  };
}

/* Can also be used in anonymous structs.  And of course named
   structs.  */

struct foo
{
  int one;
  struct
  {
    int i;
    long l;
  } if one > 0;
}

/* Bit fields are made with bit-types:

   typedef bit:4 bitfield_type;

   instead of : BITS like in C.  */

struct foo
{
  bit:4 nibble;
};


struct packet
{
  uint8 version;
  uint64 size;
  if (size > 0)
    byte[size] data;

  if (version >= 2)
    uint64 flags;
}

let packet p;  /* { 0UB, 0UL, [] } */
let p = (packet) {1, 2, [1,2,3]};
let p = packet @ .; /* At current IO offset */
packet p; /* At current IO offset */
let p = packet @ 0x0;  /* At IO offset 0x0 */

(poke) for (let i in p.data) print (i + "\n")
1B
2B
3B
(poke) for (let i = 0; i < elemsof p.data; ++i) print (p.data[i] + "\n");
1B
2B
3B
(poke) peek packet @ 0x0
...
(poke) poke 0x0, packet {1,1024}
0x00 <--- ...
...
(poke)

/* Simple struct literals must also be allowed, for patterns, switch
   statements, etc.  */

(poke) let s = {1, 2, [1,2,3]};
(poke) print typeof s
struct {int32; int32; int32[3];}

/* Struct constructors can get arguments */

struct foo (uint64 size)
{
  byte[size] bytes;
}

let f = foo(10) {[1,2,3,4,5,6,7,8,9,10]};
let foo(10) f;

let int i; /* 0 */
int i;     /* At current IO offset */
let i = 10;
let i = int @ 0x0;


let int32[5] a; /* [0,0,0,0,0] */
let a = [1,2,3,4,5];
let a = int32[5] @ 0x0;
let a = int32[5] @ .;  /* At current IO offset */
int32[5] a;            /* Likewise.  */

void incr_int (int i)
{
  i += 1;  /* This will have a side-effect if I is mapped.  */
}

void print_packet (packet p)
{

}

void sort_array (int32[] a)
{

}


(poke) let packet p;
(poke) print p
{0UB, 0UL}
(poke) print typeof p
packet {uint8 version; uint64 size;}

(poke) let p = packet {2, 4}
(poke) print p
{2UB, 4UL, [0B,0B,0B,0B]}
(poke) print typeof p
packet {uint8 version; uint64 size; byte[4] data; uint64 flags;}

(poke) print typeof {1, 2, [1,2,3]}
struct {int32; int32; int32[3];}
(poke) print typeof {.foo=1, .bar=2, .baz=[1,2,3]}
struct {int32 foo; int32 bar; int32[3] baz;}
(poke) print packet {1, 2, [1,2,3]}
error: invalid size in array `data'.  /* Constructor fails! */


