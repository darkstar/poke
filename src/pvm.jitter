## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2017 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
  tos-stack "union jitter_word" "stack"
end

## Register classes.

register-class r 5
  code
    union jitter_word
  end
end

## Functions and globals to wrap.

wrapped-functions
  printf
end

#wrapped-globals
#  pvm_printf_format_string
#end

## Prologue and epilogue for the generated code.

early-c
  code
#   include <string.h>
#   include <pvm.h>
#   define PARG(A) ((pvm_stack)(A).pointer)
  end
end

late-c
  code
  end
end

## PVM state.

# Initialize the extra field:
#  pvm_state_initialize (&s);
#  s->pvm = pvm_init ();
# Finalize the extra field:
# pvm_shutdown (s->pvm);
# pvm_state_finalize (&s);

state-struct-backing-c
  code
    /* Add extra types, variables, etc.  */
  end
end

state-initialization-c
  code
    /* Initialize extra state here.  */
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end

## VM instructions

instruction exit ()
  code
    JITTER_EXIT ();
  end
end

## Miscellaneous Instructions

instruction nop ()
  code
  end
end

instruction drop ()
  code
    JITTER_DROP_STACK();
  end
end

# Can be a register of class "r" (R), or a literal (n), or a label (l)
# 0 1 -1 and 2 are the literal values this instruction is specialized
# on.

# ? means Read-only/Input.
# ! means output
# ?! or !? means both

instruction push (?Rnl)
  code
    union jitter_word k;
    k.pointer = JITTER_ARGP0;
    JITTER_PUSH_STACK(k);
  end
end

instruction pop (!R)
  code
    union jitter_word top = JITTER_TOP_STACK();
    JITTER_DROP_STACK();
    JITTER_ARGP0 = top.pointer;
  end
end

instruction setr (!R)
  code
    JITTER_ARGP0 = JITTER_TOP_STACK().pointer;
  end
end


#instruction print ()
#  code
#    union jitter_word top = JITTER_TOP_STACK();
#    JITTER_DROP_STACK();
#    printf (stack_printf_format_string, top);
#  end
#end

## Operators instructions.

# Integer arithmetic.

instruction add ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) + PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction sub ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) - PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mul ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) * PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction div ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) / PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mod ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) % PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

# Positive.
instruction pos ()
  code
    /* Nothing.  */
  end
end

# Negation.
instruction neg ()
  code
    pvm_stack s = (pvm_stack) JITTER_TOP_STACK().pointer;
    PVM_STACK_INTEGER (s) = - PVM_STACK_INTEGER (s);
  end
end

# Pre-increment.
instruction preinc ()
  code
    pvm_stack s = (pvm_stack) JITTER_TOP_STACK().pointer;
    PVM_STACK_INTEGER (s) = ++ PVM_STACK_INTEGER (s);
  end  
end

# Pre-decrement.
instruction predec ()
  code
    pvm_stack s = (pvm_stack) JITTER_TOP_STACK().pointer;
    PVM_STACK_INTEGER (s) == -- PVM_STACK_INTEGER (s);
  end  
end

# Equality/inequality instructions.

instruction ieq ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) == PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction ine ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) != PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction seq ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s) = strcmp (PVM_STACK_STRING (PARG(a)), \
                                     PVM_STACK_STRING (PARG(b))) == 0; \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction sne ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s) = strcmp (PVM_STACK_STRING (PARG(a)), \
                                     PVM_STACK_STRING (PARG(b))) != 0; \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

# Comparison instructions.

instruction ilt ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) < PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ile ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) <= PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction igt ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) > PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction ige ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) >= PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction slt ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s) = strcmp (PVM_STACK_STRING (PARG(a)), \
                                     PVM_STACK_STRING (PARG(b))) < 0; \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction sle ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s) = strcmp (PVM_STACK_STRING (PARG(a)), \
                                     PVM_STACK_STRING (PARG(b))) <= 0; \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction sgt ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s) = strcmp (PVM_STACK_STRING (PARG(a)), \
                                     PVM_STACK_STRING (PARG(b))) > 0; \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction sge ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s) = strcmp (PVM_STACK_STRING (PARG(a)), \
                                     PVM_STACK_STRING (PARG(b))) >= 0; \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Concatenation instructions.

instruction sconc ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     char *ss = PVM_STACK_STRING (PARG(res));           \
     char *sa = PVM_STACK_STRING (PARG(a));             \
     char *sb = PVM_STACK_STRING (PARG(b));             \
     PVM_STACK_TYPE (s) = PVM_STACK_STR;                \
     ss = xmalloc (strlen (sa) + strlen (sb) + 1);      \
     ss = strcpy (ss, sa);                              \
     ss = strcat (ss, sb);                              \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Logical instructions.

instruction and ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) && PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction or ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) || PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction not ()
  code
    pvm_stack s = (pvm_stack) JITTER_TOP_STACK().pointer;
    PVM_STACK_INTEGER (s) = ! PVM_STACK_INTEGER (s);
  end
end

# Bitwise operators.

instruction bxor ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) ^ PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bior ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) | PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction band ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) & PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bnot ()
  code
    pvm_stack s = (pvm_stack) JITTER_TOP_STACK().pointer;
    PVM_STACK_INTEGER (s) = ~ PVM_STACK_INTEGER (s);
  end
end

instruction bsl ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) << PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsr ()
  code
#define F(res, a, b)                                    \
  {                                                     \
     pvm_stack  s = pvm_stack_new ();                   \
     PVM_STACK_TYPE (s) = PVM_STACK_INT;                \
     PVM_STACK_INTEGER (s)                              \
       = PVM_STACK_INTEGER (PARG(a)) >> PVM_STACK_INTEGER (PARG(b)); \
     pvm_stack_free (PARG(a));                          \
     pvm_stack_free (PARG(b));                          \
     res.pointer = (union jitter_word *) s;             \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

## Branches

# Branch always.
instruction ba (?f)
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

# Branch if zero undertop.
instruction bzut (?f)
  code
    pvm_stack s = ((pvm_stack) JITTER_TOP_STACK().pointer);
    JITTER_BRANCH_FAST_IF_ZERO (PVM_STACK_INTEGER (s),
                                JITTER_ARGF0);
  end
end

# Branch if not type top
instruction bnt (?n,?f)
  code
     pvm_stack s = ((pvm_stack)JITTER_UNDER_TOP_STACK().pointer);

     JITTER_BRANCH_FAST_IF_ZERO (PVM_STACK_TYPE (s) == JITTER_ARGN0,
                                 JITTER_ARGF1);
  end
end

# Branch if not type undertop.
instruction bntut (?n,?f)
  code
     pvm_stack s = ((pvm_stack)JITTER_UNDER_TOP_STACK().pointer);

     JITTER_BRANCH_FAST_IF_ZERO (PVM_STACK_TYPE (s) == JITTER_ARGN0,
                                 JITTER_ARGF1);
  end
end
