## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2018 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
  tos-stack "pvm_val" "stack"
end



## Register classes.

register-class r 5
  code
    union jitter_word
  end
end



## Functions and globals to wrap.

wrapped-functions
  printf
end

#wrapped-globals
#  pvm_printf_format_string
#end



## Embedded C code.

early-header-c
  code
#   include "pvm.h"
  end
end

early-c
  code
#   include <string.h>
  end
end

late-header-c
  code
    extern jitter_uint printer_hi;
  end
end

late-c
  code
    jitter_uint printer_hi;
  end
end

printer-c
  code
    void
    pvm_literal_printer_cast (FILE *out, jitter_uint val)
    {
      fprintf (out, "%" JITTER_PRIu, val);
    }

    void
    pvm_literal_printer (FILE *out, jitter_uint val)
    {
      pvm_print_val (out, (pvm_val) val, 10);
    }

    void
    pvm_literal_printer_hi (FILE *out, jitter_uint hi)
    {
      fprintf (out, "%%hi(0x%" JITTER_PRIx ")", hi);
      printer_hi = hi; /* This sucks */
    }

    void
    pvm_literal_printer_lo (FILE *out, jitter_uint lo)
    {
      fprintf (out, "%%lo(0x%" JITTER_PRIx") (", lo);
      pvm_print_val (out,
                    ((pvm_val) printer_hi << 32) | lo,
                    10);
      fputc (')', out);
      printer_hi = 0;
    }
  end
end



## PVM state.

state-struct-backing-c
  code
      enum pvm_exit_code exit_code;
      pvm_val result_value;
  end
end

state-struct-runtime-c
  code
      uint32_t push_hi;
  end
end

state-initialization-c
  code
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end



## VM instructions

instruction exit ()
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    jitter_original_state->pvm_state_backing.exit_code
      = PVM_VAL_INT (JITTER_TOP_STACK());
    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    if (1 /* !EOS == expression */)
    {
      jitter_original_state->pvm_state_backing.result_value
        = JITTER_TOP_STACK();
      JITTER_DROP_STACK ();
    }

    JITTER_EXIT ();
  end
end



## Miscellaneous Instructions

instruction nop ()
  code
  end
end

## Stack manipulation instructions

instruction drop () # A -> _
  code
    JITTER_DROP_STACK();
  end
end

instruction push (?Rnl pvm_literal_printer) # _ -> A
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

instruction swap () # A B -> B A
  code
    pvm_val tmp = JITTER_UNDER_TOP_STACK ();
    JITTER_UNDER_TOP_STACK () = JITTER_TOP_STACK ();
    JITTER_TOP_STACK () = tmp;
  end
end

instruction nip () # A B -> B
  code
    JITTER_NIP_STACK();
  end
end

instruction dup () # A -> A A
  code
    JITTER_DUP_STACK ();
  end
end

instruction rot () # A B C -> B C A
  code
   pvm_val a, b, c;

   c = JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
   b = JITTER_TOP_STACK ();
   a = JITTER_UNDER_TOP_STACK ();

   JITTER_UNDER_TOP_STACK () = b;
   JITTER_TOP_STACK () = c;
   JITTER_PUSH_STACK (a);
  end
end

instruction nrot () # A B C -> C A B
  code
   pvm_val a, b, c;

   c = JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
   b = JITTER_TOP_STACK ();
   a = JITTER_UNDER_TOP_STACK ();

   JITTER_UNDER_TOP_STACK () = c;
   JITTER_TOP_STACK () = a;
   JITTER_PUSH_STACK (b);
  end
end

instruction pushhi (?Rnl pvm_literal_printer_hi)
  code
     jitter_state_runtime.push_hi
       = JITTER_ARGN0;
  end
end

instruction pushlo (?Rnl pvm_literal_printer_lo)
  code
     pvm_val k
       = ((pvm_val) jitter_state_runtime.push_hi << 32)
         | JITTER_ARGN0;
     JITTER_PUSH_STACK (k);
  end
end

instruction push32 (?Rnl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK (k);
  end
end

instruction pop (!R)
  code
    pvm_val top = JITTER_TOP_STACK();
    JITTER_DROP_STACK();
    JITTER_ARGN0 = top;
  end
end

instruction setr (!R)
  code
    JITTER_ARGN0 = JITTER_TOP_STACK();
  end
end

instruction siz () # VAL -> ULONG
  code
    JITTER_TOP_STACK () = pvm_sizeof (JITTER_TOP_STACK ());
  end
end

instruction sel () # VAL -> ULONG
  code
    JITTER_TOP_STACK () = pvm_elemsof (JITTER_TOP_STACK ());
  end
end



## Operators instructions.

# Integer arithmetic.
#
# The following instructions assume that both operands have the same
# size in bits.

instruction addi () # INT INT -> INT
  code
#define F(res, a, b)                                                     \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) + PVM_VAL_INT (b), size);        \
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) + PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addl () # LONG LONG -> LONG
  code
#define F(res, a, b)                                                       \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) + PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) + PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) - PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) - PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) - PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction sublu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) - PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muli () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) * PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) * PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mull () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) * PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mullu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) * PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) / PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction diviu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) / PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) / PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) / PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) % PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_UINT (a) % PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) % PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) % PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction negi () # INT -> INT
  code
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_int (- PVM_VAL_INT (JITTER_TOP_STACK()), size);
  end
end

instruction negiu () # UINT -> UINT
  code
    int size = PVM_VAL_UINT_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) (- PVM_VAL_INT (JITTER_TOP_STACK())), size);
  end
end

instruction negl () # LONG -> LONG
  code
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_long (- PVM_VAL_LONG (JITTER_TOP_STACK()), size);
  end
end

instruction neglu () # LONG -> LONG
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) (- PVM_VAL_ULONG (JITTER_TOP_STACK())), size);
  end
end

# Equality/inequality

instruction eqi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) == PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) == PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eql () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) == PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) == PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) != PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction neiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) != PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) != PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) != PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqs () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) == 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nes () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) != 0, 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

# Comparison instructions.

instruction lti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) < PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) < PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) < PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) < PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) <= PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction leiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) <= PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) <= PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) <= PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) > PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) > PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) > PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) > PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) >= PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction geiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) >= PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) >= PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) >= PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction lts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) < 0, 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) > 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction ges () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) >= 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction les () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) <= 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Concatenation instructions.

instruction sconc () # STR STR -> STR
  code
#define F(res, a, b)                                  \
  {                                                   \
     char *sa = PVM_VAL_STR (a);                      \
     char *sb = PVM_VAL_STR (b);                      \
     char *s = xmalloc (strlen (sa) + strlen (sb) + 1);\
     strcpy (s, sa);                                  \
     strcat (s, sb);                                  \
     res = pvm_make_string (s);                       \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Logical instructions.

instruction and () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int ((PVM_VAL_INT (a) && PVM_VAL_INT (b)), 32);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction or () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int ((PVM_VAL_INT (a) || PVM_VAL_INT (b)), 32);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction not () # INT -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int (! PVM_VAL_INT(JITTER_TOP_STACK()), 32);
  end
end

# Bitwise operators.

instruction bxori () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                             \
    res = pvm_make_int (PVM_VAL_INT (a) ^ PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxoriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) ^ PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) ^ PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_ULONG (a) ^ PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bori () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) | PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction boriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) | PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) | PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_ULONG (a) | PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) & PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) & PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) & PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) & PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bnoti () # INT -> INT
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_int (~PVM_VAL_INT (JITTER_TOP_STACK()), size);
  end
end

instruction bnotiu () # UINT -> UINT
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_uint (~PVM_VAL_UINT (JITTER_TOP_STACK()), size);
  end
end

instruction bnotl () # LONG -> LONG
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_long (~PVM_VAL_LONG (JITTER_TOP_STACK()), size);
  end
end

instruction bnotlu () # ULONG -> ULONG
  code
   int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
   JITTER_TOP_STACK() = pvm_make_ulong (~PVM_VAL_ULONG (JITTER_TOP_STACK()), size);
  end
end

instruction bsli () # INT UINT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsll () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsllu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsri () # INT UINT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrl () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrlu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) >> PVM_VAL_UINT (b), size); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end



## Branches

instruction ba (?f) # Branch always.
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction bzi (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

instruction bziu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

instruction bzl (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

instruction bzlu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end



## Conversion instructions.

instruction itoi (?n pvm_literal_printer_cast) # INT -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int (val, tsize);
  end
end

instruction itoiu (?n pvm_literal_printer_cast) # INT -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction itol (?n pvm_literal_printer_cast) # INT -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction itolu (?n pvm_literal_printer_cast) # INT -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction iutoi (?n pvm_literal_printer_cast) # UINT -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction iutoiu (?n pvm_literal_printer_cast) # UINT -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint (val, tsize);
  end
end

instruction iutol (?n pvm_literal_printer_cast) # UINT -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction iutolu (?n pvm_literal_printer_cast) # UINT -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction ltoi (?n pvm_literal_printer_cast) # LONG -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction ltoiu (?n pvm_literal_printer_cast) # LONG -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction ltol (?n pvm_literal_printer_cast) # LONG -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long (val, tsize);
  end
end

instruction ltolu (?n pvm_literal_printer_cast) # LONG -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction lutoi (?n pvm_literal_printer_cast) # ULONG -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction lutoiu (?n pvm_literal_printer_cast) # ULONG -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction lutol (?n pvm_literal_printer_cast) # ULONG -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction lutolu (?n pvm_literal_printer_cast) # ULONG -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong (val, tsize);
  end
end



## Array instructions.

# TYP [IDX VAL]... ULONG(ninitializer) ULONG(nelem) -> ARR
instruction mka ()
  code
    size_t i;
    pvm_val nelem, ninitializer, arr;

    ninitializer = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    arr = pvm_make_array (nelem, PVM_NULL /* type */);
    for (i = 0; i < PVM_VAL_ULONG (ninitializer); ++i)
    {
      size_t index
        = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());

      PVM_VAL_ARR_ELEM (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_ARR_TYPE (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (arr);
  end
end

instruction aset () # ARR ULONG VAL -> ARR
  code
    uint64_t idx;
    pvm_val val;

    val= JITTER_TOP_STACK ();
    idx = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    /* XXX: Jump to Eabounds if index out of range.  */
    PVM_VAL_ARR_ELEM (JITTER_TOP_STACK (), idx) = val;
  end
end

instruction aref () # ARR ULONG -> VAL
  code
    /* XXX: Jump to Eabounds if index out of range.  */
#define F(res, a, b) \
  { res = PVM_VAL_ARR_ELEM (a, PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction alen () # ARR -> ULONG
  code
    JITTER_TOP_STACK ()
      = PVM_VAL_ARR_NELEM (JITTER_TOP_STACK());
  end
end



## Struct instructions.

instruction mksct () # [STR VAL]... ULONG -> SCT
  code
    size_t e;
    pvm_val nelem, sct;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    sct = pvm_make_struct (nelem);

    for (e = 0; e < PVM_VAL_ULONG (nelem); ++e)
    {
      PVM_VAL_SCT_ELEM_VALUE (sct, e) = JITTER_TOP_STACK ();
      PVM_VAL_SCT_ELEM_NAME (sct, e) = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (sct);
  end
end

instruction revsct () # SCT -> SCT
  code
    pvm_reverse_struct (JITTER_TOP_STACK ());
  end
end

instruction sctset () # SCT VAL STR -> SCT
  code
  end
end

instruction sctref () # SCT STR -> VAL
  code
#define F(res, a, b) { res = pvm_ref_struct (a, b); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end



## Offset instructions.

instruction mko () # EXP ULONG -> OFF
  code
#define F(res, a, b)                           \
  { pvm_val base_type = pvm_typeof (a);        \
    res = pvm_make_offset (base_type, a, b); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction ogetm () # OFF -> OFF (INT|LONG|UINT|ULONG)
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()));
  end
end

instruction ogetu () # OFF -> OFF UINT
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ()));
  end
end

instruction ogetbt () # OFF -> OFF BT
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_BASE_TYPE (JITTER_TOP_STACK ()));
  end
end



## Type related instructions.

instruction mktyi () # ULONG UINT -> TYP
  code
    pvm_val size = JITTER_UNDER_TOP_STACK ();
    pvm_val signed_p = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_TOP_STACK () = pvm_make_integral_type (size, signed_p);
  end
end

instruction mktys () # _ -> TYP
  code
    JITTER_PUSH_STACK (pvm_make_string_type ());
  end
end

instruction mktyo () # TYP INT -> TYP
  code
#define F(res, a, b) \
  { res = pvm_make_offset_type (a, b); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mktym () # _ -> TYP
  code
    JITTER_PUSH_STACK (pvm_make_map_type ());
  end
end

instruction mktya () # TYP ULONG -> TYP
  code
#define F(res, a, b) { res = pvm_make_array_type (b, a); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

instruction mktysct () # [STRING TYP]... NLONG -> TYP
  code
    size_t i;
    pvm_val nelem, *etypes, *enames;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_struct_attrs (nelem, &etypes, &enames);

    for (i = 0; i < PVM_VAL_ULONG (nelem); ++i)
    {
      /* XXX: check pvm_val types?  */

      enames[i] = JITTER_UNDER_TOP_STACK ();
      etypes[i] = JITTER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_struct_type (nelem,
                                             enames, etypes));
  end
end

instruction typof () # VAL -> TYP
  code
    JITTER_TOP_STACK () = pvm_typeof (JITTER_TOP_STACK ());
  end
end

# Instructions to access the IO space: mapping.

instruction mkm () # TYP ULONG -> MAP
  code
#define F(res, a, b) { res = pvm_make_map (a, b); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

instruction peek () # MAP -> VAL
  code
  end
end

instruction poke () # MAP VAL -> _
  code
  end
end



## Peephole optimizations

rule swap-drop-to-nip rewrite
  swap; drop
into
  nip
end

rule rot-rot-to-nrot rewrite
  rot; rot
into
  nrot
end
