## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2018 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
  tos-stack "pvm_val" "stack"
end

## Register classes.

register-class r 5
  code
    union jitter_word
  end
end

## Functions and globals to wrap.

wrapped-functions
  printf
end

#wrapped-globals
#  pvm_printf_format_string
#end

## Embedded C code.

early-header-c
  code
#   include "pvm.h"
  end
end

early-c
  code
#   include <string.h>
  end
end

late-header-c
  code
    extern jitter_uint printer_hi;
  end
end

late-c
  code
    jitter_uint printer_hi;
  end
end

printer-c
  code
    void
    pvm_literal_printer_cast (FILE *out, jitter_uint val)
    {
      fprintf (out, "%" JITTER_PRIu, val);
    }

    void
    pvm_literal_printer (FILE *out, jitter_uint val)
    {
      pvm_print_val (out, (pvm_val) val, 10);
    }

    void
    pvm_literal_printer_hi (FILE *out, jitter_uint hi)
    {
      fprintf (out, "%%hi(0x%" JITTER_PRIx ")", hi);
      printer_hi = hi; /* This sucks */
    }

    void
    pvm_literal_printer_lo (FILE *out, jitter_uint lo)
    {
      fprintf (out, "%%lo(0x%" JITTER_PRIx") (", lo);
      pvm_print_val (out,
                    ((pvm_val) printer_hi << 32) | lo,
                    10);
      fputc (')', out);
      printer_hi = 0;
    }
  end
end

## PVM state.

state-struct-backing-c
  code
      enum pvm_exit_code exit_code;
      pvm_val result_value;
  end
end

state-struct-runtime-c
  code
      uint32_t push_hi;
  end
end

state-initialization-c
  code
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end

## VM instructions

instruction exit ()
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    jitter_original_state->pvm_state_backing.exit_code
      = PVM_VAL_INT (JITTER_TOP_STACK());
    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    if (1 /* !EOS == expression */)
    {
      jitter_original_state->pvm_state_backing.result_value
        = JITTER_TOP_STACK();
      JITTER_DROP_STACK ();
    }

    JITTER_EXIT ();
  end
end

## Miscellaneous Instructions

instruction nop ()
  code
  end
end

instruction drop ()
  code
    JITTER_DROP_STACK();
  end
end

instruction push (?Rnl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

instruction pushhi (?Rnl pvm_literal_printer_hi)
  code
     jitter_state_runtime.push_hi
       = JITTER_ARGN0;
  end
end

instruction pushlo (?Rnl pvm_literal_printer_lo)
  code
     pvm_val k
       = ((pvm_val) jitter_state_runtime.push_hi << 32)
         | JITTER_ARGN0;
     JITTER_PUSH_STACK (k);
  end
end

instruction push32 (?Rnl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK (k);
  end
end

instruction pop (!R)
  code
    pvm_val top = JITTER_TOP_STACK();
    JITTER_DROP_STACK();
    JITTER_ARGN0 = top;
  end
end

instruction setr (!R)
  code
    JITTER_ARGN0 = JITTER_TOP_STACK();
  end
end

instruction siz () # VAL -> ULONG
  code
    JITTER_TOP_STACK () = pvm_sizeof (JITTER_TOP_STACK ());
  end
end

instruction sel () # VAL -> ULONG
  code
    JITTER_TOP_STACK () = pvm_elemsof (JITTER_TOP_STACK ());
  end
end

## Operators instructions.

# Integer arithmetic.
#
# The following instructions assume that both operands have the same
# size in bits.

instruction addi () # INT INT -> INT
  code
#define F(res, a, b)                                                     \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) + PVM_VAL_INT (b), size);        \
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) + PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addl () # LONG LONG -> LONG
  code
#define F(res, a, b)                                                       \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) + PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) + PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) - PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) - PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) - PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction sublu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) - PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muli () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) * PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) * PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mull () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) * PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mullu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) * PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) / PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction diviu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) / PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) / PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) / PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) % PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_UINT (a) % PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) % PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) % PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction negi () # INT -> INT
  code
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_int (- PVM_VAL_INT (JITTER_TOP_STACK()), size);
  end
end

instruction negiu () # UINT -> UINT
  code
    int size = PVM_VAL_UINT_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) (- PVM_VAL_INT (JITTER_TOP_STACK())), size);
  end
end

instruction negl () # LONG -> LONG
  code
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_long (- PVM_VAL_LONG (JITTER_TOP_STACK()), size);
  end
end

instruction neglu () # LONG -> LONG
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) (- PVM_VAL_ULONG (JITTER_TOP_STACK())), size);
  end
end

# Equality/inequality

instruction eqi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) == PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) == PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eql () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) == PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) == PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) != PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction neiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) != PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) != PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) != PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqs () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) == 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nes () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) != 0, 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

# Comparison instructions.

instruction lti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) < PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) < PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) < PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) < PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) <= PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction leiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) <= PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) <= PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) <= PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) > PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) > PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) > PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) > PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) >= PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction geiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) >= PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) >= PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) >= PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction lts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) < 0, 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) > 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction ges () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) >= 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction les () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) <= 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Concatenation instructions.

instruction sconc () # STR STR -> STR
  code
#define F(res, a, b)                                  \
  {                                                   \
     char *sa = PVM_VAL_STR (a);                      \
     char *sb = PVM_VAL_STR (b);                      \
     char *s = xmalloc (strlen (sa) + strlen (sb) + 1);\
     strcpy (s, sa);                                  \
     strcat (s, sb);                                  \
     res = pvm_make_string (s);                       \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Logical instructions.

instruction and () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int ((PVM_VAL_INT (a) && PVM_VAL_INT (b)), 32);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction or () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int ((PVM_VAL_INT (a) || PVM_VAL_INT (b)), 32);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction not () # INT -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int (! PVM_VAL_INT(JITTER_TOP_STACK()), 32);
  end
end

# Bitwise operators.

instruction bxori () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                             \
    res = pvm_make_int (PVM_VAL_INT (a) ^ PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxoriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) ^ PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) ^ PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_ULONG (a) ^ PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bori () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) | PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction boriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) | PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) | PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_ULONG (a) | PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) & PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) & PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) & PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) & PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bnoti () # INT -> INT
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_int (~PVM_VAL_INT (JITTER_TOP_STACK()), size);
  end
end

instruction bnotiu () # UINT -> UINT
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_uint (~PVM_VAL_UINT (JITTER_TOP_STACK()), size);
  end
end

instruction bnotl () # LONG -> LONG
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_long (~PVM_VAL_LONG (JITTER_TOP_STACK()), size);
  end
end

instruction bnotlu () # ULONG -> ULONG
  code
   int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
   JITTER_TOP_STACK() = pvm_make_ulong (~PVM_VAL_ULONG (JITTER_TOP_STACK()), size);
  end
end

instruction bsli () # INT UINT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsll () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsllu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsri () # INT UINT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrl () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrlu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) >> PVM_VAL_UINT (b), size); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

# Offsets arithmetic
#
# The following instructions assume that the base types of the offset
# operands have the same size in bits.

instruction addol () # OFF(LONG) OFF(LONG) -> OFF(LONG)
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    pvm_val size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    int64_t va = PVM_VAL_LONG (PVM_VAL_OFF_MAGNITUDE (a)); \
    int64_t vb = PVM_VAL_LONG (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_offset (base_type,                       \
                           pvm_make_long ((va * ua) + (vb * ub), PVM_VAL_ULONG (size)), \
                           pvm_make_uint (PVM_VAL_OFF_UNIT_BITS, 32)); }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction addolu () # OFF(ULONG) OFF(ULONG) -> OFF(ULONG)
  code
  end
end

instruction addoi () # OFF(INT) OFF(INT) -> OFF(INT)
  code
  end
end

instruction addoiu () # OFF(UINT) OFF(UINT) -> OFF(UINT)
  code
  end
end

instruction divol () # OFF(LONG) OFF(LONG) -> LONG
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    pvm_val size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    int64_t va = PVM_VAL_LONG (PVM_VAL_OFF_MAGNITUDE (a)); \
    int64_t vb = PVM_VAL_LONG (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_long ((va * ua) / (vb * ub), PVM_VAL_ULONG (size)); }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction divolu () # OFF(ULONG) OFF(ULONG) -> ULONG
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    pvm_val size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    uint64_t va = PVM_VAL_ULONG (PVM_VAL_OFF_MAGNITUDE (a)); \
    uint64_t vb = PVM_VAL_ULONG (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_ulong ((va * ua) / (vb * ub), PVM_VAL_ULONG (size)); }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction divoi () # OFF(INT) OFF(INT) -> INT
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    pvm_val size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    int32_t va = PVM_VAL_INT (PVM_VAL_OFF_MAGNITUDE (a)); \
    int32_t vb = PVM_VAL_INT (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_int ((va * ua) / (vb * ub), PVM_VAL_ULONG (size)); }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction divoiu () # OFF OFF -> UINT
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    pvm_val size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    uint32_t va = PVM_VAL_UINT (PVM_VAL_OFF_MAGNITUDE (a)); \
    uint32_t vb = PVM_VAL_UINT (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_uint ((va * ua) / (vb * ub), PVM_VAL_ULONG (size)); }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction modol () # OFF OFF -> LONG
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    pvm_val size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    int64_t va = PVM_VAL_LONG (PVM_VAL_OFF_MAGNITUDE (a)); \
    int64_t vb = PVM_VAL_LONG (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_offset (base_type,                       \
                           pvm_make_long (va % (vb * ub / ua), PVM_VAL_ULONG (size)), \
                           PVM_VAL_OFF_UNIT (a));           \
  }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction modolu () # OFF(ULONG) OFF(ULONG) -> ULONG
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    pvm_val size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    uint64_t va = PVM_VAL_ULONG (PVM_VAL_OFF_MAGNITUDE (a)); \
    uint64_t vb = PVM_VAL_ULONG (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_offset (base_type,                       \
                           pvm_make_ulong (va % (vb * ub / ua), PVM_VAL_ULONG (size)), \
                           PVM_VAL_OFF_UNIT (a));           \
  }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction modoi () # OFF(INT) OFF(INT) -> INT
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    uint64_t size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    int32_t va = PVM_VAL_INT (PVM_VAL_OFF_MAGNITUDE (a)); \
    int32_t vb = PVM_VAL_INT (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_offset (base_type,                       \
                           pvm_make_int (va % (vb * ub / ua), PVM_VAL_ULONG (size)), \
                           PVM_VAL_OFF_UNIT (a));           \
  }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction modoiu () # OFF(UINT) OFF(UINT) -> UINT
  code
#define F(res, a, b)                               \
  { pvm_val base_type = PVM_VAL_OFF_BASE_TYPE (a); \
    uint64_t size = PVM_VAL_TYP_I_SIZE (base_type); \
    uint64_t ua = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (a)); \
    uint64_t ub = PVM_VAL_ULONG (PVM_VAL_OFF_UNIT (b)); \
    uint32_t va = PVM_VAL_UINT (PVM_VAL_OFF_MAGNITUDE (a)); \
    uint32_t vb = PVM_VAL_UINT (PVM_VAL_OFF_MAGNITUDE (b)); \
    res = pvm_make_offset (base_type,                       \
                           pvm_make_uint (va % (vb * ub / ua), PVM_VAL_ULONG (size)), \
                           PVM_VAL_OFF_UNIT (a));           \
  }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

## Branches

instruction ba (?f) # Branch always.
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction bz (?f) # Branch if zero top.
  code
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (JITTER_TOP_STACK()),
                                JITTER_ARGF0);
  end
end

instruction boz (?f) # Branch if offset zero top.
  code
    /* XXX DO SOMETHING */
//    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (JITTER_TOP_STACK()),
//                                JITTER_ARGF0);
  end
end


instruction bzut (?f) # Branch if zero under-top.
  code
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (JITTER_UNDER_TOP_STACK()),
                                JITTER_ARGF0);
  end
end

instruction bnt (?n,?f) # Branch if not type top
  code
     JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_TAG (JITTER_TOP_STACK())
                                 == JITTER_ARGN0,
                                 JITTER_ARGF1);
  end
end

instruction bntut (?n,?f) # Branch if not type undertop.
  code
     JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_TAG (JITTER_UNDER_TOP_STACK())
                                   == JITTER_ARGN0,
                                 JITTER_ARGF1);
  end
end

## Conversion instructions.

instruction itoi (?n pvm_literal_printer_cast) # INT -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int (val, tsize);
  end
end

instruction itou (?n pvm_literal_printer_cast) # INT -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction itol (?n pvm_literal_printer_cast) # INT -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction itolu (?n pvm_literal_printer_cast) # INT -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction utoi (?n pvm_literal_printer_cast) # UINT -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction utou (?n pvm_literal_printer_cast) # UINT -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint (val, tsize);
  end
end

instruction utol (?n pvm_literal_printer_cast) # UINT -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction utolu (?n pvm_literal_printer_cast) # UINT -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction ltoi (?n pvm_literal_printer_cast) # LONG -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction ltou (?n pvm_literal_printer_cast) # LONG -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction ltol (?n pvm_literal_printer_cast) # LONG -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long (val, tsize);
  end
end

instruction ltolu (?n pvm_literal_printer_cast) # LONG -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction lutoi (?n pvm_literal_printer_cast) # ULONG -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction lutou (?n pvm_literal_printer_cast) # ULONG -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction lutol (?n pvm_literal_printer_cast) # ULONG -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction lutolu (?n pvm_literal_printer_cast) # ULONG -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong (val, tsize);
  end
end

## Array instructions.

# TYP [IDX VAL]... ULONG(ninitializer) ULONG(nelem) -> ARR
instruction mka ()
  code
    size_t i;
    pvm_val nelem, ninitializer, arr;

    ninitializer = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    arr = pvm_make_array (nelem, PVM_NULL /* type */);
    for (i = 0; i < PVM_VAL_ULONG (ninitializer); ++i)
    {
      size_t index
        = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());

      PVM_VAL_ARR_ELEM (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_ARR_TYPE (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (arr);
  end
end

instruction aset () # ARR ULONG VAL -> ARR
  code
    uint64_t idx;
    pvm_val val;

    val= JITTER_TOP_STACK ();
    idx = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    /* XXX: Jump to Eabounds if index out of range.  */
    PVM_VAL_ARR_ELEM (JITTER_TOP_STACK (), idx) = val;
  end
end

instruction aref () # ARR ULONG -> VAL
  code
    /* XXX: Jump to Eabounds if index out of range.  */
#define F(res, a, b) \
  { res = PVM_VAL_ARR_ELEM (a, PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction alen () # ARR -> ULONG
  code
    JITTER_TOP_STACK ()
      = PVM_VAL_ARR_NELEM (JITTER_TOP_STACK());
  end
end

## Struct instructions.

instruction mksct () # [STR VAL]... ULONG -> SCT
  code
    size_t e;
    pvm_val nelem, sct;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    sct = pvm_make_struct (nelem);

    for (e = 0; e < PVM_VAL_ULONG (nelem); ++e)
    {
      PVM_VAL_SCT_ELEM_VALUE (sct, e) = JITTER_TOP_STACK ();
      PVM_VAL_SCT_ELEM_NAME (sct, e) = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (sct);
  end
end

instruction revsct () # SCT -> SCT
  code
    pvm_reverse_struct (JITTER_TOP_STACK ());
  end
end

instruction sctset () # SCT VAL STR -> SCT
  code
  end
end

instruction sctref () # SCT STR -> VAL
  code
#define F(res, a, b) { res = pvm_ref_struct (a, b); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

## Offset instructions.

instruction mko () # TYP EXP ULONG -> OFF
  code
    pvm_val unit, base_type, magnitude;

    unit = JITTER_TOP_STACK ();
    magnitude = JITTER_UNDER_TOP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    base_type = JITTER_TOP_STACK ();

    JITTER_TOP_STACK () =
      pvm_make_offset (base_type, magnitude, unit);
  end
end

## Type related instructions.

instruction mktyi () # ULONG UINT -> TYP
  code
    pvm_val size = JITTER_UNDER_TOP_STACK ();
    pvm_val signed_p = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_TOP_STACK () = pvm_make_integral_type (size, signed_p);
  end
end

instruction mktys () # _ -> TYP
  code
    JITTER_PUSH_STACK (pvm_make_string_type ());
  end
end

instruction mktyo () # TYP INT -> TYP
  code
#define F(res, a, b) \
  { res = pvm_make_offset_type (a, b); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mktym () # _ -> TYP
  code
    JITTER_PUSH_STACK (pvm_make_map_type ());
  end
end

instruction mktya () # TYP ULONG -> TYP
  code
#define F(res, a, b) { res = pvm_make_array_type (b, a); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

instruction mktysct () # [STRING TYP]... NLONG -> TYP
  code
    size_t i;
    pvm_val nelem, *etypes, *enames;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_struct_attrs (nelem, &etypes, &enames);

    for (i = 0; i < PVM_VAL_ULONG (nelem); ++i)
    {
      /* XXX: check pvm_val types?  */

      enames[i] = JITTER_UNDER_TOP_STACK ();
      etypes[i] = JITTER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_struct_type (nelem,
                                             enames, etypes));
  end
end

instruction typof () # VAL -> TYP
  code
    JITTER_TOP_STACK () = pvm_typeof (JITTER_TOP_STACK ());
  end
end

# Instructions to access the IO space: mapping.

instruction mkm () # TYP ULONG -> MAP
  code
#define F(res, a, b) { res = pvm_make_map (a, b); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

instruction peek () # MAP -> VAL
  code
  end
end

instruction poke () # MAP VAL -> _
  code
  end
end
