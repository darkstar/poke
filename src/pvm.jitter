## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2018 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
  tos-stack "pvm_val" "stack"
  ntos-stack "jitter_uint" "returnstack"
end



## Register classes.

register-class r 2
  code
    union jitter_word
  end
end



## Functions and globals to wrap.

wrapped-functions
  printf
  pvm_assert
  pvm_env_lookup
  pvm_env_register
  pvm_env_pop_frame
  pvm_env_push_frame
  pvm_make_int
  pvm_make_uint
  pvm_make_long
  pvm_make_ulong
  pvm_make_string
  pvm_make_array
  pvm_make_struct
  pvm_make_offset
  pvm_make_integral_type
  pvm_make_string_type
  pvm_make_offset_type
  pvm_make_array_type
  pvm_allocate_struct_attrs
  pvm_make_struct_type
  pvm_typeof
  ios_cur
  ios_read_int
  ios_read_uint
  ios_read_long
  ios_read_ulong
  ios_read_string
end

#wrapped-globals
#  pvm_printf_format_string
#end



## Embedded C code.

early-header-c
  code
#   include "pvm.h"
#   include "ios.h"
  end
end

early-c
  code
#   include <string.h>
  end
end

late-header-c
  code
    extern jitter_uint printer_hi;
  end
end

late-c
  code
    jitter_uint printer_hi;
  end
end

printer-c
  code
    void
    pvm_literal_printer_cast (FILE *out, jitter_uint val)
    {
      fprintf (out, "%" JITTER_PRIu, val);
    }

    void
    pvm_literal_printer (FILE *out, jitter_uint val)
    {
      pvm_print_val (out, (pvm_val) val, 10);
    }

    void
    pvm_literal_printer_hi (FILE *out, jitter_uint hi)
    {
      fprintf (out, "%%hi(0x%" JITTER_PRIx ")", hi);
      printer_hi = hi; /* This sucks */
    }

    void
    pvm_literal_printer_lo (FILE *out, jitter_uint lo)
    {
      fprintf (out, "%%lo(0x%" JITTER_PRIx") (", lo);
      pvm_print_val (out,
                    ((pvm_val) printer_hi << 32) | lo,
                    10);
      fputc (')', out);
      printer_hi = 0;
    }

    void
    popf_printer (FILE *out, jitter_uint nframes)
    {
      fprintf (out, "%" JITTER_PRIu, nframes);
    }
  end
end



## PVM state.

# Jitter supports maintaining a VM state which is splitted in
# `backing' and `runtime', so the question arises what to put in either
# part of the state.  According to the comments generated by jitterc:
#
# "The machine state is separated into the backing and the more
#  compact runtime data structures, to be allocated in registers as
#  far as possible.  These are just a forward-declarations: the actual
#  definitions are machine-generated."
#
# and:
#
# "The state backing and runtime are initialized at the same time, and
#  in fact the distinction between them is invisible to the VM user."
#
# So it looks like both `backing' and `runtime' are available at
# runtime, but accessing runtime is much more efficient because it is
# kept in host machine registers if possible.

state-struct-backing-c
  code
      enum pvm_exit_code exit_code;
      pvm_val result_value;
  end
end

state-struct-runtime-c
  code
      pvm_env env;
      uint32_t push_hi;
  end
end

state-initialization-c
  code
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end



## VM instructions

instruction exit ()
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    jitter_original_state->pvm_state_backing.exit_code
      = PVM_VAL_INT (JITTER_TOP_STACK());
    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    if (JITTER_TOP_STACK() != PVM_NULL)
    {
      jitter_original_state->pvm_state_backing.result_value
        = JITTER_TOP_STACK();
      JITTER_DROP_STACK ();
    }

    /* Check for the stack centinel and pop it.  */
    pvm_assert (JITTER_TOP_STACK() == PVM_NULL);
    JITTER_DROP_STACK ();

    JITTER_EXIT ();
  end
end



## Function management instructions

instruction call () # ARG1 ... ARGN CLOSURE -> RETVAL
  caller
  code
    pvm_val closure = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  
    /* Make place for the return address in the return stack.  The
       actual value will be written by the callee. */
    JITTER_PUSH_UNSPECIFIED_RETURNSTACK();

    /* Save the current environment and use the callee's environment.
     */
    JITTER_PUSH_RETURNSTACK ((jitter_uint) (uintptr_t) jitter_state_runtime.env);
    jitter_state_runtime.env = PVM_VAL_CLS_ENV (closure);

    /* Branch-and-link to the native code, whose first instruction will
       be a prolog. */
    JITTER_BRANCH_AND_LINK (PVM_VAL_CLS_ENTRY_POINT (closure));
  end
end

instruction prolog ()
  callee
  code
    /* Fill the return stack slot with the return address.  The return
       stack has already been pushed (with an unspecified value on the
       under top) by the caller. */
    JITTER_UNDER_TOP_RETURNSTACK() = (jitter_uint) JITTER_LINK;
  end
end

instruction return ()
  code
    jitter_uint return_address;

    /* Restore the environment of the caller.  */
    jitter_state_runtime.env = (pvm_env) JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK();

    return_address = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();

    JITTER_RETURN (return_address);
  end
end



## Environment instructions

instruction pushf ()
  code
    jitter_state_runtime.env
       = pvm_env_push_frame (jitter_state_runtime.env);
  end
end

instruction popf (?n popf_printer)
  code
    jitter_uint i;

    for (i = 0; i < JITTER_ARGN0; ++i)
        jitter_state_runtime.env
           = pvm_env_pop_frame (jitter_state_runtime.env);
  end
end

# pushvar BACK, OVER
instruction pushvar (?n, ?n) #  _ -> VAL
  code
    JITTER_PUSH_STACK (pvm_env_lookup (jitter_state_runtime.env,
                                       (int) JITTER_ARGN0,
                                       (int) JITTER_ARGN1));
  end
end

instruction popvar (?n, ?n) # VAL -> _
  code
    pvm_env_set_var (jitter_state_runtime.env,
                     (int) JITTER_ARGN0,
                     (int) JITTER_ARGN1,
                     JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

instruction regvar () # VAL -> _
  code
    pvm_env_register (jitter_state_runtime.env,
                      JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Put Environment in Closure
instruction pec () # CLS -> CLS (+ current environment)
  code
    pvm_val cls = JITTER_TOP_STACK ();
    PVM_VAL_CLS_ENV (cls) = jitter_state_runtime.env;
  end
end



## Miscellaneous Instructions

instruction nop ()
  code
  end
end

instruction note (?n pvm_literal_printer)
  code
  end
end

instruction siz () # VAL -> ULONG
  code
    JITTER_TOP_STACK () = pvm_sizeof (JITTER_TOP_STACK ());
  end
end

instruction print () # STR -> _
  code
    pvm_print_string (stdout, JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end



## Stack manipulation instructions

instruction drop () # A -> _
  code
    JITTER_DROP_STACK();
  end
end

instruction push (?Rnl pvm_literal_printer) # _ -> A
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

instruction swap () # A B -> B A
  code
    pvm_val tmp = JITTER_UNDER_TOP_STACK ();
    JITTER_UNDER_TOP_STACK () = JITTER_TOP_STACK ();
    JITTER_TOP_STACK () = tmp;
  end
end

instruction nip () # A B -> B
  code
    JITTER_NIP_STACK();
  end
end

instruction dup () # A -> A A
  code
    JITTER_DUP_STACK ();
  end
end

instruction rot () # A B C -> B C A
  code
   pvm_val a, b, c;

   c = JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
   b = JITTER_TOP_STACK ();
   a = JITTER_UNDER_TOP_STACK ();

   JITTER_UNDER_TOP_STACK () = b;
   JITTER_TOP_STACK () = c;
   JITTER_PUSH_STACK (a);
  end
end

instruction nrot () # A B C -> C A B
  code
   pvm_val a, b, c;

   c = JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
   b = JITTER_TOP_STACK ();
   a = JITTER_UNDER_TOP_STACK ();

   JITTER_UNDER_TOP_STACK () = c;
   JITTER_TOP_STACK () = a;
   JITTER_PUSH_STACK (b);
  end
end

instruction pushhi (?Rnl pvm_literal_printer_hi)
  code
     jitter_state_runtime.push_hi
       = JITTER_ARGN0;
  end
end

instruction pushlo (?Rnl pvm_literal_printer_lo)
  code
     pvm_val k
       = ((pvm_val) jitter_state_runtime.push_hi << 32)
         | JITTER_ARGN0;
     JITTER_PUSH_STACK (k);
  end
end

instruction push32 (?Rnl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK (k);
  end
end

instruction pop ()
  code
    JITTER_DROP_STACK();
  end
end

instruction popr (!R)
  code
    pvm_val top = JITTER_TOP_STACK();
    JITTER_DROP_STACK();
    JITTER_ARGN0 = top;
  end
end

instruction setr (!R)
  code
    JITTER_ARGN0 = JITTER_TOP_STACK();
  end
end

instruction sel () # VAL -> ULONG
  code
    JITTER_TOP_STACK () = pvm_elemsof (JITTER_TOP_STACK ());
  end
end



## Operators instructions.

# Integer arithmetic.
#
# The following instructions assume that both operands have the same
# size in bits.

instruction addi () # INT INT -> INT
  code
#define F(res, a, b)                                                     \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) + PVM_VAL_INT (b), size);        \
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) + PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addl () # LONG LONG -> LONG
  code
#define F(res, a, b)                                                       \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) + PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) + PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) - PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) - PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) - PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction sublu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) - PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muli () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) * PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) * PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mull () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) * PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mullu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) * PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) / PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction diviu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_uint (PVM_VAL_UINT (a) / PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) / PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) / PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_INT (a) % PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a); \
    res = pvm_make_int (PVM_VAL_UINT (a) % PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a); \
    res = pvm_make_long (PVM_VAL_LONG (a) % PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a); \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) % PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction negi () # INT -> INT
  code
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_int (- PVM_VAL_INT (JITTER_TOP_STACK()), size);
  end
end

instruction negiu () # UINT -> UINT
  code
    int size = PVM_VAL_UINT_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) (- PVM_VAL_INT (JITTER_TOP_STACK())), size);
  end
end

instruction negl () # LONG -> LONG
  code
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_long (- PVM_VAL_LONG (JITTER_TOP_STACK()), size);
  end
end

instruction neglu () # LONG -> LONG
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) (- PVM_VAL_ULONG (JITTER_TOP_STACK())), size);
  end
end

# Equality/inequality

instruction eqi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) == PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) == PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eql () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) == PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) == PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) != PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction neiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) != PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) != PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) != PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqs () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) == 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nes () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) != 0, 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

# Comparison instructions.

instruction lti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) < PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) < PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) < PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) < PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) <= PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction leiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) <= PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) <= PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) <= PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) > PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) > PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) > PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) > PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) >= PVM_VAL_INT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction geiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) >= PVM_VAL_UINT (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) >= PVM_VAL_LONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) >= PVM_VAL_ULONG (b), 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction lts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) < 0, 32); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) > 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction ges () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) >= 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction les () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) <= 0, 32); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Concatenation instructions.

instruction sconc () # STR STR -> STR
  code
#define F(res, a, b)                                  \
  {                                                   \
     char *sa = PVM_VAL_STR (a);                      \
     char *sb = PVM_VAL_STR (b);                      \
     char *s = xmalloc (strlen (sa) + strlen (sb) + 1);\
     strcpy (s, sa);                                  \
     strcat (s, sb);                                  \
     res = pvm_make_string (s);                       \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Logical instructions.

instruction and () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int ((PVM_VAL_INT (a) && PVM_VAL_INT (b)), 32);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction or () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int ((PVM_VAL_INT (a) || PVM_VAL_INT (b)), 32);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction not () # INT -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int (! PVM_VAL_INT(JITTER_TOP_STACK()), 32);
  end
end

# Bitwise operators.

instruction bxori () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                             \
    res = pvm_make_int (PVM_VAL_INT (a) ^ PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxoriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) ^ PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) ^ PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_ULONG (a) ^ PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bori () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) | PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction boriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) | PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) | PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_ULONG (a) | PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandi () # INT INT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) & PVM_VAL_INT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) & PVM_VAL_UINT (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) & PVM_VAL_LONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) & PVM_VAL_ULONG (b), size);\
  }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bnoti () # INT -> INT
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_int (~PVM_VAL_INT (JITTER_TOP_STACK()), size);
  end
end

instruction bnotiu () # UINT -> UINT
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_uint (~PVM_VAL_UINT (JITTER_TOP_STACK()), size);
  end
end

instruction bnotl () # LONG -> LONG
  code
    int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
    JITTER_TOP_STACK() = pvm_make_long (~PVM_VAL_LONG (JITTER_TOP_STACK()), size);
  end
end

instruction bnotlu () # ULONG -> ULONG
  code
   int size = PVM_VAL_ULONG_SIZE (JITTER_TOP_STACK());
   JITTER_TOP_STACK() = pvm_make_ulong (~PVM_VAL_ULONG (JITTER_TOP_STACK()), size);
  end
end

instruction bsli () # INT UINT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint ((PVM_VAL_UINT (a) << PVM_VAL_UINT (b))           \
                         % PVM_MAX_UINT (size), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsll () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) << PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsllu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_ulong ((PVM_VAL_ULONG (a) << PVM_VAL_UINT (b))          \
                          % PVM_MAX_ULONG (size), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsri () # INT UINT -> INT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_INT_SIZE (a);                                     \
    res = pvm_make_int (PVM_VAL_INT (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { int size = PVM_VAL_UINT_SIZE (a);                                     \
    res = pvm_make_uint (PVM_VAL_UINT (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrl () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_LONG_SIZE (a);                                     \
    res = pvm_make_long (PVM_VAL_LONG (a) >> PVM_VAL_UINT (b), size); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrlu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { int size = PVM_VAL_ULONG_SIZE (a);                                     \
    res = pvm_make_ulong (PVM_VAL_ULONG (a) >> PVM_VAL_UINT (b), size); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end



## Branches

instruction ba (?f) # Branch always.
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction bzi (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

instruction bziu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

instruction bzl (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

instruction bzlu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end

instruction bnzi (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

instruction bnziu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

instruction bnzl (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

instruction bnzlu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end



## Conversion instructions.

instruction itoi (?n pvm_literal_printer_cast) # INT -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int (val, tsize);
  end
end

instruction itoiu (?n pvm_literal_printer_cast) # INT -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction itol (?n pvm_literal_printer_cast) # INT -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction itolu (?n pvm_literal_printer_cast) # INT -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int32_t val = PVM_VAL_INT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction iutoi (?n pvm_literal_printer_cast) # UINT -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction iutoiu (?n pvm_literal_printer_cast) # UINT -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint (val, tsize);
  end
end

instruction iutol (?n pvm_literal_printer_cast) # UINT -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction iutolu (?n pvm_literal_printer_cast) # UINT -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint32_t val = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction ltoi (?n pvm_literal_printer_cast) # LONG -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction ltoiu (?n pvm_literal_printer_cast) # LONG -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction ltol (?n pvm_literal_printer_cast) # LONG -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long (val, tsize);
  end
end

instruction ltolu (?n pvm_literal_printer_cast) # LONG -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    int64_t val = PVM_VAL_LONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong ((uint64_t) val, tsize);
  end
end

instruction lutoi (?n pvm_literal_printer_cast) # ULONG -> INT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_int ((int32_t) val, tsize);
  end
end

instruction lutoiu (?n pvm_literal_printer_cast) # ULONG -> UINT
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_uint ((uint32_t) val, tsize);
  end
end

instruction lutol (?n pvm_literal_printer_cast) # ULONG -> LONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_long ((int64_t) val, tsize);
  end
end

instruction lutolu (?n pvm_literal_printer_cast) # ULONG -> ULONG
  code
    jitter_uint tsize = JITTER_ARGN0;
    uint64_t val = PVM_VAL_ULONG (JITTER_TOP_STACK ());

    JITTER_TOP_STACK () = pvm_make_ulong (val, tsize);
  end
end



## Array instructions.

# TYP [IDX VAL]... ULONG(nelem) ULONG(ninitializer) -> ARR
instruction mka ()
  code
    size_t i;
    pvm_val nelem, ninitializer, arr;

    ninitializer = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    arr = pvm_make_array (nelem, PVM_NULL /* type */);
    for (i = 0; i < PVM_VAL_ULONG (ninitializer); ++i)
    {
      size_t index
        = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());

      PVM_VAL_ARR_ELEM (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_ARR_TYPE (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (arr);
  end
end

instruction aset () # ARR ULONG VAL -> ARR
  code
    uint64_t idx;
    pvm_val val;

    val= JITTER_TOP_STACK ();
    idx = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    /* XXX: Jump to Eabounds if index out of range.  */
    PVM_VAL_ARR_ELEM (JITTER_TOP_STACK (), idx) = val;
  end
end

instruction aref () # ARR ULONG -> VAL
  code
    /* XXX: Jump to Eabounds if index out of range.  */
#define F(res, a, b) \
  { res = PVM_VAL_ARR_ELEM (a, PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction alen () # ARR -> ULONG
  code
    JITTER_TOP_STACK ()
      = PVM_VAL_ARR_NELEM (JITTER_TOP_STACK());
  end
end



## Struct instructions.

instruction mksct () # [STR VAL]... ULONG -> SCT
  code
    size_t e;
    pvm_val nelem, sct;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    sct = pvm_make_struct (nelem);

    for (e = 0; e < PVM_VAL_ULONG (nelem); ++e)
    {
      PVM_VAL_SCT_ELEM_VALUE (sct, e) = JITTER_TOP_STACK ();
      PVM_VAL_SCT_ELEM_NAME (sct, e) = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (sct);
  end
end

instruction revsct () # SCT -> SCT
  code
    pvm_reverse_struct (JITTER_TOP_STACK ());
  end
end

instruction sctset () # SCT VAL STR -> SCT
  code
  end
end

instruction sref () # SCT STR -> VAL
  code
#define F(res, a, b) { res = pvm_ref_struct (a, b); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end



## Offset instructions.

instruction mko () # EXP ULONG -> OFF
  code
#define F(res, a, b) \
  { res = pvm_make_offset (a, b); }
  JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ogetm () # OFF -> OFF (INT|LONG|UINT|ULONG)
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()));
  end
end

instruction ogetu () # OFF -> OFF UINT
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ()));
  end
end

instruction ogetbt () # OFF -> OFF BT
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_BASE_TYPE (JITTER_TOP_STACK ()));
  end
end



## Type related instructions.

# Integral types

instruction mktyi () # ULONG UINT -> TYP
  code
    pvm_val size = JITTER_UNDER_TOP_STACK ();
    pvm_val signed_p = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_TOP_STACK () = pvm_make_integral_type (size, signed_p);
  end
end

# String types

instruction mktys () # _ -> TYP
  code
    JITTER_PUSH_STACK (pvm_make_string_type ());
  end
end

# Offset types

instruction mktyo () # TYP INT -> TYP
  code
#define F(res, a, b) \
  { res = pvm_make_offset_type (a, b); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Array types

instruction mktya () # TYP ULONG -> TYP
  code
#define F(res, a, b) { res = pvm_make_array_type (b, a); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

instruction tyagetn () # TYP -> TYP TYP
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_NELEM (JITTER_TOP_STACK ()));
  end
end

instruction tyagett () # TYP -> TYP TYP
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_ETYPE (JITTER_TOP_STACK ()));
  end
end

# Struct types

instruction mktysct () # [STRING TYP]... NLONG -> TYP
  code
    size_t i;
    pvm_val nelem, *etypes, *enames;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_struct_attrs (nelem, &etypes, &enames);

    for (i = 0; i < PVM_VAL_ULONG (nelem); ++i)
    {
      /* XXX: check pvm_val types?  */

      enames[i] = JITTER_UNDER_TOP_STACK ();
      etypes[i] = JITTER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_struct_type (nelem,
                                             enames, etypes));
  end
end

instruction typof () # VAL -> TYP
  code
    JITTER_TOP_STACK () = pvm_typeof (JITTER_TOP_STACK ());
  end
end

## IO instructions
#
#
# The following instructions operate on the global IO space.

# peeki NENC,ENDIAN,BITS
# OFF -> INT

instruction peeki (?n,?n,?n)
  code
     enum ios_nenc nenc = JITTER_ARGN0;
     enum ios_endian endian = JITTER_ARGN1;
     int bits = JITTER_ARGN2;
     int64_t value;
     ios_off offset;

     offset = (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()))
               * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ())));

     if (ios_read_int (ios_cur (), offset, 0,
                       bits, endian, nenc, &value) != IOS_OK)
       {
         /* XXX: branch to error label.  */
         JITTER_TOP_STACK () = PVM_NULL;
       }
     else
       {
         /* XXX: use IO and a base register */
         JITTER_TOP_STACK () = pvm_make_int (value, bits);
       }
  end
end

# peekiu ENDIAN,BITS
# OFF -> INT

instruction peekiu (?n,?n)
  code
     enum ios_endian endian = JITTER_ARGN0;
     int bits = JITTER_ARGN1;
     uint64_t value;
     ios_off offset;

     offset = (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()))
               * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ())));

     if (ios_read_uint (ios_cur (), offset, 0,
                        bits, endian, &value) != IOS_OK)
       {
         /* XXX: branch to error label.  */
         JITTER_TOP_STACK () = PVM_NULL;
       }
     else
       {
         /* XXX: use IO and a base register */
         JITTER_TOP_STACK () = pvm_make_uint (value, bits);
       }
  end
end

# peekl NENC,ENDIAN,BITS
# OFF -> INT

instruction peekl (?n,?n,?n)
  code
     enum ios_nenc nenc = JITTER_ARGN0;
     enum ios_endian endian = JITTER_ARGN1;
     int bits = JITTER_ARGN2;
     int64_t value;
     ios_off offset;

     offset = (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()))
               * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ())));

     if (ios_read_int (ios_cur (), offset, 0,
                       bits, endian, nenc, &value) != IOS_OK)
       {
         /* XXX: branch to error label.  */
         JITTER_TOP_STACK () = PVM_NULL;
       }
     else
       {
         /* XXX: use IO and a base register */
         JITTER_TOP_STACK () = pvm_make_long (value, bits);
       }
  end
end

# peeklu ENDIAN,BITS
# OFF -> ULONG

instruction peeklu (?n,?n)
  code
     enum ios_endian endian = JITTER_ARGN0;
     int bits = JITTER_ARGN1;
     uint64_t value;
     ios_off offset;

     offset = (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()))
               * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ())));

     if (ios_read_uint (ios_cur (), offset, 0,
                        bits, endian, &value) != IOS_OK)
       {
         /* XXX: branch to error label.  */
         JITTER_TOP_STACK () = PVM_NULL;
       }
     else
       {
         /* XXX: use IO and a base register */
         JITTER_TOP_STACK () = pvm_make_ulong (value, bits);
       }
  end
end

instruction peeks () # OFF -> STR
  code
    /* XXX: use IO and a base register */
    JITTER_TOP_STACK () = pvm_make_string ("");
  end
end



## Peephole optimizations

rule swap-drop-to-nip rewrite
  swap; drop
into
  nip
end

rule rot-rot-to-nrot rewrite
  rot; rot
into
  nrot
end
