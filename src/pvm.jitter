## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2018 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
  tos-stack "pvm_val" "stack"
end

## Register classes.

register-class r 5
  code
    union jitter_word
  end
end

## Functions and globals to wrap.

wrapped-functions
  printf
end

#wrapped-globals
#  pvm_printf_format_string
#end

## Embedded C code.

early-header-c
  code
#   include "pvm.h"
  end
end

early-c
  code
#   include <string.h>
  end
end

late-header-c
  code
    extern jitter_uint printer_hi;
  end
end

late-c
  code
    jitter_uint printer_hi;
  end
end

printer-c
  code
    void
    pvm_literal_printer (FILE *out, jitter_uint val)
    {
      pvm_print_val (out, (pvm_val) val, 10);
    }

    void
    pvm_literal_printer_hi (FILE *out, jitter_uint hi)
    {
      fprintf (out, "%%hi(0x%" JITTER_PRIx ")", hi);
      printer_hi = hi; /* This sucks */
    }

    void
    pvm_literal_printer_lo (FILE *out, jitter_uint lo)
    {
      fprintf (out, "%%lo(0x%" JITTER_PRIx") (", lo);
      pvm_print_val (out,
                    ((pvm_val) printer_hi << 32) | lo,
                    10);
      fputc (')', out);
      printer_hi = 0;
    }
  end
end

## PVM state.

state-struct-backing-c
  code
      enum pvm_exit_code exit_code;
      pvm_val result_value;
  end
end

state-struct-runtime-c
  code
      uint32_t push_hi;
  end
end

state-initialization-c
  code
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end

## VM instructions

instruction exit ()
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    jitter_original_state->pvm_state_backing.exit_code
      = PVM_VAL_INT (JITTER_TOP_STACK());
    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    if (1 /* !EOS == expression */)
    {
      jitter_original_state->pvm_state_backing.result_value
        = JITTER_TOP_STACK();
      JITTER_DROP_STACK ();
    }

    JITTER_EXIT ();
  end
end

## Miscellaneous Instructions

instruction nop ()
  code
  end
end

instruction drop ()
  code
    JITTER_DROP_STACK();
  end
end

instruction push (?Rnl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

instruction pushhi (?Rnl pvm_literal_printer_hi)
  code
     jitter_state_runtime.push_hi
       = JITTER_ARGN0;
  end
end

instruction pushlo (?Rnl pvm_literal_printer_lo)
  code
     pvm_val k
       = ((pvm_val) jitter_state_runtime.push_hi << 32)
         | JITTER_ARGN0;
     JITTER_PUSH_STACK (k);
  end
end

instruction push32 (?Rnl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK (k);
  end
end

instruction pop (!R)
  code
    pvm_val top = JITTER_TOP_STACK();
    JITTER_DROP_STACK();
    JITTER_ARGN0 = top;
  end
end

instruction setr (!R)
  code
    JITTER_ARGN0 = JITTER_TOP_STACK();
  end
end

instruction siz () # VAL -> ULONG
  code
    JITTER_TOP_STACK () = pvm_sizeof (JITTER_TOP_STACK ());
  end
end

instruction sel () # VAL -> ULONG
  code
    JITTER_TOP_STACK () = pvm_elemsof (JITTER_TOP_STACK ());
  end
end

## Operators instructions.

# Integer arithmetic.

# XXX: one of the references A or B may be lost when assigning to RES
#      depending on TOS or no TOS.  So refcounts must be decremented
#      in both A and B.

# XXX: value preserving vs sign preserving?
#      C standardized in value preserving, with promotions.
#      Java avoids this problem by not having unsigned types.. the fuckers :D
#      But we need unsigned types.

instruction addb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) + PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) + PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) + PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) + PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) + PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) + PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) + PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) + PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) - PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) - PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) - PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) - PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) - PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) - PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) - PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction sublu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) - PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mulb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) * PVM_VAL_BYTE (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mulbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) * PVM_VAL_UBYTE (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mulh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) * PVM_VAL_HALF (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mulhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) * PVM_VAL_UHALF (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muli () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) * PVM_VAL_INT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) * PVM_VAL_UINT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mull () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) * PVM_VAL_LONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mullu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) * PVM_VAL_ULONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) / PVM_VAL_BYTE (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) / PVM_VAL_UBYTE (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) / PVM_VAL_HALF (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) / PVM_VAL_UHALF (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) / PVM_VAL_INT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction diviu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) / PVM_VAL_UINT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) / PVM_VAL_LONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) / PVM_VAL_ULONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) % PVM_VAL_BYTE (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) % PVM_VAL_UBYTE (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) % PVM_VAL_HALF (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) % PVM_VAL_UHALF (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) % PVM_VAL_INT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) % PVM_VAL_UINT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) % PVM_VAL_LONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) % PVM_VAL_ULONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction negb () # BYTE -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte (- PVM_VAL_BYTE (JITTER_TOP_STACK()));
  end
end

instruction negbu () # UBYTE -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte (- PVM_VAL_UBYTE (JITTER_TOP_STACK()));
  end
end

instruction negh () # HALF -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half (- PVM_VAL_HALF (JITTER_TOP_STACK()));
  end
end

instruction neghu () # UHALF -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf (- PVM_VAL_UHALF (JITTER_TOP_STACK()));
  end
end

instruction negi () # INT -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int (- PVM_VAL_INT (JITTER_TOP_STACK()));
  end
end

instruction negiu () # UINT -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) -PVM_VAL_UINT (JITTER_TOP_STACK()));
  end
end

instruction negl () # LONG -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long (- PVM_VAL_LONG (JITTER_TOP_STACK()));
  end
end

instruction neglu () # LONG -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) -PVM_VAL_ULONG (JITTER_TOP_STACK()));
  end
end

# Equality/inequality.

instruction eqb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) == PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) == PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) == PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) == PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) == PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) == PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eql () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) == PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) == PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction neb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) != PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nebu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) != PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction neh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) != PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nehu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) != PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) != PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction neiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) != PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) != PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) != PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqs () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) == 0); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nes () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) != 0); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

# Comparison instructions.

instruction ltb () # BYTE BYTE -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_BYTE (a) < PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltbu () # UBYTE UBYTE -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UBYTE (a) < PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lth () # HALF HALF -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_HALF (a) < PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lthu () # UHALF UHALF -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UHALF (a) < PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) < PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) < PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) < PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) < PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction leb () # BYTE BYTE -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_BYTE (a) <= PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lebu () # UBYTE UBYTE -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UBYTE (a) <= PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction leh () # HALF HALF -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_HALF (a) <= PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lehu () # UHALF UHALF -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UHALF (a) <= PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) <= PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction leiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) <= PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) <= PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) <= PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gtb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) > PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) > PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gth () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) > PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gthu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) > PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) > PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) > PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) > PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) > PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction geb () # BYTE BYTE -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_BYTE (a) >= PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gebu () # UBYTE UBYTE -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UBYTE (a) >= PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction geh () # HALF HALF -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_HALF (a) >= PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gehu () # UHALF UHALF -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UHALF (a) >= PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) >= PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction geiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) >= PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) >= PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) >= PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction lts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) < 0); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) > 0); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction ges () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) >= 0); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction les () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) <= 0); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Concatenation instructions.

instruction sconc () # STR STR -> STR
  code
#define F(res, a, b)                                  \
  {                                                   \
     char *sa = PVM_VAL_STR (a);                      \
     char *sb = PVM_VAL_STR (b);                      \
     char *s = xmalloc (strlen (sa) + strlen (sb) + 1);\
     strcpy (s, sa);                                  \
     strcat (s, sb);                                  \
     res = pvm_make_string (s);                       \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Logical instructions.

instruction and () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) && PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction or () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) || PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction not () # INT -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int (! PVM_VAL_INT(JITTER_TOP_STACK()));
  end
end

# Bitwise operators.

instruction bxorb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) ^ PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) ^ PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) ^ PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) ^ PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxori () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) ^ PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxoriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) ^ PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) ^ PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) ^ PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) | PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) | PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) | PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) | PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bori () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) | PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction boriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) | PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) | PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) | PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandb () # BYTE BYTE -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) & PVM_VAL_BYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandbu () # UBYTE UBYTE -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) & PVM_VAL_UBYTE (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandh () # HALF HALF -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) & PVM_VAL_HALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandhu () # UHALF UHALF -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) & PVM_VAL_UHALF (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) & PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) & PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) & PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) & PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bnotb () # BYTE -> BYTE
  code
    JITTER_TOP_STACK() = pvm_make_byte (~PVM_VAL_BYTE (JITTER_TOP_STACK()));
  end
end

instruction bnotbu () # UBYTE -> UBYTE
  code
    JITTER_TOP_STACK() = pvm_make_ubyte (~PVM_VAL_UBYTE (JITTER_TOP_STACK()));
  end
end

instruction bnoth () # HALF -> HALF
  code
    JITTER_TOP_STACK() = pvm_make_half (~PVM_VAL_HALF (JITTER_TOP_STACK()));
  end
end

instruction bnothu () # UHALF -> UHALF
  code
    JITTER_TOP_STACK() = pvm_make_uhalf (~PVM_VAL_UHALF (JITTER_TOP_STACK()));
  end
end

instruction bnoti () # INT -> INT
  code
    JITTER_TOP_STACK() = pvm_make_int (~PVM_VAL_INT (JITTER_TOP_STACK()));
  end
end

instruction bnotiu () # UINT -> UINT
  code
    JITTER_TOP_STACK() = pvm_make_uint (~PVM_VAL_UINT (JITTER_TOP_STACK()));
  end
end

instruction bnotl () # LONG -> LONG
  code
    JITTER_TOP_STACK() = pvm_make_long (~PVM_VAL_LONG (JITTER_TOP_STACK()));
  end
end

instruction bnotlu () # ULONG -> ULONG
  code
   JITTER_TOP_STACK() = pvm_make_ulong (~PVM_VAL_ULONG (JITTER_TOP_STACK()));
  end
end

instruction bslb () # BYTE UINT -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bslbu () # UBYTE UINT -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bslh () # HALF UINT -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bslhu () # UHALF UINT -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsli () # INT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsll () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsllu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrb () # BYTE UINT -> BYTE
  code
#define F(res, a, b) \
  { res = pvm_make_byte (PVM_VAL_BYTE (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrbu () # UBYTE UINT -> UBYTE
  code
#define F(res, a, b) \
  { res = pvm_make_ubyte (PVM_VAL_UBYTE (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrh () # HALF UINT -> HALF
  code
#define F(res, a, b) \
  { res = pvm_make_half (PVM_VAL_HALF (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrhu () # UHALF UINT -> UHALF
  code
#define F(res, a, b) \
  { res = pvm_make_uhalf (PVM_VAL_UHALF (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsri () # INT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrl () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrlu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

## Branches

instruction ba (?f) # Branch always.
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction bz (?f) # Branch if zero top.
  code
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (JITTER_TOP_STACK()),
                                JITTER_ARGF0);
  end
end

instruction bzut (?f) # Branch if zero under-top.
  code
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (JITTER_UNDER_TOP_STACK()),
                                JITTER_ARGF0);
  end
end

instruction bnt (?n,?f) # Branch if not type top
  code
     JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_TAG (JITTER_TOP_STACK())
                                 == JITTER_ARGN0,
                                 JITTER_ARGF1);
  end
end

instruction bntut (?n,?f) # Branch if not type undertop.
  code
     JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_TAG (JITTER_UNDER_TOP_STACK())
                                   == JITTER_ARGN0,
                                 JITTER_ARGF1);
  end
end

## Conversion instructions.

instruction ltoi () # LONG -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int ((int64_t) PVM_VAL_LONG (JITTER_TOP_STACK ()));
  end
end

instruction ltoiu () # LONG -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) PVM_VAL_LONG (JITTER_TOP_STACK ()));
  end
end

instruction lutoi () # ULONG -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int ((int32_t) PVM_VAL_ULONG (JITTER_TOP_STACK ()));
  end
end

instruction lutoiu () # ULONG -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) PVM_VAL_ULONG (JITTER_TOP_STACK ()));
  end
end

instruction itol () # INT -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long ((int64_t) PVM_VAL_INT (JITTER_TOP_STACK ()));
  end
end

instruction iutol () # UINT -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long ((int64_t) PVM_VAL_UINT (JITTER_TOP_STACK ()));
  end
end

instruction iutolu () # UINT -> ULONG
  code
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) PVM_VAL_UINT (JITTER_TOP_STACK ()));
  end
end

instruction lutol () # ULONG -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long ((int64_t) PVM_VAL_ULONG (JITTER_TOP_STACK ()));
  end
end

instruction ltolu () # LONG -> ULONG
  code
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) PVM_VAL_LONG (JITTER_TOP_STACK ()));
  end
end

instruction iutoi () # UINT -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int ((int32_t) PVM_VAL_UINT (JITTER_TOP_STACK ()));
  end
end

instruction itoiu () # INT -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) PVM_VAL_INT (JITTER_TOP_STACK ()));
  end
end

instruction btobu () # BYTE -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte ((uint8_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction ltob () # LONG -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte ((int8_t) PVM_VAL_LONG (JITTER_TOP_STACK ()));
  end
end

instruction ltobu () # LONG -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte ((uint8_t) PVM_VAL_LONG (JITTER_TOP_STACK ()));
  end
end

instruction lutob () # ULONG -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte ((int8_t) PVM_VAL_ULONG (JITTER_TOP_STACK ()));
  end
end

instruction lutobu () # ULONG -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte ((uint8_t) PVM_VAL_ULONG (JITTER_TOP_STACK ()));
  end
end

instruction ltoh () # LONG -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half ((int16_t) PVM_VAL_LONG (JITTER_TOP_STACK ()));
  end
end

instruction ltohu () # LONG -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf ((uint16_t) PVM_VAL_LONG (JITTER_TOP_STACK ()));
  end
end

instruction lutoh () # ULONG -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half ((int16_t) PVM_VAL_ULONG (JITTER_TOP_STACK ()));
  end
end

instruction lutohu () # ULONG -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf ((uint16_t) PVM_VAL_ULONG (JITTER_TOP_STACK ()));
  end
end

instruction itob () # INT -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte ((int8_t) PVM_VAL_INT (JITTER_TOP_STACK ()));
  end
end

instruction itobu () # INT -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte ((uint8_t) PVM_VAL_INT (JITTER_TOP_STACK ()));
  end
end

instruction iutob () # UINT -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte ((int8_t) PVM_VAL_UINT (JITTER_TOP_STACK ()));
  end
end

instruction iutobu () # UINT -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte ((uint8_t) PVM_VAL_UINT (JITTER_TOP_STACK ()));
  end
end

instruction itoh () # INT -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half ((int16_t) PVM_VAL_INT (JITTER_TOP_STACK ()));
  end
end

instruction itohu () # INT -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf ((uint16_t) PVM_VAL_INT (JITTER_TOP_STACK ()));
  end
end

instruction iutoh () # UINT -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half ((int16_t) PVM_VAL_UINT (JITTER_TOP_STACK ()));
  end
end

instruction iutohu () # UINT -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf ((uint16_t) PVM_VAL_UINT (JITTER_TOP_STACK ()));
  end
end

instruction htoi () # HALF -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int ((int32_t) PVM_VAL_HALF (JITTER_TOP_STACK ()));
  end
end

instruction hutoi () # UHALF -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int ((int32_t) PVM_VAL_UHALF (JITTER_TOP_STACK ()));
  end
end

instruction htoiu () # HALF -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) PVM_VAL_HALF (JITTER_TOP_STACK ()));
  end
end

instruction hutoiu () # UHALF -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) PVM_VAL_UHALF (JITTER_TOP_STACK ()));
  end
end

instruction htob () # HALF -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte ((int8_t) PVM_VAL_HALF (JITTER_TOP_STACK ()));
  end
end

instruction htobu () # HALF -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte ((uint8_t) PVM_VAL_HALF (JITTER_TOP_STACK ()));
  end
end

instruction hutob () # UHALF -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte ((int8_t) PVM_VAL_UHALF (JITTER_TOP_STACK ()));
  end
end

instruction hutobu () # UHALF -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte ((uint8_t) PVM_VAL_UHALF (JITTER_TOP_STACK ()));
  end
end

instruction htoh () # HALF -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half ((int16_t) PVM_VAL_HALF (JITTER_TOP_STACK ()));
  end
end

instruction htohu () # HALF -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf ((uint16_t) PVM_VAL_HALF (JITTER_TOP_STACK ()));
  end
end

instruction hutoh () # UHALF -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half ((int16_t) PVM_VAL_UHALF (JITTER_TOP_STACK ()));
  end
end

instruction hutohu () # UHALF -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf ((uint16_t) PVM_VAL_UHALF (JITTER_TOP_STACK ()));
  end
end

instruction btob () # BYTE -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte ((int8_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction butob () # UBYTE -> BYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_byte ((int8_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction butobu () # UBYTE -> UBYTE
  code
    JITTER_TOP_STACK()
      = pvm_make_ubyte ((uint8_t) PVM_VAL_UBYTE (JITTER_TOP_STACK ()));
  end
end

instruction btoh () # BYTE -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half ((int16_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction btohu () # BYTE -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf ((uint16_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction butoh () # UBYTE -> HALF
  code
    JITTER_TOP_STACK()
      = pvm_make_half ((int16_t) PVM_VAL_UBYTE (JITTER_TOP_STACK ()));
  end
end

instruction butohu () # UBYTE -> UHALF
  code
    JITTER_TOP_STACK()
      = pvm_make_uhalf ((uint16_t) PVM_VAL_UBYTE (JITTER_TOP_STACK ()));
  end
end

instruction btoi () # BYTE -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int ((int32_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction btoiu () # BYTE -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction butoi () # UBYTE -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int ((int32_t) PVM_VAL_UBYTE (JITTER_TOP_STACK ()));
  end
end

instruction butoiu () # UBYTE -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) PVM_VAL_UBYTE (JITTER_TOP_STACK ()));
  end
end

instruction itoui () # INT -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_uint ((uint32_t) PVM_VAL_INT (JITTER_TOP_STACK ()));
  end
end

instruction itolu () # INT -> ULONG
  code
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) PVM_VAL_INT (JITTER_TOP_STACK ()));
  end
end

instruction htol () # HALF -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long ((int64_t) PVM_VAL_HALF (JITTER_TOP_STACK ()));
  end
end

instruction htolu () # HALF -> ULONG
  code
    JITTER_TOP_STACK()
      = pvm_make_ulong ((int64_t) PVM_VAL_HALF (JITTER_TOP_STACK ()));
  end
end

instruction hutol () # UHALF -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long ((int64_t) PVM_VAL_UHALF (JITTER_TOP_STACK ()));
  end
end

instruction hutolu () # UHALF -> ULONG
  code
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) PVM_VAL_UHALF (JITTER_TOP_STACK ()));
  end
end

instruction btol () # BYTE -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long ((int64_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction btolu () # BYTE -> ULONG
  code
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) PVM_VAL_BYTE (JITTER_TOP_STACK ()));
  end
end

instruction butol () # UBYTE -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long ((int64_t) PVM_VAL_UBYTE (JITTER_TOP_STACK ()));
  end
end

instruction butolu () # UBYTE -> ULONG
  code
    JITTER_TOP_STACK()
      = pvm_make_ulong ((uint64_t) PVM_VAL_UBYTE (JITTER_TOP_STACK ()));
  end
end

## Array instructions.

# TYP [IDX VAL]... ULONG(ninitializer) ULONG(nelem) -> ARR
instruction mka ()
  code
    size_t i;
    pvm_val nelem, ninitializer, arr;

    ninitializer = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    arr = pvm_make_array (nelem, PVM_NULL /* type */);
    for (i = 0; i < PVM_VAL_ULONG (ninitializer); ++i)
    {
      size_t index
        = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());

      PVM_VAL_ARR_ELEM (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_ARR_TYPE (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (arr);
  end
end

instruction aset () # ARR ULONG VAL -> ARR
  code
    uint64_t idx;
    pvm_val val;

    val= JITTER_TOP_STACK ();
    idx = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    /* XXX: Jump to Eabounds if index out of range.  */
    PVM_VAL_ARR_ELEM (JITTER_TOP_STACK (), idx) = val;
  end
end

instruction aref () # ARR ULONG -> VAL
  code
    /* XXX: Jump to Eabounds if index out of range.  */
#define F(res, a, b) \
  { res = PVM_VAL_ARR_ELEM (a, PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction alen () # ARR -> ULONG
  code
    JITTER_TOP_STACK ()
      = PVM_VAL_ARR_NELEM (JITTER_TOP_STACK());
  end
end

## Struct instructions.

instruction mksct () # [STR VAL]... ULONG -> SCT
  code
    size_t e;
    pvm_val nelem, sct;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    sct = pvm_make_struct (nelem);

    for (e = 0; e < PVM_VAL_ULONG (nelem); ++e)
    {
      PVM_VAL_SCT_ELEM_VALUE (sct, e) = JITTER_TOP_STACK ();
      PVM_VAL_SCT_ELEM_NAME (sct, e) = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (sct);
  end
end

instruction revsct () # SCT -> SCT
  code
    pvm_reverse_struct (JITTER_TOP_STACK ());
  end
end

instruction sctset () # SCT VAL STR -> SCT
  code
  end
end

instruction sctref () # SCT STR -> VAL
  code
#define F(res, a, b) { res = pvm_ref_struct (a, b); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

## Offset instructions.

instruction mko () # TYP EXP ULONG -> OFF
  code
    pvm_val unit, base_type, magnitude;

    unit = JITTER_TOP_STACK ();
    magnitude = JITTER_UNDER_TOP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    base_type = JITTER_TOP_STACK ();

    JITTER_TOP_STACK () =
      pvm_make_offset (base_type, magnitude, unit);
  end
end

## Type related instructions.

instruction mktyi () # ULONG UINT -> TYP
  code
    pvm_val size = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    pvm_val signed_p = PVM_VAL_UINT (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();

    JITTER_TOP_STACK () = pvm_make_integral_type (size, signed_p);
  end
end

instruction mktys () # _ -> TYP
  code
    JITTER_PUSH_STACK (pvm_make_string_type ());
  end
end

instruction mktyo () # TYP INT -> TYP
  code
#define F(res, a, b) \
  { res = pvm_make_offset_type (a, b); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mktym () # _ -> TYP
  code
    JITTER_PUSH_STACK (pvm_make_map_type ());
  end
end

instruction mktya () # TYP ULONG -> TYP
  code
#define F(res, a, b) { res = pvm_make_array_type (b, a); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

instruction mktysct () # [STRING TYP]... NLONG -> TYP
  code
    size_t i;
    pvm_val nelem, *etypes, *enames;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_struct_attrs (nelem, &etypes, &enames);

    for (i = 0; i < PVM_VAL_ULONG (nelem); ++i)
    {
      /* XXX: check pvm_val types?  */

      enames[i] = JITTER_UNDER_TOP_STACK ();
      etypes[i] = JITTER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_struct_type (nelem,
                                             enames, etypes));
  end
end

instruction typof () # VAL -> TYP
  code
    JITTER_TOP_STACK () = pvm_typeof (JITTER_TOP_STACK ());
  end
end

# Instructions to access the IO space: mapping.

instruction mkm () # TYP ULONG -> MAP
  code
#define F(res, a, b) { res = pvm_make_map (a, b); }
    JITTER_BINARY_STACK (F);  
#undef F
  end
end

instruction peek () # MAP -> VAL
  code
  end
end

instruction poke () # MAP VAL -> _
  code
  end
end
