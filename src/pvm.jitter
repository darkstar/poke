## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2017 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
  tos-stack "jitter_uint" "stack"
end

## Register classes.

register-class r 5
  code
    union jitter_word
  end
end

## Functions and globals to wrap.

wrapped-functions
  printf
end

#wrapped-globals
#  pvm_printf_format_string
#end

## Prologue and epilogue for the generated code.

early-header-c
  code
#   include "pvm.h"
  end
end

early-c
  code
#   include <string.h>
  end
end

late-c
  code
  end
end

## PVM state.

state-struct-backing-c
  code
      /* XXX enum pvm_exit_code exit_code;  */
      int exit_code;
      /* pvm_val result_value */
      uint64_t result_value;
  end
end

state-initialization-c
  code
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end

## VM instructions

instruction exit ()
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    original_state->pvm_state_backing.exit_code
      = pvm_make_int (JITTER_TOP_STACK());
    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    if (1 /* !EOS == expression */)
    {
      original_state->pvm_state_backing.result_value
        = JITTER_TOP_STACK();
      JITTER_DROP_STACK ();
    }

    JITTER_EXIT ();
  end
end

## Miscellaneous Instructions

instruction nop ()
  code
  end
end

instruction drop ()
  code
    JITTER_DROP_STACK();
  end
end

instruction push (?Rnl)
  code
    jitter_uint k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

instruction pop (!R)
  code
    jitter_uint top = JITTER_TOP_STACK();
    JITTER_DROP_STACK();
    JITTER_ARGN0 = top;
  end
end

instruction setr (!R)
  code
    JITTER_ARGN0 = JITTER_TOP_STACK();
  end
end

## Operators instructions.

# Integer arithmetic.

# XXX: one of the references A or B may be lost when assigning to RES
#      depending on TOS or no TOS.  So refcounts must be decremented
#      in both A and B.

# XXX: value preserving vs sign preserving?
#      C standardized in value preserving, with promotions.
#      Java avoids this problem by not having unsigned types.. the fuckers :D
#      But we need unsigned types.

instruction addi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) + PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) + PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) + PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction addlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) + PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) - PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) - PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction subl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) - PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction sublu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) - PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muli () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) * PVM_VAL_INT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction muliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) * PVM_VAL_UINT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mull () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) * PVM_VAL_LONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction mullu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) * PVM_VAL_ULONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divi () # INT INT -> INT
  code
  /* XXX: handle division by 0.  */
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) / PVM_VAL_INT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction diviu () # UINT UINT -> UINT
  code
  /* XXX: handle division by 0.  */
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) / PVM_VAL_UINT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divl () # LONG LONG -> LONG
  code
  /* XXX: handle division by 0.  */
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) / PVM_VAL_LONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction divlu () # ULONG ULONG -> ULONG
  code
  /* XXX: handle division by 0.  */
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) / PVM_VAL_ULONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) % PVM_VAL_INT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) % PVM_VAL_UINT (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) % PVM_VAL_LONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction modlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) % PVM_VAL_ULONG (b)); }
  JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction negi () # INT -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int (- PVM_VAL_INT (JITTER_TOP_STACK()));
  end
end

instruction negiu () # UINT -> UINT
  code
    JITTER_TOP_STACK()
      = pvm_make_int (PVM_VAL_INT (JITTER_TOP_STACK()));
  end
end

instruction negl () # LONG -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long (- PVM_VAL_LONG (JITTER_TOP_STACK()));
  end
end

instruction neglu () # LONG -> LONG
  code
    JITTER_TOP_STACK()
      = pvm_make_long (PVM_VAL_LONG (JITTER_TOP_STACK()));
  end
end

# Equality/inequality.

instruction eqi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) == PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) == PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eql () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) == PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) == PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) != PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction neiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) != PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) != PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) != PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction eqs () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) == 0); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction nes () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) != 0); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

# Comparison instructions.

instruction lti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) < PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) < PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) < PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction ltlu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) < PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) <= PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction leiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) <= PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) <= PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction lelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) <= PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gti () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) > PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) > PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtl () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) > PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gtlu () # ULONG ULONG - INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) > PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gei () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) >= PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction geiu () # UINT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_UINT (a) >= PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gel () # LONG LONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_LONG (a) >= PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction gelu () # ULONG ULONG -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_ULONG (a) >= PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction lts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) < 0); }
    JITTER_BINARY_STACK (F);
#undef F
  end
end

instruction gts () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) > 0); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction ges () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) >= 0); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction les () # STR STR -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (strcmp (PVM_VAL_STR (a), PVM_VAL_STR (b)) <= 0); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Concatenation instructions.

instruction sconc () # STR STR -> STR
  code
#define F(res, a, b)                                  \
  {                                                   \
     char *sa = PVM_VAL_STR (a);                      \
     char *sb = PVM_VAL_STR (b);                      \
     char *s = xmalloc (strlen (sa) + strlen (sb) + 1);\
     strcpy (s, sa);                                  \
     strcat (s, sb);                                  \
     res = pvm_make_string (s);                       \
  }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Logical instructions.

instruction and () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) && PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction or () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) || PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction not () # INT -> INT
  code
    JITTER_TOP_STACK()
      = pvm_make_int (! PVM_VAL_INT(JITTER_TOP_STACK()));
  end
end

# Bitwise operators.

instruction bxori () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) ^ PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxoriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) ^ PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) ^ PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bxorlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) ^ PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bori () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) | PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction boriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) | PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) | PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction borlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) | PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandi () # INT INT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) & PVM_VAL_INT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandiu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) & PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandl () # LONG LONG -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) & PVM_VAL_LONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bandlu () # ULONG ULONG -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) & PVM_VAL_ULONG (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bnoti () # INT -> INT
  code
    JITTER_TOP_STACK() = pvm_make_int (~PVM_VAL_INT (JITTER_TOP_STACK()));
  end
end

instruction bnotiu () # UINT -> UINT
  code
    JITTER_TOP_STACK() = pvm_make_uint (~PVM_VAL_UINT (JITTER_TOP_STACK()));
  end
end

instruction bnotl () # LONG -> LONG
  code
    JITTER_TOP_STACK() = pvm_make_long (~PVM_VAL_LONG (JITTER_TOP_STACK()));
  end
end

instruction bnotlu () # ULONG -> ULONG
  code
   JITTER_TOP_STACK() = pvm_make_ulong (~PVM_VAL_ULONG (JITTER_TOP_STACK()));
  end
end

instruction bsli () # INT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsliu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsll () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsllu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) << PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsri () # INT UINT -> INT
  code
#define F(res, a, b) \
  { res = pvm_make_int (PVM_VAL_INT (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsriu () # UINT UINT -> UINT
  code
#define F(res, a, b) \
  { res = pvm_make_uint (PVM_VAL_UINT (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrl () # LONG UINT -> LONG
  code
#define F(res, a, b) \
  { res = pvm_make_long (PVM_VAL_LONG (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

instruction bsrlu () # ULONG UINT -> ULONG
  code
#define F(res, a, b) \
  { res = pvm_make_ulong (PVM_VAL_ULONG (a) >> PVM_VAL_UINT (b)); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

## Branches

instruction ba (?f) # Branch always.
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction bz (?f) # Branch if zero top.
  code
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (JITTER_TOP_STACK()),
                                JITTER_ARGF0);
  end
end

instruction bnt (?n,?f) # Branch if not type top
  code
     JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_TAG (JITTER_TOP_STACK())
                                   == JITTER_ARGN0,
                                 JITTER_ARGF1);
  end
end

instruction bntut (?n,?f) # Branch if not type undertop.
  code
     JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_TAG (JITTER_UNDER_TOP_STACK())
                                   == JITTER_ARGN0,
                                 JITTER_ARGF1);
  end
end

# Conversion instructions.
