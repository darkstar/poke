## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2019 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
  tos-stack "pvm_val" "stack"
  ntos-stack "jitter_uint" "returnstack"
  ntos-stack "struct pvm_exception_handler *" "exceptionstack"
end



## Register classes.

register-class r 4
  code
    pvm_val
  end
end



## Functions and globals to wrap.

wrapped-functions
  printf
  pvm_assert
  pvm_env_lookup
  pvm_env_register
  pvm_env_pop_frame
  pvm_env_push_frame
  pvm_make_int
  pvm_make_uint
  pvm_make_long
  pvm_make_ulong
  pvm_make_string
  pvm_make_array
  pvm_make_struct
  pvm_make_offset
  pvm_make_integral_type
  pvm_make_string_type
  pvm_make_offset_type
  pvm_make_array_type
  pvm_allocate_struct_attrs
  pvm_make_struct_type
  pvm_typeof
  ios_cur
  ios_read_int
  ios_read_uint
  ios_read_long
  ios_read_ulong
  ios_read_string
end

#wrapped-globals
#  pvm_printf_format_string
#end



## Embedded C code.

early-header-c
  code
#   include "pvm.h"
#   include "ios.h"

    /* Exception handlers, that are installed in the "exceptionstack".

       EXCEPTION is the exception type, either one of the E_* values defined
       above, or any integer >= 256 for user-defined exceptions.

       MAIN_STACK_HEIGHT and RETURN_STACK_HEIGHT are the heights of
       the main and return stacks, to restore before transferring
       control to the exception handler.

       CODE is the program point where the exception handler starts.

       ENV is the run-time environment to restore before transferring
       control to the exception handler.  */

    struct pvm_exception_handler
    {
      int exception;
      jitter_stack_height main_stack_height;
      jitter_stack_height return_stack_height;
      pvm_program_point code;
      pvm_env env;
    };
  end
end

early-c
  code
#   include <string.h>
  end
end

late-header-c
  code
    extern jitter_uint printer_hi;

    /* Macro to raise an exception from within an instruction.  This
       is used in the RAISE instruction itself, and also in instructions
       that can fail, such as integer division or IO.

       The code in the macro looks for the first matching exception
       handler in the exception handlers stack.  Then it restores the
       heights of the main stack and the return stack, restores the
       original dynamic environment, and then pushes the exception
       type as an integer in the main stack, before branching to the
       exception handler.  */

#define PVM_RAISE(EXCEPTION)                                           \
    while (1)                                                          \
    {                                                                  \
      struct pvm_exception_handler *ehandler                           \
        = JITTER_TOP_EXCEPTIONSTACK ();                                \
      int handler_exception = ehandler->exception;                     \
                                                                       \
      JITTER_DROP_EXCEPTIONSTACK ();                                   \
                                                                       \
      if (handler_exception == 0 || handler_exception == (EXCEPTION))  \
      {                                                                \
        JITTER_SET_HEIGHT_STACK (ehandler->main_stack_height);         \
        JITTER_SET_HEIGHT_RETURNSTACK (ehandler->return_stack_height); \
                                                                       \
        JITTER_PUSH_STACK (pvm_make_int ((EXCEPTION), 32));            \
                                                                       \
        jitter_state_runtime.env = ehandler->env;                      \
        JITTER_BRANCH (ehandler->code);                                \
        break;                                                         \
      }                                                                \
    }

    /* Macros to implement different kind of instructions.  These are to
       avoid flagrant code replication below.  */

/* Binary numeric operations generating a boolean in the stack.
   ( TYPE TYPE -- TYPE TYPE INT ) */
# define PVM_BOOL_BINOP(TYPE,OP)                                             \
   do                                                                        \
    {                                                                        \
      pvm_val res = pvm_make_int (PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ()) \
                                  OP PVM_VAL_##TYPE (JITTER_TOP_STACK ()), 32); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Unary numeric operations.
   ( TYPE -- TYPE TYPE) */
# define PVM_UNOP(TYPE,TYPER,TYPERLC,OP)                                     \
   do                                                                        \
    {                                                                        \
      int size = PVM_VAL_##TYPER##_SIZE (JITTER_TOP_STACK ());               \
      pvm_val res = pvm_make_##TYPERLC (OP PVM_VAL_##TYPE (JITTER_TOP_STACK ()), size); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)
   

/* Binary numeric operations.
  ( TYPE TYPE -- TYPE TYPE TYPE ) */
# define PVM_BINOP(TYPEA,TYPEB,TYPER,TYPERLC,OP)                             \
   do                                                                        \
    {                                                                        \
      int size = PVM_VAL_##TYPER##_SIZE (JITTER_UNDER_TOP_STACK ());       \
      pvm_val res = pvm_make_##TYPERLC (PVM_VAL_##TYPEA (JITTER_UNDER_TOP_STACK ()) \
                                        OP PVM_VAL_##TYPEB (JITTER_TOP_STACK ()), size); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Same, but with division by zero run-time check.  */
# define PVM_CHECKED_BINOP(TYPEA,TYPEB,TYPER,TYPERLC,OP)                     \
   if (PVM_VAL_##TYPEB (JITTER_TOP_STACK ()) == 0)                           \
   {                                                                         \
      PVM_RAISE (PVM_E_DIV_BY_ZERO);                                         \
   }                                                                         \
   else                                                                      \
   {                                                                         \
      PVM_BINOP (TYPEA, TYPEB, TYPER, TYPERLC, OP);                          \
   }

/* Conversion instructions.
   ( TYPE -- TYPE RTYPE )  */
#define PVM_CONVOP(TYPE, TYPEC, RTYPELC, RTYPEC)                             \
   do                                                                        \
    {                                                                        \
      jitter_uint tsize = JITTER_ARGN0;                                      \
      TYPEC val = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                      \
      JITTER_PUSH_STACK (pvm_make_##RTYPELC ((RTYPEC) val, tsize));          \
    } while (0)

/* Auxiliary macros used in PVM_PEEK and PVM_POKE below.  */
#define PVM_IOS_ARGS_INT                                                     \
  io, offset, 0, bits, endian, nenc, &value
#define PVM_IOS_ARGS_UINT                                                    \
  io, offset, 0, bits, endian, &value
#define PVM_IOS_ARGS_WRITE_INT                                               \
  io, offset, 0, bits, endian, nenc, value
#define PVM_IOS_ARGS_WRITE_UINT                                              \
  io, offset, 0, bits, endian, value

/* Integral peek instructions.
   ( OFF -- VAL )  */
#define PVM_PEEK(TYPE,IOTYPE,NENC,ENDIAN,BITS,IOARGS)                        \
  do                                                                         \
   {                                                                         \
     __attribute__((unused)) enum ios_nenc nenc = (NENC);                    \
     enum ios_endian endian = (ENDIAN);                                      \
     int bits = (BITS);                                                      \
     IOTYPE##64_t value;                                                     \
     ios io;                                                                 \
     ios_off offset;                                                         \
                                                                             \
     if ((io = ios_cur ()) == NULL)                                          \
        PVM_RAISE (PVM_E_NO_IOS);                                            \
                                                                             \
     offset = (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()))\
               * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ()))); \
                                                                             \
     if (ios_read_##IOTYPE (IOARGS) != IOS_OK)                               \
       {                                                                     \
         /* XXX: raise an IO exception for a != EOF error.  */               \
         JITTER_TOP_STACK () = PVM_NULL;                                     \
       }                                                                     \
     else                                                                    \
       JITTER_TOP_STACK () = pvm_make_##IOTYPE (value, bits);                \
   } while (0)

/* Integral poke instructions.
   ( OFF VAL -- )  */
#define PVM_POKE(TYPE,IOTYPE,NENC,ENDIAN,BITS,IOARGS)                        \
  do                                                                         \
   {                                                                         \
     __attribute__((unused)) enum ios_nenc nenc = (NENC);                    \
     enum ios_endian endian = (ENDIAN);                                      \
     int bits = (BITS);                                                      \
     IOTYPE##64_t value = PVM_VAL_##TYPE (JITTER_TOP_STACK ());              \
     pvm_val offset_val = JITTER_UNDER_TOP_STACK ();                         \
     ios io;                                                                 \
     ios_off offset;                                                         \
                                                                             \
     JITTER_DROP_STACK ();                                                   \
     JITTER_DROP_STACK ();                                                   \
                                                                             \
     if ((io = ios_cur ()) == NULL)                                          \
        PVM_RAISE (PVM_E_NO_IOS);                                            \
                                                                             \
     offset = (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (offset_val))         \
               * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (offset_val)));          \
                                                                             \
     if (ios_write_##IOTYPE (IOARGS) != IOS_OK)                              \
       {                                                                     \
         /* XXX: raise an IO exception.  */                                  \
       }                                                                     \
   } while (0)

/* Macro to call to a closure.  This is used in the isntruction CALL,
   and also other instructions required to... call :D The argument
   should be a closure (surprise.)  */

#define PVM_CALL(CLS)                                                        \
   do                                                                        \
    {                                                                        \
       /* Make place for the return address in the return stack.  */         \
       /* actual value will be written by the callee. */                     \
       JITTER_PUSH_UNSPECIFIED_RETURNSTACK();                                \
                                                                             \
       /* Save the current environment and use the callee's environment. */     \
       JITTER_PUSH_RETURNSTACK ((jitter_uint) (uintptr_t) jitter_state_runtime.env); \
       jitter_state_runtime.env = PVM_VAL_CLS_ENV ((CLS));                   \
                                                                             \
       /* Branch-and-link to the native code, whose first instruction will */ \
       /*  be a prolog. */                                                   \
       JITTER_BRANCH_AND_LINK (PVM_VAL_CLS_ENTRY_POINT ((CLS)));           \
    } while (0)
  end
end

late-c
  code
    jitter_uint printer_hi;
  end
end

printer-c
  code
    void
    pvm_literal_printer_cast (FILE *out, jitter_uint val)
    {
      fprintf (out, "%" JITTER_PRIu, val);
    }

    void
    pvm_literal_printer (FILE *out, jitter_uint val)
    {
      pvm_print_val (out, (pvm_val) val, 10, 0);
    }

    void
    pvm_literal_printer_hi (FILE *out, jitter_uint hi)
    {
      fprintf (out, "%%hi(0x%" JITTER_PRIx ")", hi);
      printer_hi = hi; /* This sucks */
    }

    void
    pvm_literal_printer_lo (FILE *out, jitter_uint lo)
    {
      fprintf (out, "%%lo(0x%" JITTER_PRIx") (", lo);
      pvm_print_val (out,
                    ((pvm_val) printer_hi << 32) | lo,
                    10, 0);
      fputc (')', out);
      printer_hi = 0;
    }

    void
    popf_printer (FILE *out, jitter_uint nframes)
    {
      fprintf (out, "%" JITTER_PRIu, nframes);
    }

    void
    bits_printer (FILE *out, jitter_uint val)
    {
        fprintf (out, "%" JITTER_PRIu, val);
    }

    void
    endian_printer (FILE *out, jitter_uint val)
    {
       fprintf (out, "%s",
               val == IOS_ENDIAN_MSB ? "big" : "little");
    }

    void
    nenc_printer (FILE *out, jitter_uint val)
    {
       fprintf (out, "%s",
                val == IOS_NENC_1 ? "1c" : "2c");
    }
  end
end



## PVM state.

# Jitter supports maintaining a VM state which is splitted in
# `backing' and `runtime', so the question arises what to put in either
# part of the state.  According to the comments generated by jitterc:
#
# "The machine state is separated into the backing and the more
#  compact runtime data structures, to be allocated in registers as
#  far as possible.  These are just a forward-declarations: the actual
#  definitions are machine-generated."
#
# and:
#
# "The state backing and runtime are initialized at the same time, and
#  in fact the distinction between them is invisible to the VM user."
#
# So it looks like both `backing' and `runtime' are available at
# runtime, but accessing runtime is much more efficient because it is
# kept in host machine registers if possible.

state-struct-backing-c
  code
      enum pvm_exit_code exit_code;
      pvm_val result_value;
      jitter_stack_height canary;
  end
end

state-struct-runtime-c
  code
      pvm_env env;
      uint32_t push_hi;
      uint32_t endian;
      uint32_t nenc;
  end
end

state-initialization-c
  code
      jitter_state_backing->canary = NULL;
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
      /* XXX: are these reasonable defaults? */
      jitter_state_runtime->endian = IOS_ENDIAN_MSB;
      jitter_state_runtime->nenc = IOS_NENC_2;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end



## VM instructions

instruction canary ()
  code
     jitter_original_state->pvm_state_backing.canary
      = JITTER_HEIGHT_STACK ();
  end
end

instruction exit ()
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    jitter_original_state->pvm_state_backing.exit_code
      = PVM_VAL_INT (JITTER_TOP_STACK());

    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    jitter_original_state->pvm_state_backing.result_value
                = JITTER_TOP_STACK();
    JITTER_DROP_STACK ();

    /* Check for the stack centinel, but only if it was
       installed.  */
    if (jitter_original_state->pvm_state_backing.canary != NULL)
      assert (jitter_original_state->pvm_state_backing.canary
              == JITTER_HEIGHT_STACK ());

    JITTER_EXIT ();
  end
end



## Function management instructions

instruction call () # ARG1 ... ARGN CLOSURE -> RETVAL
  caller
  code
    pvm_val closure = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
    PVM_CALL (closure);
  end
end

instruction prolog ()
  callee
  code
    /* Fill the return stack slot with the return address.  The return
       stack has already been pushed (with an unspecified value on the
       under top) by the caller. */
    JITTER_UNDER_TOP_RETURNSTACK() = (jitter_uint) JITTER_LINK;
  end
end

instruction return ()
  code
    jitter_uint return_address;

    /* Restore the environment of the caller.  */
    jitter_state_runtime.env = (pvm_env) JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK();

    return_address = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();

    JITTER_RETURN (return_address);
  end
end



## Environment instructions

instruction pushf ()
  code
    jitter_state_runtime.env
       = pvm_env_push_frame (jitter_state_runtime.env);
  end
end

instruction popf (?n popf_printer)
  code
    jitter_uint i;

    for (i = 0; i < JITTER_ARGN0; ++i)
        jitter_state_runtime.env
           = pvm_env_pop_frame (jitter_state_runtime.env);
  end
end

# pushvar BACK, OVER
instruction pushvar (?n, ?n) #  ( -- VAL )
  code
    JITTER_PUSH_STACK (pvm_env_lookup (jitter_state_runtime.env,
                                       (int) JITTER_ARGN0,
                                       (int) JITTER_ARGN1));
  end
end

instruction popvar (?n, ?n) # ( VAL -- )
  code
    pvm_env_set_var (jitter_state_runtime.env,
                     (int) JITTER_ARGN0,
                     (int) JITTER_ARGN1,
                     JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

instruction regvar () # ( VAL -- )
  code
    pvm_env_register (jitter_state_runtime.env,
                      JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Put Environment in Closure
instruction pec () # ( CLS -- CLS )
  code
    pvm_val cls = JITTER_TOP_STACK ();
    PVM_VAL_CLS_ENV (cls) = jitter_state_runtime.env;
  end
end



## Miscellaneous Instructions

instruction nop ()
  code
  end
end

instruction note (?n pvm_literal_printer)
  code
  end
end

instruction siz () # ( VAL -- VAL OFF )
  code
    JITTER_PUSH_STACK (pvm_sizeof (JITTER_TOP_STACK ()));
  end
end

instruction print () # ( STR -- )
  code
    pvm_print_string (stdout, JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

instruction strace () # ( -- )
  code
     pvm_val tmp[1024];
     int i = 0, j;

     while (JITTER_HEIGHT_STACK () !=
            jitter_original_state->pvm_state_backing.canary)
        {
          assert (i < 1024);

          pvm_print_val (stdout, JITTER_TOP_STACK (), 16, 0);
          fprintf (stdout, "\n");
          tmp[i++] = JITTER_TOP_STACK ();
          JITTER_DROP_STACK ();
        }

     /* Restore the stack.  */
     for (j = (i - 1); j >= 0; j--)
        JITTER_PUSH_STACK (tmp[j]);
  end
end



## Stack manipulation instructions

instruction drop () # ( A -- )
  code
    JITTER_DROP_STACK();
  end
end

instruction drop2 () # ( A B -- )
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

instruction drop3 () # ( A B C -- )
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

instruction drop4 () # ( A B C D -- )
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end


instruction push (?nl pvm_literal_printer) # ( -- A )
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

instruction pushr (?R)
  code
    JITTER_PUSH_STACK (JITTER_ARG0);
  end
end

instruction swap () # ( A B -- B A )
  code
    pvm_val tmp = JITTER_UNDER_TOP_STACK ();
    JITTER_UNDER_TOP_STACK () = JITTER_TOP_STACK ();
    JITTER_TOP_STACK () = tmp;
  end
end

instruction nip () # ( A B -- B )
  code
    JITTER_NIP_STACK();
  end
end

instruction nip2 () # ( A B C -- C )
  code
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
  end
end

instruction nip3 () # ( A B C D -- D )
  code
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
  end
end


instruction dup () # ( A -- A A )
  code
    JITTER_DUP_STACK ();
  end
end

instruction rot () # ( A B C -- B C A )
  code
   pvm_val a, b, c;

   c = JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
   b = JITTER_TOP_STACK ();
   a = JITTER_UNDER_TOP_STACK ();

   JITTER_UNDER_TOP_STACK () = b;
   JITTER_TOP_STACK () = c;
   JITTER_PUSH_STACK (a);
  end
end

instruction nrot () # ( A B C -- C A B )
  code
   pvm_val a, b, c;

   c = JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
   b = JITTER_TOP_STACK ();
   a = JITTER_UNDER_TOP_STACK ();

   JITTER_UNDER_TOP_STACK () = c;
   JITTER_TOP_STACK () = a;
   JITTER_PUSH_STACK (b);
  end
end

instruction pushhi (?nl pvm_literal_printer_hi)
  code
     jitter_state_runtime.push_hi
       = JITTER_ARGN0;
  end
end

instruction pushlo (?nl pvm_literal_printer_lo)
  code
     pvm_val k
       = ((pvm_val) jitter_state_runtime.push_hi << 32)
         | JITTER_ARGN0;
     JITTER_PUSH_STACK (k);
  end
end

instruction push32 (?nl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK (k);
  end
end

instruction popr (!R)
  code
    JITTER_ARG0 = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end

instruction setr (!R)
  code
    JITTER_ARG0 = JITTER_TOP_STACK();
  end
end

instruction saver (?R)
  code
    JITTER_PUSH_RETURNSTACK (JITTER_ARG0);
  end
end

instruction restorer (!R)
  code
    JITTER_ARG0 = JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK ();
  end
end

instruction sel () # ( VAL -- VAL ULONG )
  code
    JITTER_PUSH_STACK (pvm_elemsof (JITTER_TOP_STACK ()));
  end
end



## Operators instructions.

# Integer arithmetic.
#
# The following instructions assume that both operands have the same
# size in bits.

instruction addi () # ( INT INT -- INT INT INT)
  code
    PVM_BINOP (INT, INT, INT, int,  +);
  end
end

instruction addiu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint,  +);
  end
end

instruction addl () # ( LONG LONG -- LONG LONG LONG)
  code
    PVM_BINOP (LONG, LONG, LONG, long,  +);
  end
end

instruction addlu () # ( ULONG ULONG -- ULONG ULONG ULONG )
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong,  +);
  end
end

instruction subi () # ( INT INT -- INT INT INT )
  code
    PVM_BINOP (INT, INT, INT, int,  -);
  end
end

instruction subiu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint,  -);
  end
end

instruction subl () # ( LONG LONG -- LONG LONG LONG )
  code
    PVM_BINOP (LONG, LONG, LONG, long,  -);
  end
end

instruction sublu () # ( ULONG ULONG -- ULONG ULONG ULONG )
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong,  -);
  end
end

instruction muli () # ( INT INT -- INT INT INT )
  code
    PVM_BINOP (INT, INT, INT, int,  *);
  end
end

instruction muliu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint,  *);
  end
end

instruction mull () # ( LONG LONG -- LONG LONG LONG )
  code
    PVM_BINOP (LONG, LONG, LONG, long,  *);
  end
end

instruction mullu () # ( ULONG ULONG -- ULONG ULONG ULONG )
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong,  *);
  end
end

instruction divi () # ( INT INT -- INT INT INT )
  code
    PVM_CHECKED_BINOP (INT, INT, INT, int, /);
  end
end

instruction diviu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_CHECKED_BINOP (UINT, UINT, UINT, uint, /);
  end
end

instruction divl () # ( LONG LONG -- LONG LONG LONG )
  code
    PVM_CHECKED_BINOP (LONG, LONG, LONG, long, /);
  end
end

instruction divlu () # ( ULONG ULONG -- ULONG ULONG ULONG )
  code
    PVM_CHECKED_BINOP (ULONG, ULONG, ULONG, ulong, /);
  end
end

instruction modi () # ( INT INT -- INT INT INT )
  code
    PVM_CHECKED_BINOP (INT, INT, INT, int, %);
  end
end

instruction modiu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_CHECKED_BINOP (UINT, UINT, UINT, uint, %);
  end
end

instruction modl () # ( LONG LONG -- LONG LONG LONG )
  code
    PVM_CHECKED_BINOP (LONG, LONG, LONG, long, %);
  end
end

instruction modlu () # ( ULONG ULONG -- ULONG ULONG ULONG )
  code
    PVM_CHECKED_BINOP (ULONG, ULONG, ULONG, ulong, %);
  end
end

instruction negi () # ( INT -- INT INT )
  code
    PVM_UNOP (INT, INT, int, -);
  end
end

instruction negiu () # ( UINT -- UINT UINT )
  code
    PVM_UNOP (UINT, UINT, uint, -);
  end
end

instruction negl () # ( LONG -- LONG LONG )
  code
    PVM_UNOP (LONG, LONG, long, -);
  end
end

instruction neglu () # ( LONG -- LONG )
  code
    PVM_UNOP (ULONG, ULONG, ulong, -);
  end
end

# Equality/inequality

instruction eqi () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, ==);
  end
end

instruction eqiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, ==);
  end
end

instruction eql () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, ==);
  end
end

instruction eqlu () # ( ULONG ULONG -- ULONG ULONG INT )
  code
     PVM_BOOL_BINOP (ULONG, ==);
  end
end

instruction nei () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, !=);
  end
end

instruction neiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, !=);
  end
end

instruction nel () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, !=);
  end
end

instruction nelu () # ULONG ULONG - ULONG ULONG INT
  code
     PVM_BOOL_BINOP (ULONG, !=);
  end
end

instruction eqs () # ( STR STR -- STR STR INT )
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) == 0,
                                32);
    JITTER_PUSH_STACK (res);
  end
end

instruction nes () # ( STR STR -- STR STR INT )
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) != 0,
                                32);
    JITTER_PUSH_STACK (res);
  end
end

# Comparison instructions.

instruction lti () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, <);
  end
end

instruction ltiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, <);
  end
end

instruction ltl () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, <);
  end
end

instruction ltlu () # ( ULONG ULONG -- ULONG ULONG INT )
  code
     PVM_BOOL_BINOP (ULONG, <);
  end
end

instruction lei () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, <=);
  end
end

instruction leiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, <=);
  end
end

instruction lel () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, <=);
  end
end

instruction lelu () # ( ULONG ULONG -- ULONG ULONG INT )
  code
     PVM_BOOL_BINOP (ULONG, <=);
  end
end

instruction gti () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, >);
  end
end

instruction gtiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, >);
  end
end

instruction gtl () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, >);
  end
end

instruction gtlu () # ( ULONG ULONG -- ULONG ULONG INT )
  code
     PVM_BOOL_BINOP (ULONG, >);
  end
end

instruction gei () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, >=);
  end
end

instruction geiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, >=);
  end
end

instruction gel () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, >=);
  end
end

instruction gelu () # ( ULONG ULONG -- ULONG ULONG INT )
  code
     PVM_BOOL_BINOP (ULONG, >=);
  end
end

instruction lts () # ( STR STR -- STR STR INT )
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) < 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

instruction gts () # ( STR STR -- STR STR INT )
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) > 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

instruction ges () # ( STR STR -- STR STR INT )
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) >= 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

instruction les () # ( STR STR -- STR STR INT )
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) <= 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Concatenation instructions.

instruction sconc () # ( STR STR -- STR STR STR )
  code
     pvm_val res;
     char *sa = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
     char *sb = PVM_VAL_STR (JITTER_TOP_STACK ());
     char *s = xmalloc (strlen (sa) + strlen (sb) + 1);
     strcpy (s, sa);
     strcat (s, sb);
     res = pvm_make_string (s);

     JITTER_PUSH_STACK (res);
#undef F
  end
end

# Logical instructions.

instruction and () # ( INT INT -- INT INT INT )
  code
    PVM_BOOL_BINOP (INT, &&);
  end
end

instruction or () # ( INT INT -- INT INT INT )
  code
    PVM_BOOL_BINOP (INT, ||);
  end
end

instruction not () # ( INT -- INT INT )
  code
    pvm_val res = pvm_make_int (! PVM_VAL_INT (JITTER_TOP_STACK ()), 32);
    JITTER_PUSH_STACK (res);
  end
end

# Bitwise operators.

instruction bxori () # ( INT INT -- INT INT INT )
  code
    PVM_BINOP (INT, INT, INT, int, ^);
  end
end

instruction bxoriu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint, ^);
  end
end

instruction bxorl () # ( LONG LONG -- LONG LONG LONG )
  code
    PVM_BINOP (LONG, LONG, LONG, long, ^);
  end
end

instruction bxorlu () # ( ULONG ULONG -- ULONG ULONG ULONG )
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong, ^);
  end
end

instruction bconciii () # ( INT INT -- INT )
  code
  end
end

instruction bconciil () # ( INT INT -- LONG )
  code
  end
end


instruction bori () # ( INT INT -- INT )
  code
    PVM_BINOP (INT, INT, INT, int, |);
  end
end

instruction boriu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint, |);
  end
end

instruction borl () # ( LONG LONG -- LONG LONG LONG )
  code
    PVM_BINOP (LONG, LONG, LONG, long, |);
  end
end

instruction borlu () # ( ULONG ULONG -- ULONG ULONG ULONG )
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong, |);
  end
end

instruction bandi () # ( INT INT -- INT INT INT )
  code
    PVM_BINOP (INT, INT, INT, int, &);
  end
end

instruction bandiu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint, &);
  end
end

instruction bandl () # ( LONG LONG -- LONG LONG LONG )
  code
    PVM_BINOP (LONG, LONG, LONG, long, &);
  end
end

instruction bandlu () # ( ULONG ULONG -- ULONG ULONG ULONG )
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong, &);
  end
end

instruction bnoti () # ( INT -- INT INT )
  code
    PVM_UNOP (INT, INT, int, ~);
  end
end

instruction bnotiu () # ( UINT -- UINT UINT )
  code
    PVM_UNOP (UINT, UINT, uint, ~);
  end
end

instruction bnotl () # ( LONG -- LONG LONG )
  code
    PVM_UNOP (LONG, LONG, long, ~);
  end
end

instruction bnotlu () # ( ULONG -- ULONG ULONG )
  code
    PVM_UNOP (ULONG, ULONG, ulong, ~);
  end
end

instruction bsli () # ( INT UINT -- INT UINT INT )
  code
    PVM_BINOP (INT, UINT, INT, int, <<);
  end
end

instruction bsliu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint, <<);
  end
end

instruction bsll () # ( LONG UINT -- LONG UINT LONG )
  code
    PVM_BINOP (LONG, UINT, LONG, long, <<);
  end
end

instruction bsllu () # ( ULONG UINT -- ULONG UINT ULONG )
  code
    PVM_BINOP (ULONG, UINT, ULONG, ulong, <<);
  end
end

instruction bsri () # ( INT UINT -- INT UINT INT )
  code
    PVM_BINOP (INT, UINT, INT, int, >>);
  end
end

instruction bsriu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint, >>);
  end
end

instruction bsrl () # ( LONG UINT -- LONG UINT LONG )
  code
    PVM_BINOP (LONG, UINT, LONG, long, >>);
  end
end

instruction bsrlu () # ( ULONG UINT -- ULONG UINT ULONG )
  code
    PVM_BINOP (ULONG, UINT, ULONG, ulong, >>);
  end
end



## Branches

instruction ba (?f) # Branch always.
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction bn (?f) # Branch if null
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (tmp != PVM_NULL, JITTER_ARGF0);
  end
end

instruction bzi (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

instruction bziu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

instruction bzl (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

instruction bzlu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end

instruction bnzi (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

instruction bnziu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

instruction bnzl (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

instruction bnzlu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end



## Conversion instructions.

instruction itoi (?n pvm_literal_printer_cast) # ( INT -- INT INT )
  code
    PVM_CONVOP (INT, int32_t, int, int32_t);
  end
end

instruction itoiu (?n pvm_literal_printer_cast) # ( INT -- INT UINT )
  code
    PVM_CONVOP (INT, int32_t, uint, uint32_t);
  end
end

instruction itol (?n pvm_literal_printer_cast) # ( INT -- INT LONG )
  code
    PVM_CONVOP (INT, int32_t, long, int64_t);
  end
end

instruction itolu (?n pvm_literal_printer_cast) # ( INT -- INT ULONG )
  code
    PVM_CONVOP (INT, int32_t, ulong, uint64_t);
  end
end

instruction iutoi (?n pvm_literal_printer_cast) # ( UINT -- UINT INT )
  code
    PVM_CONVOP (UINT, uint32_t, int, int32_t);
  end
end

instruction iutoiu (?n pvm_literal_printer_cast) # ( UINT -- UINT UINT )
  code
    PVM_CONVOP (UINT, uint32_t, uint, uint32_t);
  end
end

instruction iutol (?n pvm_literal_printer_cast) # ( UINT -- UINT LONG )
  code
    PVM_CONVOP (UINT, uint32_t, long, int64_t);
  end
end

instruction iutolu (?n pvm_literal_printer_cast) # ( UINT -- UINT ULONG )
  code
    PVM_CONVOP (UINT, uint32_t, ulong, uint64_t);
  end
end

instruction ltoi (?n pvm_literal_printer_cast) # ( LONG -- LONG INT )
  code
    PVM_CONVOP (LONG, int64_t, int, int32_t);
  end
end

instruction ltoiu (?n pvm_literal_printer_cast) # ( LONG -- LONG UINT )
  code
    PVM_CONVOP (LONG, int64_t, uint, uint32_t);
  end
end

instruction ltol (?n pvm_literal_printer_cast) # ( LONG -- LONG LONG )
  code
    PVM_CONVOP (LONG, int64_t, long, int64_t);
  end
end

instruction ltolu (?n pvm_literal_printer_cast) # ( LONG -- LONG ULONG )
  code
    PVM_CONVOP (LONG, int64_t, ulong, uint64_t);
  end
end

instruction lutoi (?n pvm_literal_printer_cast) # ( ULONG -- ULONG INT )
  code
    PVM_CONVOP (ULONG, uint64_t, int, int32_t);
  end
end

instruction lutoiu (?n pvm_literal_printer_cast) # ( ULONG -- ULONG UINT )
  code
    PVM_CONVOP (ULONG, uint64_t, uint, uint32_t);
  end
end

instruction lutol (?n pvm_literal_printer_cast) # ( ULONG -- ULONG LONG )
  code
    PVM_CONVOP (ULONG, uint64_t, long, int64_t);
  end
end

instruction lutolu (?n pvm_literal_printer_cast) # ( ULONG -- ULONG ULONG )
  code
    PVM_CONVOP (ULONG, uint64_t, ulong, uint64_t);
  end
end



## Array instructions.

# ( TYP [IDX VAL]... ULONG(nelem) ULONG(ninitializer) -- ARR )
instruction mka ()
  code
    size_t i;
    pvm_val nelem, ninitializer, arr;

    ninitializer = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    arr = pvm_make_array (nelem, PVM_NULL /* type */);
    for (i = 0; i < PVM_VAL_ULONG (ninitializer); ++i)
    {
      size_t index
        = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());

      PVM_VAL_ARR_ELEM_VALUE (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_ARR_TYPE (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (arr);
  end
end

# ( OFF TYP [OFF IDX VAL]... ULONG(nelem) ULONG(ninitializer) -- ARR )
instruction mkma ()
  code
    size_t i;
    pvm_val nelem, ninitializer, arr;

    ninitializer = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    arr = pvm_make_array (nelem, PVM_NULL /* type */);
    for (i = 0; i < PVM_VAL_ULONG (ninitializer); ++i)
    {
      size_t index
        = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());

      PVM_VAL_ARR_ELEM_VALUE (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();

      PVM_VAL_ARR_ELEM_OFFSET (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_ARR_TYPE (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    PVM_VAL_ARR_OFFSET (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (arr);
  end
end

instruction aset () # ( ARR ULONG VAL -- ARR )
  code
    uint64_t idx;
    pvm_val val;

    val= JITTER_TOP_STACK ();
    idx = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    if (idx < 0 ||
        idx >= PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (JITTER_TOP_STACK ())))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS);

    PVM_VAL_ARR_ELEM_VALUE (JITTER_TOP_STACK (), idx) = val;
  end
end

instruction aref () # ( ARR ULONG -- ARR ULONG VAL )
  code
    pvm_val array = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (array))))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_ARR_ELEM_VALUE (array,
                                               PVM_VAL_ULONG (index)));
  end
end

instruction arefo () # ( ARR ULONG -- ARR ULONG OFF )
  code
    pvm_val array = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (array))))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_ARR_ELEM_OFFSET (array,
                                                PVM_VAL_ULONG (index)));
  end
end



## Struct instructions.

instruction mksct () # ( [STR VAL]... ULONG -- SCT )
  code
    size_t e;
    pvm_val nelem, sct;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    sct = pvm_make_struct (nelem);

    for (e = 0; e < PVM_VAL_ULONG (nelem); ++e)
    {
      PVM_VAL_SCT_ELEM_VALUE (sct, e) = JITTER_TOP_STACK ();
      PVM_VAL_SCT_ELEM_NAME (sct, e) = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (sct);
  end
end

instruction revsct () # ( SCT -- SCT )
  code
    pvm_reverse_struct (JITTER_TOP_STACK ());
  end
end

instruction sset () # ( SCT STR VAL -- SCT )
  code
  end
end

instruction sref () # ( SCT STR -- SCT STR VAL )
  code
    JITTER_PUSH_STACK (pvm_ref_struct (JITTER_UNDER_TOP_STACK (),
                                       JITTER_TOP_STACK ()));
  end
end



## Offset instructions.

instruction mko () # ( EXP ULONG -- OFF )
  code
   pvm_val res = pvm_make_offset (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());
   JITTER_DROP_STACK ();
   JITTER_TOP_STACK () = res;
  end
end

instruction ogetm () # ( OFF -- OFF (INT|LONG|UINT|ULONG) )
  code
   JITTER_PUSH_STACK (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()));
  end
end

instruction ogetu () # ( OFF -- OFF ULONG )
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ()));
  end
end

instruction ogetbt () # ( OFF -- OFF BT )
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_BASE_TYPE (JITTER_TOP_STACK ()));
  end
end



## Instructions to handle mapped values.

instruction mgeto () # ( VAL -- VAL OFF )
  code
    JITTER_PUSH_STACK (PVM_VAL_OFFSET (JITTER_TOP_STACK ()));
  end
end

instruction mseto () # ( VAL OFF -- VAL )
  code
    PVM_VAL_SET_OFFSET (JITTER_UNDER_TOP_STACK (),
                        JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

instruction mgetm () # ( VAL -- VAL CLS )
  code
     JITTER_PUSH_STACK (PVM_VAL_MAPPER (JITTER_TOP_STACK ()));
  end
end

instruction msetm () #  ( VAL CLS -- VAL )
  code
    PVM_VAL_SET_MAPPER (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();           
  end
end

instruction mgetw () #  ( VAL -- VAL CLS )
  code
     JITTER_PUSH_STACK (PVM_VAL_WRITER (JITTER_TOP_STACK ()));
  end
end

instruction msetw () #  ( VAL CLS -- VAL )
  code
    PVM_VAL_SET_WRITER (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();           
  end
end




## Type related instructions.

# Integral types

instruction mktyi () # ( ULONG UINT -- TYP )
  code
    pvm_val size = JITTER_UNDER_TOP_STACK ();
    pvm_val signed_p = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_TOP_STACK () = pvm_make_integral_type (size, signed_p);
  end
end

# String types

instruction mktys () # ( _ -- TYP )
  code
    JITTER_PUSH_STACK (pvm_make_string_type ());
  end
end

# Offset types

instruction mktyo () # ( TYP INT -- TYP )
  code
#define F(res, a, b) \
  { res = pvm_make_offset_type (a, b); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Array types

instruction mktya () # ( TYP -- TYP )
  code
    JITTER_TOP_STACK () = pvm_make_array_type (JITTER_TOP_STACK ());
  end
end

instruction tyagett () # ( TYP -- TYP TYP )
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_ETYPE (JITTER_TOP_STACK ()));
  end
end

# Function types

instruction mktyc () # ( ATYPE... RTYPE NARGS -- TYP )
  code
    size_t i;
    pvm_val nargs, rtype, *atypes;

    nargs = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    rtype = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_closure_attrs (nargs, &atypes);

    for (i = 0; i < PVM_VAL_ULONG (nargs); ++i)
    {
      atypes[i] = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_closure_type (rtype,
                                              nargs, atypes));
  end
end

# Struct types

instruction mktysct () # ( [STRING TYP]... NLONG -- TYP )
  code
    size_t i;
    pvm_val nelem, *etypes, *enames;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_struct_attrs (nelem, &etypes, &enames);

    for (i = 0; i < PVM_VAL_ULONG (nelem); ++i)
    {
      /* XXX: check pvm_val types?  */

      enames[i] = JITTER_UNDER_TOP_STACK ();
      etypes[i] = JITTER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_struct_type (nelem,
                                             enames, etypes));
  end
end

instruction typof () # ( VAL -- TYP )
  code
    JITTER_TOP_STACK () = pvm_typeof (JITTER_TOP_STACK ());
  end
end



## IO instructions
#
#
# The following instructions operate on the global IO space.

# write
#
# If the value at the TOS is mapped, then write it to IO.
# Otherwise, this is a NOP.
#
# Executing this instruction can result in the following exceptions:
#   PVM_E_IOS_FULL
#   PVM_E_CONSTRAINT_ERROR

instruction write () # ( VAL -- VAL )
  caller
  code
     pvm_val val = JITTER_TOP_STACK ();
     pvm_val writer = pvm_val_writer (val);

     if (writer != PVM_NULL)
     {
        JITTER_DUP_STACK ();                      /* VAL VAL */
        JITTER_PUSH_STACK (PVM_VAL_OFFSET (val)); /* VAL VAL OFF */
        PVM_CALL (writer);
      }
  end
end

# peeki NENC,ENDIAN,BITS
# ( OFF -- INT )

instruction peeki (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_PEEK (int, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_INT);
  end
end

# peekiu ENDIAN,BITS
# ( OFF -- UINT )

instruction peekiu (?n endian_printer,?n bits_printer)
  code
   PVM_PEEK (uint, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_UINT);
  end
end

# peekl NENC,ENDIAN,BITS
# ( OFF -- LONG )

instruction peekl (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_PEEK (long, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_INT);
  end
end

# peeklu ENDIAN,BITS
# ( OFF -- ULONG )

instruction peeklu (?n endian_printer,?n bits_printer)
  code
   PVM_PEEK (ulong, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_UINT);
  end
end

# peekdi BITS
# ( OFF -- INT )

instruction peekdi (?n bits_printer) # XXX: avoid code duplication with peeki
  code
    PVM_PEEK (int, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_INT);
  end
end

# peekdiu BITS
# ( OFF -- UINT )

instruction peekdiu (?n bits_printer) # XXX avoid code duplication with peekiu
  code
    PVM_PEEK (uint, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_UINT);
  end
end

# peekdl BITS
# ( OFF -- LONG )

instruction peekdl (?n bits_printer) # XXX avoid duplication with peekl
  code
    PVM_PEEK (long, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_INT);
  end
end

# peekdlu BITS
# ( OFF -- ULONG )

instruction peekdlu (?n bits_printer) # XXX avoid code duplication with peeklu
  code
    PVM_PEEK (ulong, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_UINT);
  end
end

# pokei NENC,ENDIAN,BITS
# ( OFF INT -- )

instruction pokei (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_POKE (INT, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_WRITE_INT);
  end
end

# pokeiu ENDIAN,BITS
# ( OFF UINT -- )

instruction pokeiu (?n endian_printer,?n bits_printer)
  code
   PVM_POKE (UINT, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_WRITE_UINT);
  end
end

# pokel NENC,ENDIAN,BITS
# ( OFF LONG -- )

instruction pokel (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_POKE (LONG, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_WRITE_INT);
  end
end

# pokelu ENDIAN,BITS
# ( OFF ULONG -- )

instruction pokelu (?n endian_printer,?n bits_printer)
  code
   PVM_POKE (ULONG, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_WRITE_UINT);
  end
end

# pokedi BITS
# ( OFF INT -- )

instruction pokedi (?n bits_printer)
  code
    PVM_POKE (INT, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_INT);
  end
end

# pokediu BITS
# ( OFF UINT -- )

instruction pokediu (?n bits_printer)
  code
    PVM_POKE (UINT, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_UINT);
  end
end

# pokedl BITS
# ( OFF LONG -- )

instruction pokedl (?n bits_printer)
  code
    PVM_POKE (LONG, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_INT);
  end
end

# pokedlu BITS
# ( OFF ULONG -- )

instruction pokedlu (?n bits_printer)
  code
    PVM_POKE (ULONG, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_UINT);
  end
end

# peeks
# ( OFF -- STR )

instruction peeks ()
  code
    ios io;

    if ((io = ios_cur ()) == NULL)
        PVM_RAISE (PVM_E_NO_IOS);

    JITTER_TOP_STACK () = pvm_make_string ("");
    /* XXX: WRITEME */
  end
end



## Exceptions handling instructions

# pushe LABEL
#
# ( EXCEPTION_TYPE -- EXCEPTION_HANDLER )

instruction pushe (?l)
  code
   struct pvm_exception_handler *ehandler
      = xmalloc (sizeof (struct pvm_exception_handler)); /* XXX GC */

   ehandler->exception = PVM_VAL_INT (JITTER_TOP_STACK ());
   JITTER_DROP_STACK ();
   ehandler->main_stack_height = JITTER_HEIGHT_STACK ();
   ehandler->return_stack_height = JITTER_HEIGHT_RETURNSTACK ();
   ehandler->code = JITTER_ARGP0;
   ehandler->env = jitter_state_runtime.env;

   JITTER_PUSH_EXCEPTIONSTACK (ehandler);
  end
end

# pope
#
# ( EXCEPTION_HANDLER -- _ )

instruction pope ()
  code
    JITTER_DROP_EXCEPTIONSTACK ();
  end
end

# raise
#
# ( EXCEPTION -- )

instruction raise ()
  code
    pvm_val exception = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
    PVM_RAISE (PVM_VAL_INT (exception));
  end
end



## Peephole optimizations

rule swap-drop-to-nip rewrite
  swap; drop
into
  nip
end

rule rot-rot-to-nrot rewrite
  rot; rot
into
  nrot
end

rule nip-nip-to-nip2 rewrite
  nip; nip
into
  nip2
end

rule drop-drop-to-drop2 rewrite
  drop; drop
into
  drop2
end

rule drop2-drop-to-drop3 rewrite
  drop2; drop
into
  drop3
end

rule drop3-drop-to-drop4 rewrite
  drop3; drop
into
  drop4
end

