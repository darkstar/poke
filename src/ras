#!/usr/bin/awk -f

# ras - The Retarded Poke Assembler
#
# Copyright (C) 2019 Jose E. Marchesi
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This is a dumb assembler that can translate Poke Assembly code into
# C macros.  The resulting C macros are designed to be used in the PKL
# code generator.
#
# Yes, RAS sucks ass, but it does its job... more or less.
# No, we wont' spend time trying to turn it into a real assembler.
# Yes, we suck too :P

### Documentation

# Macros and Functions
#
#  .macro NAME
#  ...
#  .end
#
# Translates to RAS_MACRO_NAME
#
#  .function NAME
#  ...
#  .end
#
# Translates to RAS_FUNCTION_NAME(CLOSURE)

# XXX support pushf/popf and lexical environment
# XXX support labels
# XXX support E_* constants

BEGIN {
    objdir = ENVIRON["objdir"]
    current_entity = ""

    # Read the instructions from pkl-insn.def and build the
    # instructions hash.
    # XXX error if the file doesn't exist
    while ((getline line < (objdir "ras-insn.def")) > 0)
    {
        name = gensub (/(.*) (.*)/, "\\2", "g", line)
        id = gensub (/(.*) (.*)/, "\\1", "g", line)
        insn_table[name] = id
    }
    close ("pkl-insn.def")

    print "/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY RAS -- DO NOT EDIT */"
}

### Miscellaneous rules

# Keep blank lines (to improve visibility)
/^[ \t]*$/ {
    if (current_entity == "")
        print ""
    else
        print "\t                                                          \\"
    next
}

# Process lines containing only comments
/^[ \t]*;.*/ {
    # XXX do not include the leading ; in the comment
    print "/* " $0 " */"
    next
}

### Rules for assembler directives

# .c RESTOFLINE
/\.c.*$/ {
    # XXX: should print the rest of the line
    print $2 "\\"
    next
}

# .macro NAME
/\.macro/ {
    print "#define RAS_MACRO_" toupper($2) "(CLOSURE) \\"
    print "\tdo() {                                                     \\"

    current_entity = "macro"
    next
}

# .expand NAME
/\.expand/ {
    print "\tRAS_MACRO_" toupper($2) ";                                \\"
    next
}

# .function NAME
/\.function/ {
    print "#define RAS_FUNCTION_" toupper($2) "(CLOSURE)  \\"
    print "\tdo() {                                                    \\"
    print "\tpvm_program program;                                      \\"
    print "\t                                                          \\"
    print "\tPKL_GEN_PUSH_ASM (pkl_asm_new (PKL_PASS_AST,              \\"
    print "\t                               PKL_GEN_PAYLOAD->compiler, \\"
    print "\t                               0 /* prologue */));        \\"
    print "\t                                                          \\"

    # Initialize the variable back and over
    back = 0
    over = 0
    for (key in variable_back) delete variable_back[key];
    for (key in variable_over) delete variable_over[key];

    current_entity = "function"
    next
}

# .endfunction
/\.end/ {
    if (current_entity == "function")
    {
        print "\tPKL_GEN_POP_ASM;                                      \\"
        print "\tpvm_specialize_program (program);                     \\"
        print "\t(CLOSURE) = pvm_make_cls (program);                   \\"
    }
    print "\t} while (0)"

    current_entity = ""
    next
}

# .local VARNAME
/\.local/ {
    if (current_entity != "function")
    {
        print "error:" FNR ": .local can only be used in functions"
        exit (1)
    }

    if (match ($2, /^[a-zA-Z][a-zA-Z]/) == 0)
    {
        print ("error:" FNR ": invalid variable name in .local")
        exit (1)
    }

    variable_back[$2] = back
    variable_over[$2] = over
    
    print "\tpkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REGVAR, " back "," over "); \\"
    over++;
    next
}

# Process an instruction

/^[ \t]*[a-zA-Z][a-zA-Z]+/ {

    # Lookup the instruction in the instructions hash.
    insn = $1
    insn_id = insn_table[insn]

    if (insn_id == "")
    {
        print "error:" FNR ": unknown instruction `" insn "'"
        exit (1)
    }
    
    if (insn_id == "PKL_INSN_POPF")
        popf_frames = $2

    # xxx Validate number of arguments, by counting commas in the
    # record.

    # Remove the optional line comment.
    $0 = gensub (/(.*);(.*)$/, "\\1", "g", $0)
    
    # {int,uint}<N>M -> pvm_make_{int,uint} (M, N)
    # XXX check that N is between 1 and 32
    $0 = gensub (/(u?int)<([0-9]+)>(-?[0-9]+)/,
                 "pvm_make_\\1 (\\3, \\2)", "g", $0);

    # {long,ulong}<N>M -> pvm_make_{long,ulong} (M, N)
    # XXX check that N is between 1 and 64
    $0 = gensub (/(u?long)<([0-9]+)>(-?[0-9]+)/,
                 "pvm_make_\\1 (\\3, \\2)", "g", $0);

    # null -> PVM_NULL
    $0 = gensub (/null/, "PVM_NULL", "g", $0)
    # "..." -> pvm_make_string ("...")
    $0 = gensub (/("[^"]*")/, "pvm_make_string (\\1)", "g", $0);

    # $literal -> if variable: back,over
    # This assumes only one variable is allowed per line.
    varloc = match ($0, /\$[a-zA-Z][a-zA-Z]+/)
    if (varloc != 0)
    {
        vname = substr ($0, RSTART + 1, RLENGTH);
        vback = variable_back[vname]
        vover = variable_over[vname]

        if (vback == "" || vover == "")
        {
            print "error:" FNR ": unknown variable $" vname
            exit (1);
        }

        $0 = gensub ("\\$" vname, vback "," vover, "g", $0);
    }

   # $0 = gensub (/\$([a-z][A-Z]*)/, variable_back[\\1] "," variable_over[\\1], "g", $0);

    $0 = gensub (insn, "pkl_asm_insn (PKL_ASM_GEN, " insn_id ",", "g", $0);

    # Remove spurious trailing commas.
    $0 = $0 "); \\"
    $0 = gensub (",\\)", ")", "g", $0);

    # Update `back' if POPF or PUSHF
    if (insn_id == "PKL_INSN_PUSHF")
        back++
    if (insn_id == "PKL_INSN_POPF")
        back = back - popf_frames

    if (back < 0)
    {
        print "error:" FNR ": unbalanced PUSHF and POPF"
        exit (1)
    }

    print $0
    next
}

# Catch-all centinel rule

{
    # XXX print to stderr
    print "error:" FNR ": UNKNOWN LINE"
    exit (1)
}
