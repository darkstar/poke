#!/usr/bin/awk -f

# ras - The Retarded Poke Assembler
#
# Copyright (C) 2019 Jose E. Marchesi
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This assembler translates Poke Assembly code into C macros.  The
# resulting C macros are designed to be used in the PKL code
# generator.  See the Documentation section below for more details.
#
# ras may not be the smartest assembler in the class, but we love it
# very much because it saves us a lot of work.  So please be gentle
# and don't break it.
#
# This code is supposed to run well on any POSIX-compatible awk.
# Please send us a patch if it doesn't!

### Documentation

# Invoking RAS
# ------------
#
# The environment variable `srcdir' should be set before running ras,
# and it should contain the path of the poke src/ directory.
#
# Usage: ras [FILE]
#
# Where FILE is a Poke assembly program, which usually use the file
# extension .pks.  The assembler will write the translated program to
# the standard output.
#
# If FILE is not specified then ras will read the assembly program in
# the standard input.
#
# Macros and Functions
# --------------------
#
#  .macro NAME
#  ...
#  .end
#
# Translates to RAS_MACRO_NAME
#
#  .function NAME
#  ...
#  .end
#
# Translates to RAS_FUNCTION_NAME(CLOSURE)
#
# Assembler Directives
# --------------------
#
# .function
# .macro
# .end
# .expand
# .c
#
# Instructions
# ------------
#
# An instruction line looks like:
#
#       MNEMONIC [ARG,...]  [; comment]
#
# i.e. zero or more blank characters followed by a mnemonic, followed
# by zero or more instruction arguments separated by commas,
# optionally followed by a comment that spans to the end of the line.
#
# ras supports the PVM instructions as they are defined in the
# pkl-insn.def file.  Arguments of the following types are supported:
#
# Immediate numbers are written like C decimal immediates, for example
# 1, 0, -1.
#
# PVM integers are written like int<M>N or uint<M>N, depending whether
# they are signed or unsigned.  M is the number of bits, and N an
# immediate number with the value.  M should be in the range 1 <= M <=
# 32.  N is a C numeric literal, such as 0, -1, or -0x32.
#
# Similarly, PVM longs are written like long<M>N or ulong<M>N.  This
# time, M should be in the range 1 <= M <= 64.
#
# PVM strings are written like C strings, i.e. "foo" or "" or
# "two\nlines".
#
# Exception Arguments are written like PVM_E_*.  See the file pvm.h
# for the set of valid exceptions.
#
# Variables
# ---------
#
# Wherever a lexical address (a pair of BACK, OVER numbers) is
# expected in a program, ras allows you to specify a variable name
# instead.  Variable names are identifiers that start with the $
# character.
#
# For example, both forms of pushvar are allowed:
#
#   pushvar 0,3
#   pushvar $foo
#
# Using variable names eases writing PVM assembly code a lot, for
# several reasons.
#
# First, the location of a given variable in a given lexical frame
# depends on how many other variables has been registered before.  For
# example, consider a function that gets two arguments, and also uses
# local variables:
#
#   .function FOO
#   prolog
#   pushf
#   regvar      ; Argument2, 0,0
#   regvar      ; Argument1, 0,1
#   ...
#   regvar      ; Local1, 0,2
#   regvar      ; Local2, 0,3
#   ...
#   pushvar 0,2 ; Use Local1
#
# Now, we want to modify FOO to get an extra argument.  Boom! This
# changes the lexical addresses of everything, and thus we need to
# adjust them manually:
#
#   .function FOO
#   prolog
#   pushf
#   regvar      ; Argument3, 0,0
#   regvar      ; Argument2, 0,1
#   regvar      ; Argument1, 0,2
#   ...
#   regvar      ; Local1, 0,3
#   regvar      ; Local2, 0,4
#   ...
#   pushvar 0,3 ; Use Local1
#
# This is VERY error prone and mistakes are laborious to debug, not to
# mention it is a pain in the ass and a waste of time.
#
# Fortunately, ras comes to the rescue.  Using variable names instead
# of lexical addresses, the assembler will do the boring work for you.
# The original function is:
#
#  .function FOO
#  prolog
#  pushf
#  regvar $arg2
#  regvar $arg1
#  ...
#  regvar $local1
#  regvar $local2
#
# And the updated function, with an additional argument:
#
#  .function FOO
#  prolog
#  pushf
#  regvar $arg3
#  regvar $arg2
#  regvar $arg1
#  ...
#  regvar $local1
#  regvar $local2
#
# Much better :P
#
# Another difficulty when dealing with lexical addresses is that
# different addresses are required to refer to the same variable,
# depending on the context.  For example, consider the following PVM
# program:
#
# pushf
# regvar        ; A
# pushvar 0,0   ; A
# pushf
# pushvar 1,0   ; Also A!
# popf 2
#
# In this case, it is simple: a quick look at the code is enough to
# determine the lexical addresses of the desired variable (A) in both
# program points.  However, in real programs this quickly degenerates
# and gets really complex.  As before, it is much better to let ras do
# the tracking job:
#
# pushf
# regvar %A
# pushvar %A
# pushf
# pushvar %A
# popf 2
#
# Summarizing: ultimately it is up to you when to use explicit lexical
# addresses instead of variable names.  But I strongly recommend using
# variable names unless you have a _very_ good reason not to... like a
# gun aiming at your head for example.

### Some useful misc functions, used in the rules below

# Emit an error message
function error(msg)
{
    num_errors++
    errors[num_errors] = msg
}

# Emit an error message and terminate immediately
function fatal(msg)
{
    print msg
    exit (1)
}

# Append a line to the assembled output.
function out(line)
{
    output[output_line++] = line
}

### Functions to manage the lexical environment

function init_lexenv()
{
    for (key in frame_nvars) delete frame_nvars[key]
    for (key in lexenv) delete lexenv[key]
    cur_frame = -1
}

function push_frame()
{
    cur_frame++
    frame_nvars[cur_frame] = 0
}

function pop_frame()
{
    if (cure_frame == -1)
    {
        error("error: " FNR " frame underflow")
        return
    }
    cur_frame--
}

function register_var(name)
{
    # Make sure the variable doesn't exist already, in the current
    # frame.
    for (on = 0; on < frame_nvars[cur_frame]; on++)
        if (lexenv[cur_frame,on] == name)
        {
            error("error: " FNR " variable `" name "' already defined")
            return
        }

    # Add the variable to the current frame
    lexenv[cur_frame,frame_nvars[cur_frame]] = varname
    frame_nvars[cur_frame] = frame_nvars[cur_frame] + 1
}

# Lookup for a variable in the lexical environment.
# Set the global `lookup_var_found'.
function lookup_var(name)
{
    if (cur_frame < 0)
        error("error: " FNR ": at least a PUSHF is required to access variables")

    lookup_var_found["back"] = -1
    lookup_var_found["over"] = -1
    for (fn = cur_frame; fn >= 0; fn--)
    {
        for (on = 0; on < frame_nvars[fn]; on++)
        {
            if (lexenv[fn,on] == name)
            {
                lookup_var_found["back"] = cur_frame - fn
                lookup_var_found["over"] = on
                break;
            }
        }
        if (lookup_var_found["back"] != -1)
            break;
    }
}

# Initialize the global state to start processing a new function or
# macro.
function init_entity()
{
    # Reset the output
    for (lineno in output) delete output[lineno]
    # Reset the line number of the entity
    output_line = 1
    # Reset the labels table
    for (label in labels) delete labels[label]
    # Reset the lexical environment state
    init_lexenv()
}

### There we go...

BEGIN {
    srcdir = ENVIRON["srcdir"]
    num_errors=0
    current_entity = ""

    # Read the instructions from pkl-insn.def and build the
    # instructions hashes:
    #
    # insn_id[NAME] contains the PKL_INSN_* identifier for the
    # instructions.
    #
    # insn_re[NAME] contains a regular expression matching a
    # instruction.

    null_re="null"
    int_re="(u?int)<([0-9]+)>(-?(0x)?[0-9]+)"
    long_re="(u?long)<([0-9]+)>(-?(0x)?[0-9]+)"
    string_re="(\"[^\"]*\")"
    var_re="(\\$[a-zA-Z][a-zA-Z]*)"
    expt_re="PVM_E_[A-Z_]+"

    ideffile = srcdir "pkl-insn.def"
    if (system ("test -r " ideffile) == 1)
        fatal("fatal: cannot read instruction definition file " ideffile)
    
    cmd = "cpp -D'PKL_DEF_INSN(M,A,N)=M A N' -P " srcdir "pkl-insn.def"
    while ((cmd | getline line) > 0)
    {
        name = gensub (/(.*) (.*) (.*)/, "\\3", "g", line)
        args = gensub (/(.*) (.*) (.*)/, "\\2", "g", line)
        id = gensub (/(.*) (.*) (.*)/, "\\1", "g", line)

        # Remove leading and trailing double-quotes wherever
        # appropriate
        name = substr (name, 2, length (name) - 2)
        args = substr (args, 2, length (args) - 2)     

        # Build the instruction's regexp.
        iregexp = name

        if (id == "PKL_INSN_PUSHVAR" \
            || id == "PKL_INSN_POPVAR")
            iregexp \
                = iregexp "[ \t]+((\\$([a-z][A-Z]*))"\
                          "|((-?[0-9][0-9]*)[ \t]*,[ \t]*(-?[0-9][0-9]*)))"
        else if (id == "PKL_INSN_REGVAR")
            iregexp = iregexp "[ \t]+\\$([a-z][A-Z]*)"
        else
        {
            for (ia = 1; ia <= length (args); ia++)
            {
                a = substr (args, ia, 1)
                
                if (ia == 1)
                    iregexp = iregexp "[ \t]+"
                if (ia != 1)
                    iregexp = iregexp "[ \t]*,[ \t]*"
                
                switch (a)
                {
                    case "n":
                        re="(-?(0x)?[0-9][0-9]*)"
                        break
                    case "l":
                        re="(\\.[a-zA-Z][a-zA-Z]*)"
                        break
                    case "v":
                        re="(" null_re "|" int_re "|" long_re \
                           "|" string_re "|" var_re "|" expt_re ")"
                        break
                    case "r":
                        break
                    case "a":
                        re="(---NEVER MATCHING---)"
                        break
                    default:
                        error("error: unknown insn argument type " a)
                }
                iregexp = iregexp re
            }
        }

        # Ok, set the entries for the instruction
        insn_id[name] = id
        insn_re[name] = iregexp
    }

    print "/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY RAS" \
          "-- DO NOT EDIT */"
}

### Line matching rules

# Every line in the assembly program is expected to match one of the
# rules below.  In case a line isn't recognized by any rule, it will
# choke on the catch-all centinel at the end of the file, and that
# ain't be fun.
#
# In what probably is terrible awk style, each rule below will use
# `next' in order to prevent other rules to match the just processed
# line.  This keeps things simple.

## Miscellaneous rules

# Keep blank lines (to improve readability)
/^[ \t]*$/ {
    if (current_entity == "")
        out("")
    else
        out("\t                                                          \\")
    next
}

# Process lines containing only comments
/^[ \t]*;.*/ {
    out("/* " $0 " */")
    next
}

## Rules for assembler directives

# .c RESTOFLINE
/\.c.*$/ {
    $0 = gensub (/.*\.c (.*)$/, "\\1", "g", $0)
    out("\t" $0 " \\")
    next
}

# .macro NAME
/\.macro/ {
    # Get the macro name, and make sure it looks good.
    macro_name = $2
    if (match (macro_name, /^[a-zA-Z][a-zA-Z]*/) == 0)
        error("error:" FNR ": invalid function name")

   init_entity()

    out("#define RAS_MACRO_" toupper($2) "(CLOSURE) \\")
    out("\tdo() {                                                     \\")

    current_entity = "macro"
    next
}

# .function NAME
/\.function/ {

    # Get the function name, and make sure it looks good.
    function_name = $2
    if (match (function_name, /^[a-zA-Z][a-zA-Z]*/) == 0)
        error("error:" FNR ": invalid function name")

    init_entity()

    out("#define RAS_FUNCTION_" toupper($2) "(CLOSURE)  \\")
    out("\tdo() {                                       \\")
    out("\tpvm_program program;                         \\")
    out("\t                                             \\")
    out("\tPKL_GEN_PUSH_ASM (pkl_asm_new (PKL_PASS_AST, \\")
    out("\t                               PKL_GEN_PAYLOAD->compiler, \\")
    out("\t                               0 /* prologue */));        \\")
    out("\t                                                          \\")
    out("---LABELDECLS---")

    current_entity = "function"
    next
}

# .end
/\.end/ {
    # Check that the previous entity finished any opened
    # lexical frame.
    if (cur_frame != -1)
        error("error: " FNR ": unbalanced PUSHF and POPF in closing entity")

    if (current_entity == "function")
    {
        out("\tPKL_GEN_POP_ASM;                                      \\")
        out("\tpvm_specialize_program (program);                     \\")
        out("\t(CLOSURE) = pvm_make_cls (program);                   \\")
    }
    out("\t} while (0)")

    # If there has been errors while processing the entity, print them
    # and do not continue processing further entities.
    if (num_errors > 0)
    {
        for (nerror = 1; nerror <= num_errors; nerror++)
            print errors[nerror]
        exit (1);
    }

    # Output the entity
    for (lineno = 1; lineno <= output_line; lineno++)
    {
        line = output[lineno]
        if (match (line, "---LABELDECLS---") == 1)
        {
            # Emit label declarations
            for (label in labels)
                print "\tjitter_label " label \
                      "_label = pkl_asm_fresh_label (PKL_GEN_ASM); \\"
        }
        else
            print output[lineno]
    }

    for (line in output) delete output[line]
    current_entity = ""
    next
}

# .expand NAME
/\.expand/ {
    out("\tRAS_MACRO_" toupper($2) ";                                \\")
    next
}

# Process a label
/^[ \t]*\.[a-zA-Z][a-zA-Z]*:[ \t]*(;.*)?$/ {
    labelname = substr ($1, 2, length($1) - 2)
    labels[labelname] = labelname
    out("\tpkl_asm_label (PKL_GEN_ASM," labelname "_label); \\")
    next
}

## Rules to process instructions

/^[ \t]*[a-zA-Z][a-zA-Z]+/ {

    # Lookup the instruction in the instructions hash and complain if
    # the instruction is unknown.
    insn = $1
    i_id = insn_id[insn]
    i_re = insn_re[insn]

    if (i_id == "")
    {
        error("error:" FNR ": unknown instruction `" insn "'")
        next
    }

    # Check that the instruction is well-formed
    if (match ($0, "^[ \t]*" i_re "[ \t]*(; .*)?$") != 1)
        error("error:" FNR ": malformed instruction " insn)

    # Remove the optional line comment.
    $0 = gensub (/(.*);(.*)$/, "\\1", "g", $0)

    # Substitute and check integer arguments.
    $0 = gensub (int_re, "pvm_make_\\1 (\\3, \\2)", "g", $0)

    # Substitute and check long arguments.
    $0 =gensub (long_re, "pvm_make_\\1 (\\3, \\2)", "g", $0)

    # Substitute and check string arguments.
    $0 = gensub (string_re, "pvm_make_string (\\1)", "g", $0);

    # Substitute and check null arguments.
    $0 = gensub (null_re, "PVM_NULL", "g", $0)

    # Substitute variable arguments and perform side-effects.
    # This assumes instructions have at most one variable argument.
    if (i_id == "PKL_INSN_REGVAR")
    {
        # Remove the leading $ from the variable name
        varname = substr ($2, 2, length ($2) - 1)
        register_var(varname)

        $0 = gensub (var_re, "", "g", $0)
    }
    else
    {
        varloc = match ($0, /\$[a-zA-Z][a-zA-Z]*/)
        if (varloc != 0)
        {
            vname = substr ($0, RSTART + 1, RLENGTH);
            lookup_var(vname)
            vback = lookup_var_found["back"]
            vover = lookup_var_found["over"]
            
            if (vback == -1 || vover == -1)
                error("error:" FNR ": unknown variable $" vname)
            
            $0 = gensub ("\\$" vname, vback "," vover, "g", $0);
        }
    }

    # Some instructions have side-effects in the lexical environment.
    # Proces them.
    if (i_id == "PKL_INSN_PUSHF")
        push_frame()
    if (i_id == "PKL_INSN_POPF")
    {
        popf_frames = $2
        for (i = 0; i < popf_frames; i++)
            pop_frame()
    }

    # Build the call to pkl_asm_insn.
    $0 = gensub (insn, "pkl_asm_insn (PKL_ASM_GEN, " i_id ",", "g", $0);
    $0 = $0 "); \\"
    $0 = gensub (",[ \t]*\\)", ")", "g", $0);

    # Ok, emit the line
    out($0)
    next
}

## Catch-all centinel rule

{
    error("error:" FNR ": excuse me, what is this crap")
}
