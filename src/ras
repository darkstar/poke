#!/usr/bin/gawk -f

# ras - The Retarded Poke Assembler
#
# Copyright (C) 2019 Jose E. Marchesi
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This is a dumb assembler that can translate Poke Assembly code into
# C macros.  The resulting C macros are designed to be used in the PKL
# code generator.
#
# Yes, RAS sucks ass, but it does its job... more or less.
# No, we wont' spend time trying to turn it into a real assembler.
# Yes, we suck too :P
#
# Note that RAS requires GAWK.

### Documentation

# Macros and Functions
#
#  .macro NAME
#  ...
#  .end
#
# Translates to RAS_MACRO_NAME
#
#  .function NAME
#  ...
#  .end
#
# Translates to RAS_FUNCTION_NAME(CLOSURE)

# XXX support pushf/popf and lexical environment
# XXX support labels
# XXX support E_* constants
# XXX turn .local VAR into regvar $VAR

### Some useful functions, used in the rules below

# Append a line to the assembled output.
function out(line)
{
    output[output_line++] = line
}

# Initialize the global state to start processing a new function or
# macro.
function init_entity()
{
    # Reset the output
    for (lineno in output) delete output[lineno]
    # Reset the line number of the entity
    output_line = 1
    # Reset the labels table
    for (label in labels) delete labels[label]
    # Reset the lexical environment state
    back = 0
    over = 0
    for (key in variable_back) delete variable_back[key];
    for (key in variable_over) delete variable_over[key];
}

### There we go...

BEGIN {
    objdir = ENVIRON["objdir"]
    current_entity = ""

    # Read the instructions from pkl-insn.def and build the
    # instructions hash.
    # XXX error if the file doesn't exist
    while ((getline line < (objdir "ras-insn.def")) > 0)
    {
        name = gensub (/(.*) (.*)/, "\\2", "g", line)
        id = gensub (/(.*) (.*)/, "\\1", "g", line)
        insn_table[name] = id
    }
    close ("pkl-insn.def")

    print "/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY RAS -- DO NOT EDIT */"
}

### Miscellaneous rules

# Keep blank lines (to improve visibility)
/^[ \t]*$/ {
    if (current_entity == "")
        out("")
    else
        out("\t                                                          \\")
    next
}

# Process lines containing only comments
/^[ \t]*;.*/ {
    # XXX do not include the leading ; in the comment
    out("/* " $0 " */")
    next
}

### Rules for assembler directives

# .c RESTOFLINE
/\.c.*$/ {
    # XXX: should print the rest of the line
    out($2 "\\")
    next
}

# .macro NAME
/\.macro/ {
    # Get the macro name, and make sure it looks good.
    macro_name = $2
    if (match (macro_name, /^[a-zA-Z][a-zA-Z]*/) == 0)
    {
        print ("error:" FNR ": invalid function name")
        exit (1)
    }

   init_entity()

    out("#define RAS_MACRO_" toupper($2) "(CLOSURE) \\")
    out("\tdo() {                                                     \\")

    current_entity = "macro"
    next
}

# .function NAME
/\.function/ {

    # Get the function name, and make sure it looks good.
    function_name = $2
    if (match (function_name, /^[a-zA-Z][a-zA-Z]*/) == 0)
    {
        print ("error:" FNR ": invalid function name")
        exit (1)
    }

    init_entity()

    out("#define RAS_FUNCTION_" toupper($2) "(CLOSURE)  \\")
    out("\tdo() {                                       \\")
    out("\tpvm_program program;                         \\")
    out("\t                                             \\")
    out("\tPKL_GEN_PUSH_ASM (pkl_asm_new (PKL_PASS_AST, \\")
    out("\t                               PKL_GEN_PAYLOAD->compiler, \\")
    out("\t                               0 /* prologue */));        \\")
    out("\t                                                          \\")
    out("---LABELDECLS---")

    current_entity = "function"
    next
}

# .end
/\.end/ {
    if (current_entity == "function")
    {
        out("\tPKL_GEN_POP_ASM;                                      \\")
        out("\tpvm_specialize_program (program);                     \\")
        out("\t(CLOSURE) = pvm_make_cls (program);                   \\")
    }
    out("\t} while (0)")

    # Output the entity
    for (lineno = 1; lineno <= output_line; lineno++)
    {
        line = output[lineno]
        if (match (line, "---LABELDECLS---") == 1)
        {
            # Emit label declarations
            for (label in labels)
                print "\tjitter_label " label "_label = pkl_asm_fresh_label (PKL_GEN_ASM); \\"
        }
        else
            print output[lineno]
    }

    for (line in output) delete output[line]
    current_entity = ""
    next
}

# .expand NAME
/\.expand/ {
    out("\tRAS_MACRO_" toupper($2) ";                                \\")
    next
}

# .local VARNAME
/\.local/ {
    if (current_entity != "function")
    {
        print "error:" FNR ": .local can only be used in functions"
        exit (1)
    }

    if (match ($2, /^[a-zA-Z][a-zA-Z]*/) == 0)
    {
        print ("error:" FNR ": invalid variable name in .local")
        exit (1)
    }

    variable_back[$2] = back
    variable_over[$2] = over
    
    out("\tpkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REGVAR, " back "," over "); \\")
    over++;
    next
}

# Process a label
/^[ \t]*\.[a-zA-Z][a-zA-Z]*:/ {
    labelname = substr ($1, 2, length($1) - 2)
    labels[labelname] = labelname
    out("\tpkl_asm_label (PKL_GEN_ASM," labelname "_label); \\")
    next
}

# Process an instruction

/^[ \t]*[a-zA-Z][a-zA-Z]+/ {

    # Lookup the instruction in the instructions hash.
    insn = $1
    insn_id = insn_table[insn]

    # XXX from the information stored in the instruction tables,
    # i.e. the number of arguments, and their types, build a regular
    # expression to match and extract the fields.

    if (insn_id == "")
    {
        print "error:" FNR ": unknown instruction `" insn "'"
        exit (1)
    }
    
    if (insn_id == "PKL_INSN_POPF")
        popf_frames = $2

    # xxx Validate number of arguments, by counting commas in the
    # record.

    # Remove the optional line comment.
    $0 = gensub (/(.*);(.*)$/, "\\1", "g", $0)
    
    # {int,uint}<N>M -> pvm_make_{int,uint} (M, N)
    # XXX check that N is between 1 and 32
    $0 = gensub (/(u?int)<([0-9]+)>(-?[0-9]+)/,
                 "pvm_make_\\1 (\\3, \\2)", "g", $0);

    # {long,ulong}<N>M -> pvm_make_{long,ulong} (M, N)
    # XXX check that N is between 1 and 64
    $0 = gensub (/(u?long)<([0-9]+)>(-?[0-9]+)/,
                 "pvm_make_\\1 (\\3, \\2)", "g", $0);

    # null -> PVM_NULL
    $0 = gensub (/null/, "PVM_NULL", "g", $0)
    # "..." -> pvm_make_string ("...")
    $0 = gensub (/("[^"]*")/, "pvm_make_string (\\1)", "g", $0);

    # $literal -> if variable: back,over
    # This assumes only one variable is allowed per line.
    varloc = match ($0, /\$[a-zA-Z][a-zA-Z]+/)
    if (varloc != 0)
    {
        vname = substr ($0, RSTART + 1, RLENGTH);
        vback = variable_back[vname]
        vover = variable_over[vname]

        if (vback == "" || vover == "")
        {
            print "error:" FNR ": unknown variable $" vname
            exit (1);
        }

        $0 = gensub ("\\$" vname, vback "," vover, "g", $0);
    }

   # $0 = gensub (/\$([a-z][A-Z]*)/, variable_back[\\1] "," variable_over[\\1], "g", $0);

    $0 = gensub (insn, "pkl_asm_insn (PKL_ASM_GEN, " insn_id ",", "g", $0);

    # Remove spurious trailing commas.
    $0 = $0 "); \\"
    $0 = gensub (",\\)", ")", "g", $0);

    # Update `back' if POPF or PUSHF
    if (insn_id == "PKL_INSN_PUSHF")
        back++
    if (insn_id == "PKL_INSN_POPF")
        back = back - popf_frames

    if (back < 0)
    {
        print "error:" FNR ": unbalanced PUSHF and POPF"
        exit (1)
    }

    out($0)
    next
}

# Catch-all centinel rule

{
    # XXX print to stderr
    print "error:" FNR ": UNKNOWN LINE"
    exit (1)
}
