#!/usr/bin/awk -f

# ras - The Retarded Poke Assembler
#
# Copyright (C) 2019 Jose E. Marchesi
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This is a dumb assembler that can translate Poke Assembly code into
# C macros.  The resulting C macros are designed to be used in the PKL
# code generator.  ras is not very smart, but we love it very much
# because it saves us a lot of work.  So please be gentle and don't
# break it.
#
# This code is supposed to run well on any POSIX-compatible awk.
# Please send us a patch if it doesn't!

### Documentation

# Invoking RAS
# ------------
#
# XXX srcdir
#
# Macros and Functions
# --------------------
#
#  .macro NAME
#  ...
#  .end
#
# Translates to RAS_MACRO_NAME
#
#  .function NAME
#  ...
#  .end
#
# Translates to RAS_FUNCTION_NAME(CLOSURE)

# XXX support pushf/popf and lexical environment
# XXX support E_* constants
# XXX turn .local VAR into regvar $VAR

### Some useful functions, used in the rules below

# Emit an error message and boil out with an error status.
function fatal(msg)
{
    print msg
    exit (1)
}

# Append a line to the assembled output.
function out(line)
{
    output[output_line++] = line
}

# Initialize the global state to start processing a new function or
# macro.
function init_entity()
{
    # Reset the output
    for (lineno in output) delete output[lineno]
    # Reset the line number of the entity
    output_line = 1
    # Reset the labels table
    for (label in labels) delete labels[label]
    # Reset the lexical environment state
    back = 0
    over = 0
    for (key in variable_back) delete variable_back[key];
    for (key in variable_over) delete variable_over[key];
}

### There we go...

BEGIN {
    srcdir = ENVIRON["srcdir"]
    current_entity = ""

    # Read the instructions from pkl-insn.def and build the
    # instructions hashes:
    #
    # insn_id[NAME] contains the PKL_INSN_* identifier for the
    # instructions.
    #
    # insn_re[NAME] contains a regular expression matching a
    # instruction.

    null_re="null"
    int_re="(u?int)<([0-9]+)>(-?[0-9]+)"
    long_re="(u?long)<([0-9]+)>(-?[0-9]+)"
    string_re="(\"[^\"]*\")"
    var_re="(\\$[a-zA-Z][a-zA-Z]+)"

    ideffile = srcdir "pkl-insn.def"
    if (system ("test -r " ideffile) == 1)
        fatal("error: cannot read instruction definition file " ideffile)
    
    cmd = "cpp -D'PKL_DEF_INSN(M,A,N)=M A N' -P " srcdir "pkl-insn.def"
    while ((cmd | getline line) > 0)
    {
        name = gensub (/(.*) (.*) (.*)/, "\\3", "g", line)
        args = gensub (/(.*) (.*) (.*)/, "\\2", "g", line)
        id = gensub (/(.*) (.*) (.*)/, "\\1", "g", line)

        # Remove leading and trailing double-quotes wherever
        # appropriate
        name = substr (name, 2, length (name) - 2)
        args = substr (args, 2, length (args) - 2)     

        # Build the instruction's regexp.  There is a couple of
        # special cases.
        iregexp = name

        if (id == "PKL_INSN_PUSHVAR" || id == "PKL_INSN_POPVAR")
            iregexp = iregexp "[ \t]+\\$([a-z][A-Z]*)"
        else
        {
            for (ia = 1; ia <= length (args); ia++)
            {
                a = substr (args, ia, 1)
                
                if (ia == 1)
                    iregexp = iregexp "[ \t]+"
                if (ia != 1)
                    iregexp = iregexp "[ \t]*,[ \t]*"
                
                switch (a)
                {
                    case "n":
                        re="(-?[0-9][0-9]*)"
                        break
                    case "l":
                        re="(\\.[a-zA-Z][a-zA-Z]*)"
                        break
                    case "v":
                        re="(" null_re "|" int_re "|" long_re \
                           "|" string_re "|" var_re ")"
                        break
                    case "r":
                        break
                    case "a":
                        re="(---NEVER MATCHING---)"
                        break
                    default:
                        fatal("error: unknown insn argument type " a)
                }
                iregexp = iregexp re
            }
        }

        # Ok, set the entries for the instruction
        insn_id[name] = id
        insn_re[name] = iregexp
    }

    print "/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY RAS" \
          "-- DO NOT EDIT */"
}

## Miscellaneous rules

# Keep blank lines (to improve readability)
/^[ \t]*$/ {
    if (current_entity == "")
        out("")
    else
        out("\t                                                          \\")
    next
}

# Process lines containing only comments
/^[ \t]*;.*/ {
    # XXX do not include the leading ; in the comment
    out("/* " $0 " */")
    next
}

## Rules for assembler directives

# .c RESTOFLINE
/\.c.*$/ {
    # XXX: should print the rest of the line
    $0 = gensub (/.*\.c (.*)$/, "\\1", "g", $0)
    out("\t" $0 " \\")
    next
}

# .macro NAME
/\.macro/ {
    # Get the macro name, and make sure it looks good.
    macro_name = $2
    if (match (macro_name, /^[a-zA-Z][a-zA-Z]*/) == 0)
        fatal("error:" FNR ": invalid function name")

   init_entity()

    out("#define RAS_MACRO_" toupper($2) "(CLOSURE) \\")
    out("\tdo() {                                                     \\")

    current_entity = "macro"
    next
}

# .function NAME
/\.function/ {

    # Get the function name, and make sure it looks good.
    function_name = $2
    if (match (function_name, /^[a-zA-Z][a-zA-Z]*/) == 0)
        fatal("error:" FNR ": invalid function name")

    init_entity()

    out("#define RAS_FUNCTION_" toupper($2) "(CLOSURE)  \\")
    out("\tdo() {                                       \\")
    out("\tpvm_program program;                         \\")
    out("\t                                             \\")
    out("\tPKL_GEN_PUSH_ASM (pkl_asm_new (PKL_PASS_AST, \\")
    out("\t                               PKL_GEN_PAYLOAD->compiler, \\")
    out("\t                               0 /* prologue */));        \\")
    out("\t                                                          \\")
    out("---LABELDECLS---")

    current_entity = "function"
    next
}

# .end
/\.end/ {
    if (current_entity == "function")
    {
        out("\tPKL_GEN_POP_ASM;                                      \\")
        out("\tpvm_specialize_program (program);                     \\")
        out("\t(CLOSURE) = pvm_make_cls (program);                   \\")
    }
    out("\t} while (0)")

    # Output the entity
    for (lineno = 1; lineno <= output_line; lineno++)
    {
        line = output[lineno]
        if (match (line, "---LABELDECLS---") == 1)
        {
            # Emit label declarations
            for (label in labels)
                print "\tjitter_label " label \
                      "_label = pkl_asm_fresh_label (PKL_GEN_ASM); \\"
        }
        else
            print output[lineno]
    }

    for (line in output) delete output[line]
    current_entity = ""
    next
}

# .expand NAME
/\.expand/ {
    out("\tRAS_MACRO_" toupper($2) ";                                \\")
    next
}

# .local VARNAME
/\.local/ {
    if (current_entity != "function")
        fatal("error:" FNR ": .local can only be used within functions")

    if (match ($2, /^[a-zA-Z][a-zA-Z]*/) == 0)
        fatal("error:" FNR ": invalid variable name in .local")

    variable_back[$2] = back
    variable_over[$2] = over
    
    out("\tpkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REGVAR, " back "," over "); \\")
    over++;
    next
}

# Process a label
/^[ \t]*\.[a-zA-Z][a-zA-Z]*:/ {
    labelname = substr ($1, 2, length($1) - 2)
    labels[labelname] = labelname
    out("\tpkl_asm_label (PKL_GEN_ASM," labelname "_label); \\")
    next
}

## Rules to process instructions

/^[ \t]*[a-zA-Z][a-zA-Z]+/ {

    # Lookup the instruction in the instructions hash and complain if
    # the instruction is unknown.
    insn = $1
    i_id = insn_id[insn]
    i_re = insn_re[insn]

    if (i_id == "")
        fatal("error:" FNR ": unknown instruction `" insn "'")

    # Check that the instruction is well-formed
    if (match ($0, "^[ \t]*" i_re "(; .*)?") != 1)
        fatal("error:" FNR ": malformed instruction " insn)

    # Remove the optional line comment.
    $0 = gensub (/(.*);(.*)$/, "\\1", "g", $0)

    # Substitute and check integer arguments.
    # XXX: check bits >= 1 && <= 32
    $0 = gensub (int_re, "pvm_make_\\1 (\\3, \\2)", "g", $0)

    # Substitute and check long arguments.
    # XXX: check bits >= 1 && <= 64
    $0 =gensub (long_re, "pvm_make_\\1 (\\3, \\2)", "g", $0)

    # Substitute and check string arguments.
    $0 = gensub (string_re, "pvm_make_string (\\1)", "g", $0);

    # Substitute and check null arguments.
    $0 = gensub (null_re, "PVM_NULL", "g", $0)

    # Substitute variable arguments.
    # This assumes instructions have at most one variable argument.
    if (i_id == "PKL_INSN_REGVAR")
    {
        # Remove the leading $ from the variable name
        varname = substr ($2, 2, length ($2) - 1)
        variable_back[varname] = back
        variable_over[varname] = over
        over++;

        $0 = gensub (var_re, "", "g", $0)
    }
    else
    {
        varloc = match ($0, /\$[a-zA-Z][a-zA-Z]+/)
        if (varloc != 0)
        {
            vname = substr ($0, RSTART + 1, RLENGTH);
            vback = variable_back[vname]
            vover = variable_over[vname]
            
            if (vback == "" || vover == "")
                fatal("error:" FNR ": unknown variable $" vname)
            
            $0 = gensub ("\\$" vname, vback "," vover, "g", $0);
        }
    }

    # Build the call to pkl_asm_insn.
    $0 = gensub (insn, "pkl_asm_insn (PKL_ASM_GEN, " i_id ",", "g", $0);
    $0 = $0 "); \\"
    $0 = gensub (",[ \t]*\\)", ")", "g", $0);

    # Some instructions have side-effects in the lexical environment.
    # Proces them.
    if (i_id == "PKL_INSN_PUSHF")
    {
        back++
        over = 0
    }
    if (i_id == "PKL_INSN_POPF")
    {
        popf_frames = $2
        back = back - popf_frames
        if (back < 0)
            fatal("error:" FNR ": unbalanced PUSHF and POPF")
    }

    # Ok, emit the line
    out($0)
    next
}

## Catch-all centinel rule

{
    # XXX print to stderr
    fatal("error:" FNR ": UNKNOWN LINE")
}
