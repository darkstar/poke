/* pkl-gen.c - Code generation phase for the poke compiler.  */

/* Copyright (C) 2019 Jose E. Marchesi */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <config.h>
#include <stdio.h>
#include <assert.h>
#include <jitter/jitter.h>

#include "pkl.h"
#include "pkl-gen.h"
#include "pkl-ast.h"
#include "pkl-pass.h"
#include "pkl-asm.h"
#include "pvm.h"

/* The following macros are used in the rules below, to reduce
   verbosity.  */

#define PKL_GEN_PAYLOAD ((pkl_gen_payload) PKL_PASS_PAYLOAD)

#define PKL_GEN_AN_ASM(ASM)                             \
  (PKL_GEN_PAYLOAD->ASM[PKL_GEN_PAYLOAD->cur_##ASM])

#define PKL_GEN_ASM  PKL_GEN_AN_ASM(pasm)
#define PKL_GEN_ASM2 PKL_GEN_AN_ASM(pasm2)

#define PKL_GEN_PUSH_AN_ASM(ASM,new_pasm)                               \
  do                                                                    \
    {                                                                   \
      assert (PKL_GEN_PAYLOAD->cur_##ASM < PKL_GEN_MAX_PASM);           \
      PKL_GEN_PAYLOAD->ASM[++(PKL_GEN_PAYLOAD->cur_##ASM)] = (new_pasm); \
    }                                                                   \
  while (0)

#define PKL_GEN_PUSH_ASM(new_pasm)  PKL_GEN_PUSH_AN_ASM(pasm,new_pasm)
#define PKL_GEN_PUSH_ASM2(new_pasm) PKL_GEN_PUSH_AN_ASM(pasm2,new_pasm)

#define PKL_GEN_POP_AN_ASM(ASM)                  \
  do                                             \
    {                                            \
      assert (PKL_GEN_PAYLOAD->cur_##ASM > 0);   \
      PKL_GEN_PAYLOAD->cur_##ASM -= 1;           \
    }                                            \
  while (0)

#define PKL_GEN_POP_ASM  PKL_GEN_POP_AN_ASM(pasm)
#define PKL_GEN_POP_ASM2 PKL_GEN_POP_AN_ASM(pasm2)


/* Code generated by RAS is used in the handlers below.  Configure it
   to use the main assembler in the GEN payload.  Then just include
   the assembled macros in this file.  */
#define RAS_ASM PKL_GEN_ASM
#include "pkl-gen.pkc"

/*
 * PROGRAM
 * | PROGRAM_ELEM
 * | ...
 *
 * This function initializes the payload and also generates the
 * standard prologue.
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_program)
{
  PKL_GEN_ASM = pkl_asm_new (PKL_PASS_AST,
                             PKL_GEN_PAYLOAD->compiler,
                             1 /* prologue */);
}
PKL_PHASE_END_HANDLER

/*
 * | PROGRAM_ELEM
 * | ...
 * PROGRAM
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_program)
{
  /* Make sure there is always some value returned in the stack, since
     that is expected in the PVM.  */
  if (!pkl_compiling_expression_p (PKL_GEN_PAYLOAD->compiler)
      && !(pkl_compiling_statement_p (PKL_GEN_PAYLOAD->compiler)
           && PKL_AST_PROGRAM_ELEMS (PKL_PASS_NODE)
           && PKL_AST_CODE (PKL_AST_PROGRAM_ELEMS (PKL_PASS_NODE)) == PKL_AST_EXP_STMT))
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);

  PKL_GEN_PAYLOAD->program = pkl_asm_finish (PKL_GEN_ASM,
                                             1 /* prologue */,
                                             &PKL_GEN_PAYLOAD->pointers);
}
PKL_PHASE_END_HANDLER

/*
 * DECL
 * | INITIAL
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_decl)
{
  pkl_ast_node decl = PKL_PASS_NODE;
  pkl_ast_node initial = PKL_AST_DECL_INITIAL (decl);

  switch (PKL_AST_DECL_KIND (decl))
    {
    case PKL_AST_DECL_KIND_TYPE:
      switch (PKL_AST_TYPE_CODE (initial))
        {
        case PKL_TYPE_STRUCT:
          {
            pvm_val mapper_closure;
            pvm_val writer_closure;
            pvm_val constructor_closure;

            pkl_ast_node type_struct = initial;
            pkl_ast_node type_struct_elems = PKL_AST_TYPE_S_ELEMS (type_struct);
            pkl_ast_node field;

            /* Compile the struct closures and complete them using the
               current environment.  */

            PKL_GEN_PAYLOAD->in_writer = 1;
            RAS_FUNCTION_STRUCT_WRITER (writer_closure);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, writer_closure); /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);                 /* _ */
            PKL_GEN_PAYLOAD->in_writer = 0;

            PKL_GEN_PAYLOAD->in_mapper = 1;
            RAS_FUNCTION_STRUCT_MAPPER (mapper_closure);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, mapper_closure); /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);                 /* _ */
            PKL_GEN_PAYLOAD->in_mapper = 0;

            PKL_GEN_PAYLOAD->in_constructor = 1;
            RAS_FUNCTION_STRUCT_CONSTRUCTOR (constructor_closure);          /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, constructor_closure); /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                       /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);                      /* _ */
            PKL_GEN_PAYLOAD->in_constructor = 0;

            /* Install the closures in the type AST node.  */

            PKL_AST_TYPE_S_WRITER (type_struct) = writer_closure;
            PKL_AST_TYPE_S_MAPPER (type_struct) = mapper_closure;
            PKL_AST_TYPE_S_CONSTRUCTOR (type_struct) = constructor_closure;

            PKL_PASS_BREAK;
            break;
          }
        case PKL_TYPE_ARRAY:
          {
            pvm_val mapper_closure;
            pvm_val writer_closure;

            pkl_ast_node array_type = initial;

            /* Compile the arrays closures and complete them using the
               current environment.  */

            PKL_GEN_PAYLOAD->in_writer = 1;
            RAS_FUNCTION_ARRAY_WRITER (writer_closure);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, writer_closure); /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);                 /* _ */
            PKL_GEN_PAYLOAD->in_writer = 0;

            PKL_GEN_PAYLOAD->in_mapper = 1;
            RAS_FUNCTION_ARRAY_MAPPER (mapper_closure);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, mapper_closure); /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* CLS */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);                 /* _ */
            PKL_GEN_PAYLOAD->in_mapper = 0;

            /* The bounder closures for this array and possibly
               contained sub-arrays are installed in the
               pkl_gen_pr_type_array handler.  */
            PKL_GEN_PAYLOAD->in_array_bounder = 1;
            PKL_PASS_SUBPASS (array_type);
            PKL_GEN_PAYLOAD->in_array_bounder = 0;

            /* Install the closures in the type AST node.  */

            PKL_AST_TYPE_A_WRITER (array_type) = writer_closure;
            PKL_AST_TYPE_A_MAPPER (array_type) = mapper_closure;

            PKL_PASS_BREAK;
            break;
          }
        default:
          break;
        }
      break;
    case PKL_AST_DECL_KIND_FUNC:

      /* INITIAL is a PKL_AST_FUNC, that will compile into a program
         containing the function code.  Push a new assembler to the
         stack of assemblers in the payload and use it to process
         INITIAL.  */
      PKL_GEN_PUSH_ASM (pkl_asm_new (PKL_PASS_AST,
                                     PKL_GEN_PAYLOAD->compiler,
                                     0 /* prologue */));
      break;
    default:
      break;
    }
}
PKL_PHASE_END_HANDLER

/*
 * | INITIAL
 * DECL
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_decl)
{
  pkl_ast_node decl = PKL_PASS_NODE;
  pkl_ast_node initial = PKL_AST_DECL_INITIAL (decl);

  switch (PKL_AST_DECL_KIND (decl))
    {
    case PKL_AST_DECL_KIND_VAR:
      /* The value is in the stack.  Just register the variable.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REGVAR);
      break;
    case PKL_AST_DECL_KIND_TYPE:
      if (PKL_AST_TYPE_CODE (initial) == PKL_TYPE_STRUCT)
        assert (0);
      break;
    case PKL_AST_DECL_KIND_FUNC:
      {
        /* At this point the code for the function specification
           INITIAL has been assembled in the current macroassembler.
           Finalize the program and put it in a PVM closure, along
           with the current environment.  */

        void *pointers;
        pvm_program program = pkl_asm_finish (PKL_GEN_ASM,
                                              0 /* epilogue */,
                                              &pointers);
        pvm_val closure;

        PKL_GEN_POP_ASM;
        pvm_specialize_program (program);
        closure = pvm_make_cls (program, pointers);

        /*XXX*/
        /* pvm_print_program (stdout, program); */

        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, closure);
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REGVAR);
        break;
      }
    default:
      assert (0);
      break;
    }
}
PKL_PHASE_END_HANDLER

/*
 * VAR
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_var)
{
  pkl_ast_node var = PKL_PASS_NODE;

  if (PKL_PASS_PARENT == NULL && PKL_GEN_PAYLOAD->in_lvalue)
    {
      /* This is a l-value in an assignment.  Generate nothing, as
         this node is only used as a recipient for the lexical address
         of the variable.  */
      /* XXX: the call to WRITE will most probably belong here, after
         the indexer or sref or whatever.  */
    }
  else
    {
      pkl_ast_node var_type = PKL_AST_TYPE (var);

      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSHVAR,
                    PKL_AST_VAR_BACK (var), PKL_AST_VAR_OVER (var));

      /* If the value holds a value that could be mapped, then use the
         REMAP instruction.  */
      if (PKL_AST_TYPE_CODE (var_type) == PKL_TYPE_ARRAY
          || PKL_AST_TYPE_CODE (var_type) == PKL_TYPE_STRUCT)
        {
          /* XXX: handle exceptions from the mapper function.  */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REMAP);
        }
    }
}
PKL_PHASE_END_HANDLER

/*
 * NULL_STMT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_null_stmt)
{
  /* Null is nothing, nada.  */
}
PKL_PHASE_END_HANDLER

/*
 * COMP_STMT
 * | (STMT | DECL)
 * | ...
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_comp_stmt)
{
  pkl_ast_node comp_stmt = PKL_PASS_NODE;

  if (PKL_AST_COMP_STMT_BUILTIN (comp_stmt) == PKL_AST_BUILTIN_NONE)
    /* Push a frame into the environment.  */
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSHF);

}
PKL_PHASE_END_HANDLER

/*
 * | (STMT | DECL)
 * | ...
 * COMP_STMT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_comp_stmt)
{
  pkl_ast_node comp_stmt = PKL_PASS_NODE;
  int comp_stmt_builtin
    = PKL_AST_COMP_STMT_BUILTIN (comp_stmt);

  if (comp_stmt_builtin != PKL_AST_BUILTIN_NONE)
    {
      switch (comp_stmt_builtin)
        {
        case PKL_AST_BUILTIN_RAND:
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAND);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RETURN);
          break;
        default:
          assert (0);
        }
    }
  else
    /* Pop the lexical frame created by the compound statement.  */
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POPF, 1);
}
PKL_PHASE_END_HANDLER

/*
 * ASS_STMT
 * | EXP
 * | LVALUE
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_ass_stmt)
{
  pkl_ast_node ass_stmt = PKL_PASS_NODE;
  pkl_ast_node lvalue = PKL_AST_ASS_STMT_LVALUE (ass_stmt);
  pkl_ast_node exp = PKL_AST_ASS_STMT_EXP (ass_stmt);

  pvm_val valmapper;

  PKL_PASS_SUBPASS (exp);

  PKL_GEN_PAYLOAD->in_lvalue = 1;
  PKL_PASS_SUBPASS (lvalue);
  PKL_GEN_PAYLOAD->in_lvalue = 0;

  /* At this point the r-value, generated from executing EXP, is in
     the stack.  If its type can be mapped, then we need to generate
     code to perform a mapval on that value.

     Mapval code gets two arguments, and generates one value:
     MAPVAL ( NVAL OFF -- NVAL )

     If the type is a named struct or array, the assignment statement
     has the lexical address of the corresponding mapval function.
     Just call it.  */
  switch (PKL_AST_CODE (lvalue))
    {
    case PKL_AST_INDEXER:
      /* Note that analf guarantees that the entity in this indexer is
         an array, not a string.  */
      /* Fallthrough.  */
    case PKL_AST_STRUCT_REF:
      {
        jitter_label label = pkl_asm_fresh_label (PKL_GEN_ASM);

        valmapper = PVM_NULL; /* XXX PKL_AST_TYPE_S_VALMAPPER (lvalue_type) */

        /* We need to get the value (array element, or struct field)
           that will be replaced in the lvalue.  */

                                                      /* EXP LVALUE IDX */

        /* Save EXP in %r0. XXX: use the r-stack instead.  */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ROT);     /* LVALUE IDX EXP */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POPR, 0); /* LVALUE IDX */

        if (PKL_AST_CODE (lvalue) == PKL_AST_INDEXER)
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_AREF); /* LVALUE IDX VAL */
        else /* PKL_AST_STRUCT_REF */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SREF);

        /* If VAL is not mapped, skip the mapval.  */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSHR, 0);  /* LVALUE IDX VAL EXP */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);      /* LVALUE IDX EXP VAL */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MGETM);     /* LVALUE IDX EXP VAL MCLS */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BN, label); /* LVALUE IDX EXP VAL MCLS */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);      /* LVALUE IDX EXP VAL */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MGETO);     /* LVALUE IDX EXP VAL OFFSET */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NROT);      /* LVALUE IDX OFFSET EXP VAL */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);      /* LVALUE IDX OFFSET VAL EXP */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ROT);       /* LVALUE IDX VAL EXP OFFSET */

        if (valmapper != PVM_NULL)
          {
            /* XXX this never happens atm  */
            assert (0);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, valmapper);
          }
        else
          {
            PKL_GEN_PAYLOAD->in_valmapper = 1;
            PKL_PASS_SUBPASS (PKL_AST_TYPE (exp));
            PKL_GEN_PAYLOAD->in_valmapper = 0;
          }

                                                             /* LVALUE IDX VAL */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL); /* LVALUE IDX VAL null */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL); /* LVALUE IDX VAL null null */
        pkl_asm_label (PKL_GEN_ASM, label);
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);        /* LVALUE IDX EXP VAL */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);        /* LVALUE IDX EXP */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NROT);        /* EXP LVALUE IDX */
      }
      break;
    default:
      break;
    }

  /* All right, now assign the resulting rvalue to the lvalue.  */
  switch (PKL_AST_CODE (lvalue))
    {
    case PKL_AST_VAR:
      /* Stack: VAL */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POPVAR,
                    PKL_AST_VAR_BACK (lvalue), PKL_AST_VAR_OVER (lvalue));
      break;
    case PKL_AST_INDEXER:
      {
        /* Stack: VAL ARRAY INDEX */

        pkl_ast_node array = PKL_AST_INDEXER_ENTITY (lvalue);
        pkl_ast_node array_type = PKL_AST_TYPE (array);
        pkl_ast_node etype = PKL_AST_TYPE_A_ETYPE (array_type);

        /* If the type of the array is ANY[], then check at runtime
           that the type of the value matches the type of the elements
           in the array.  */
        if (PKL_AST_TYPE_CODE (etype) == PKL_TYPE_ANY)
          {
            jitter_label label = pkl_asm_fresh_label (PKL_GEN_ASM);

            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NROT);  /* INDEX VAL ARRAY */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_TYPOF); /* INDEX VAL ARRAY ATYPE */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_TYAGETT); /* INDEX VAL ARRAY ATYPE ETYPE */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);   /* INDEX VAL ARRAY ETYPE */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ROT);   /* INDEX ARRAY ETYPE VAL */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);  /* INDEX ARRAY VAL ETYPE */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ISA);   /* INDEX ARRAY VAL ETYPE BOOL */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);   /* INDEX ARRAY VAL BOOL */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BNZI, label);

            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_int (PVM_E_CONV, 32));
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAISE);

            pkl_asm_label (PKL_GEN_ASM, label);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);  /* INDEX ARRAY VAL */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);  /* INDEX VAL ARRAY */
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ROT);   /* VAL ARRAY INDEX */
          }

        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ROT);   /* ARRAY INDEX VAL */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ASET);  /* ARRAY */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_WRITE); /* ARRAY */
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);  /* The array
                                                       value.  */
        break;
      }
    case PKL_AST_STRUCT_REF:
      /* Stack: VAL SCT ID */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ROT);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SSET);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_WRITE);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP); /* The struct
                                                    value.  */
      break;
    default:
      break;
    }

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * IF_STMT
 * | EXP
 * | THEN_STMT
 * | [ELSE_STMT]
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_if_stmt)
{
  pkl_ast_node if_stmt = PKL_PASS_NODE;
  pkl_ast_node if_exp = PKL_AST_IF_STMT_EXP (if_stmt);
  pkl_ast_node if_then_stmt = PKL_AST_IF_STMT_THEN_STMT (if_stmt);
  pkl_ast_node if_else_stmt = PKL_AST_IF_STMT_ELSE_STMT (if_stmt);

  pkl_asm_if (PKL_GEN_ASM, if_exp);
  {
    PKL_PASS_SUBPASS (if_exp);
  }
  pkl_asm_then (PKL_GEN_ASM);
  {
    PKL_PASS_SUBPASS (if_then_stmt);
  }
  pkl_asm_else (PKL_GEN_ASM);
  {
    if (if_else_stmt)
      PKL_PASS_SUBPASS (if_else_stmt);
  }
  pkl_asm_endif (PKL_GEN_ASM);

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * BREAK_STMT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_break_stmt)
{
  int nframes = PKL_AST_BREAK_STMT_NFRAMES (PKL_PASS_NODE);

  if (nframes > 0)
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POPF, nframes);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BA,
                pkl_asm_break_label (PKL_GEN_ASM));
}
PKL_PHASE_END_HANDLER

/*
 * LOOP_STMT
 * | CONDITION
 * | BODY
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_loop_stmt)
{
  pkl_ast_node loop_stmt = PKL_PASS_NODE;
  pkl_ast_node condition = PKL_AST_LOOP_STMT_CONDITION (loop_stmt);
  pkl_ast_node iterator = PKL_AST_LOOP_STMT_ITERATOR (loop_stmt);
  pkl_ast_node container = PKL_AST_LOOP_STMT_CONTAINER (loop_stmt);
  pkl_ast_node body = PKL_AST_LOOP_STMT_BODY (loop_stmt);

  if (condition && !iterator  && !container)
    {
      /* This is a WHILE loop.  */
      pkl_asm_while (PKL_GEN_ASM);
      {
        PKL_PASS_SUBPASS (condition);
      }
      pkl_asm_loop (PKL_GEN_ASM);
      {
        PKL_PASS_SUBPASS (body);
      }
      pkl_asm_endloop (PKL_GEN_ASM);
    }
  else if (iterator && container)
    {
      pkl_ast_node container_type = PKL_AST_TYPE (container);

      /* This is a FOR-IN[-WHERE] loop.  */
      pkl_asm_for (PKL_GEN_ASM,
                   PKL_AST_TYPE_CODE (container_type),
                   condition);
      {
        PKL_PASS_SUBPASS (container);
      }
      pkl_asm_for_where (PKL_GEN_ASM);
      {
        if (condition)
          PKL_PASS_SUBPASS (condition);
      }
      pkl_asm_for_loop (PKL_GEN_ASM);
      {
        PKL_PASS_SUBPASS (body);
      }
      pkl_asm_for_endloop (PKL_GEN_ASM);
    }
  else
    /* This should not happen.  */
    assert (0);

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * RETURN
 * | EXP
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_return_stmt)
{
  /* Clean the stack before returning.  */
  size_t i;

  for (i = 0; i < PKL_AST_RETURN_STMT_NDROPS (PKL_PASS_NODE); ++i)
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
}
PKL_PHASE_END_HANDLER

/*
 * | EXP
 * RETURN
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_return_stmt)
{
  /* Return from the function: pop N frames and generate a return
     instruction.  */

  pkl_ast_node return_stmt = PKL_PASS_NODE;
  pkl_ast_node function = PKL_AST_RETURN_STMT_FUNCTION (return_stmt);
  pkl_ast_node function_type = PKL_AST_TYPE (function);

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POPF,
                PKL_AST_RETURN_STMT_NFRAMES (PKL_PASS_NODE));

  /* Pop the function argument's frame.  */
  if (PKL_AST_FUNC_ARGS (function))
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POPF, 1);

  /* In a void function, return PVM_NULL in the stack.  */
  if (PKL_AST_TYPE_CODE (PKL_AST_TYPE_F_RTYPE (function_type))
      == PKL_TYPE_VOID)
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RETURN);
}
PKL_PHASE_END_HANDLER

/*
 * | EXP
 * EXP_STMT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_exp_stmt)
{
  /* Drop the expression from the stack, but not if we are compiling a
     single statement.  */
  if (!(pkl_compiling_statement_p (PKL_GEN_PAYLOAD->compiler)
        && PKL_PASS_PARENT
        && PKL_AST_CODE (PKL_PASS_PARENT) == PKL_AST_PROGRAM))
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
}
PKL_PHASE_END_HANDLER

/*
 * PRINT_STMT
 * | ARG
 * | ...
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_print_stmt)
{
  pkl_ast_node print_stmt = PKL_PASS_NODE;
  pkl_ast_node print_stmt_args = PKL_AST_PRINT_STMT_ARGS (print_stmt);
  pkl_ast_node print_stmt_fmt = PKL_AST_PRINT_STMT_FMT (print_stmt);

  if (print_stmt_fmt)
    {
      pkl_ast_node arg;
      char *prefix = PKL_AST_PRINT_STMT_PREFIX (print_stmt);

      /* Emit the optional prefix.  */
      if (prefix)
        {
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_string (prefix));
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PRINTS);
        }

      for (arg = print_stmt_args; arg; arg = PKL_AST_CHAIN (arg))
        {
          /* Print the argument, and the optional suffix.  */

          pkl_ast_node exp = PKL_AST_PRINT_STMT_ARG_EXP (arg);
          char *suffix = PKL_AST_PRINT_STMT_ARG_SUFFIX (arg);
          int base = PKL_AST_PRINT_STMT_ARG_BASE (arg);

          PKL_PASS_SUBPASS (exp);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PRINT, PKL_AST_TYPE (exp),
                        base);

          if (suffix)
            {
              pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_string (suffix));
              pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PRINTS);
            }
        }
    }
  else
    {
      PKL_PASS_SUBPASS (print_stmt_args);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PRINTS);
    }

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * | [EXP]
 * RAISE_STMT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_raise_stmt)
{
  pkl_ast_node raise_stmt = PKL_PASS_NODE;

  /* If the `raise' statement was anonymous, then we need to push the
     exception to raise, which by default, is 0.  */
  if (PKL_AST_RAISE_STMT_EXP (raise_stmt) == NULL)
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_int (0, 32));

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAISE);
}
PKL_PHASE_END_HANDLER

/*
 * | CODE
 * | HANDLER
 * | [ARG]
 * | [EXP]
 * TRY_CATCH_STMT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_try_catch_stmt)
{
  pkl_ast_node try_catch_stmt = PKL_PASS_NODE;
  pkl_ast_node code = PKL_AST_TRY_CATCH_STMT_CODE (try_catch_stmt);
  pkl_ast_node handler = PKL_AST_TRY_CATCH_STMT_HANDLER (try_catch_stmt);
  pkl_ast_node catch_arg = PKL_AST_TRY_CATCH_STMT_ARG (try_catch_stmt);
  pkl_ast_node catch_exp = PKL_AST_TRY_CATCH_STMT_EXP (try_catch_stmt);

  /* Push the exception number that will be catched by the sentence.
     This is EXP if it is defined, or 0 (catch-all) if it isnt.  */
  if (catch_exp)
    PKL_PASS_SUBPASS (catch_exp);
  else
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_int (0, 32));

  pkl_asm_try (PKL_GEN_ASM, catch_arg);
  {
    PKL_PASS_SUBPASS (code);
  }
  pkl_asm_catch (PKL_GEN_ASM);
  {
    PKL_PASS_SUBPASS (handler);
  }
  pkl_asm_endtry (PKL_GEN_ASM);

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * | EXP
 * FUNCALL_ARG
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_funcall_arg)
{
  /* No extra action is required here.  */
}
PKL_PHASE_END_HANDLER


/* FUNCALL
 * | [ARG]
 * | ...
 * | FUNCTION
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_funcall)
{
  pkl_ast_node funcall = PKL_PASS_NODE;
  pkl_ast_node function = PKL_AST_FUNCALL_FUNCTION (funcall);
  pkl_ast_node function_type = PKL_AST_TYPE (function);
  int vararg = PKL_AST_TYPE_F_VARARG (function_type);
  int i, aindex = 0, vararg_actual = 0, optionals_specified = 0;
  pkl_ast_node aa;

  /* Push the actuals to the stack. */
  for (aa = PKL_AST_FUNCALL_ARGS (funcall); aa; aa = PKL_AST_CHAIN (aa))
    {
      if (PKL_AST_FUNCALL_ARG_FIRST_VARARG (aa))
        {
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL); /* Array offset. */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_any_type ());
          vararg_actual = 1;
        }

      if (vararg_actual)
        {
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL); /* Elem offset. */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_ulong (aindex, 64));
          aindex++;
        }

      if (!PKL_AST_FUNCALL_ARG_EXP (aa))
        {
          /* This is a non-specified actual for a formal having a
             default value.  */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
          optionals_specified++;
        }
      else
        PKL_PASS_SUBPASS (aa);
    }

  if (vararg)
    {
      if (aindex == 0)
        {
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL); /* Array offset. */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_any_type ());
        }

      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_ulong (aindex, 64));
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DUP);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKA);
    }

  /* Complete non-specified actuals for formals having default values.
     For these, we should push nulls.  But beware the vararg!  */
  {
    int non_specified
      = (PKL_AST_TYPE_F_NARG (function_type)
         - PKL_AST_FUNCALL_NARG (funcall)
         - PKL_AST_TYPE_F_VARARG (function_type)
         - optionals_specified);

    for (i = 0; i < non_specified; ++i)
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
  }

  /* Push the closure for FUNCTION and call the bloody function.  */
  PKL_PASS_SUBPASS (PKL_AST_FUNCALL_FUNCTION (funcall));
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_CALL);

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * FUNC
 * | [TYPE]
 * | [FUNC_ARG]
 * | ...
 * | BODY
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_func)
{
  pkl_ast_node fa;

  /* This is a function prologue.  */
  pkl_asm_note (PKL_GEN_ASM,
                PKL_AST_FUNC_NAME (PKL_PASS_NODE));
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PROLOG);

  /* Reverse the arguments.
     XXX: compute the number of formals in transf.
     XXX: use pick and roll when available.  */
  {
    int narg = 0;
    for (fa = PKL_AST_FUNC_ARGS (PKL_PASS_NODE); fa; fa = PKL_AST_CHAIN (fa))
      narg++;

    if (narg == 2)
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);
    else if (narg == 3)
      {
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ROT);
      }
    else if (narg > 1)
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REVN, narg);
  }

  /* Push the function environment, for the arguments, if there are
     any.  The compound-statement that is the body for the function
     will create it's own frame.  */
  if (PKL_AST_FUNC_ARGS (PKL_PASS_NODE))
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSHF);

  /* If the function's return type is an array type, make sure it has
     a bounder.  If it hasn't one, then compute it in this
     environment.  */
  {
    pkl_ast_node rtype = PKL_AST_FUNC_RET_TYPE (PKL_PASS_NODE);

    if (PKL_AST_TYPE_CODE (rtype) == PKL_TYPE_ARRAY
        && PKL_AST_TYPE_A_BOUNDER (rtype) == PVM_NULL)
      {
        PKL_GEN_PAYLOAD->in_array_bounder = 1;
        PKL_PASS_SUBPASS (rtype);
        PKL_GEN_PAYLOAD->in_array_bounder = 0;
      }
  }
}
PKL_PHASE_END_HANDLER

/*
 * FUNC_ARG
 * | INITIAL
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_func_arg)
{
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node func_arg = PKL_PASS_NODE;
  pkl_ast_node func_arg_initial = PKL_AST_FUNC_ARG_INITIAL (func_arg);
  pkl_ast_node func_arg_type = PKL_AST_FUNC_ARG_TYPE (func_arg);
  jitter_label after_conv_label = pkl_asm_fresh_label (PKL_GEN_ASM);

  if (func_arg_initial)
    {
      jitter_label label = pkl_asm_fresh_label (PKL_GEN_ASM);

      /* If the value on the stack is `null', that means we need to
         use the default value for the argument.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BNN, label);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP); /* Drop the null */
      PKL_PASS_SUBPASS (func_arg_initial);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BA, after_conv_label);
      pkl_asm_label (PKL_GEN_ASM, label);
    }

  /* If the argument is an array, check/cast to it's type, in order to
     perform whatever needed run-time checks.  This is done here and
     not in a cast at funcall time because the argument's type is
     evaluated in the function's lexical environment.  As per promo,
     we know that the value on the stack is an array with the same
     base type, but possibly different bounding.

     Note that if the initial argument is used, then the flow jumps to
     `after_conv_label' and therefore the code below is not executed,
     as promo already performed a cast if needed.  */
  if (PKL_AST_TYPE_CODE (func_arg_type) == PKL_TYPE_ARRAY)
    {
      /* Make sure the cast type has a bounder.  If it doesn't,
         compile and install one.  */
      if (PKL_AST_TYPE_A_BOUNDER (func_arg_type) == PVM_NULL)
        {
          PKL_GEN_PAYLOAD->in_array_bounder = 1;
          PKL_PASS_SUBPASS (func_arg_type);
          PKL_GEN_PAYLOAD->in_array_bounder = 0;
        }

      pkl_asm_insn (pasm, PKL_INSN_ATOA,
                    NULL /* from_type */, func_arg_type);
    }

  pkl_asm_label (PKL_GEN_ASM, after_conv_label);

  /* Pop the actual argument from the stack and put it in the current
     environment.  */
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REGVAR);

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * | [TYPE]
 * | [FUNC_ARG]
 * | ...
 * | BODY
 * FUNC
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_func)
{
  /* Function epilogue.  */

  pkl_ast_node function = PKL_PASS_NODE;
  pkl_ast_node function_type = PKL_AST_TYPE (function);


  /* In a void function, return PVM_NULL in the stack.  Otherwise, it
     is a run-time error to reach this point.  */
  if (PKL_AST_TYPE_CODE (PKL_AST_TYPE_F_RTYPE (function_type))
      == PKL_TYPE_VOID)
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
  else
    {
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                    pvm_make_int (PVM_E_NO_RETURN, 32));
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAISE);
    }

  /* Pop the function's argument environment, if any, and return.  */
  if (PKL_AST_FUNC_ARGS (function))
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POPF, 1);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RETURN);
}
PKL_PHASE_END_HANDLER

/*
 * INTEGER
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_integer)
{
  pkl_ast_node integer = PKL_PASS_NODE;
  pkl_ast_node type;
  pvm_val val;
  int size;
  uint64_t value;

  type = PKL_AST_TYPE (integer);
  assert (type != NULL
          && PKL_AST_TYPE_CODE (type) == PKL_TYPE_INTEGRAL);

  size = PKL_AST_TYPE_I_SIZE (type);
  value = PKL_AST_INTEGER_VALUE (integer);

  if ((size - 1) & ~0x1f)
    {
      if (PKL_AST_TYPE_I_SIGNED (type))
        val = pvm_make_long (value, size);
      else
        val = pvm_make_ulong (value, size);
    }
  else
    {
      if (PKL_AST_TYPE_I_SIGNED (type))
        val = pvm_make_int (value, size);
      else
        val = pvm_make_uint (value, size);
    }

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, val);
}
PKL_PHASE_END_HANDLER

/*
 * IDENTIFIER
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_identifier)
{
  pkl_ast_node identifier = PKL_PASS_NODE;
  pvm_val val
    = pvm_make_string (PKL_AST_IDENTIFIER_POINTER (identifier));

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, val);
}
PKL_PHASE_END_HANDLER

/*
 * STRING
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_string)
{
  pkl_ast_node string = PKL_PASS_NODE;
  pvm_val val
    = pvm_make_string (PKL_AST_STRING_POINTER (string));

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, val);
}
PKL_PHASE_END_HANDLER

/*
 * TYPE
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_type)
{
  /* Type nodes are handled by the code generator only in certain
     circumstances.  In any other cases, break the pass to avoid
     post-order hooks to be invoked.  Note that this logic is
     duplicated in pkl_gen_pr_type_array.  Please keep them
     synchronized!  */

  if (PKL_GEN_PAYLOAD->in_struct_decl)
    PKL_PASS_DONE;

  if (PKL_PASS_PARENT)
    {
      switch (PKL_AST_CODE (PKL_PASS_PARENT))
        {
        case PKL_AST_TYPE:
        case PKL_AST_STRUCT_TYPE_FIELD:
          /* Process these.  */
          break;
        default:
          PKL_PASS_BREAK;
          break;
        }
    }
}
PKL_PHASE_END_HANDLER

/*
 * TYPE_OFFSET
 * | BASE_TYPE
 * | UNIT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_type_offset)
{
  if (PKL_GEN_PAYLOAD->in_writer)
    {
      /* Stack: OFF VAL */
      /* The offset to poke is stored in the TOS.  Replace the offset
         at the TOS with the magnitude of the offset and let the
         BASE_TYPE handler to tackle it.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_OGETM); /* OFF VAL VMAG */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);   /* OFF VMAG */
    }
}
PKL_PHASE_END_HANDLER

/*
 * | BASE_TYPE
 * | UNIT
 * TYPE_OFFSET
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_type_offset)
{
  /* Note that in_writer is handled in the pre-order handler, and not
     here.  */

  /* XXX handle mapper (peek the offset magnitude) and the writer
     (poke the offset magnitude).  */

  if (PKL_GEN_PAYLOAD->in_mapper)
    /* Stack: OFF */
    /* XXX wtf */
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKO);
  else if (PKL_GEN_PAYLOAD->in_valmapper)
    {
      /* Stack: VAL NVAL OFF */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP); /* VAL NVAL */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP); /* NVAL */
    }
  else
    /* Just build an offset type.  */
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKTYO);

}
PKL_PHASE_END_HANDLER

/*
 * | TYPE
 * | MAGNITUDE
 * | UNIT
 * OFFSET
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_offset)
{
  pkl_asm pasm = PKL_GEN_ASM;

  pkl_asm_insn (pasm, PKL_INSN_MKO);
}
PKL_PHASE_END_HANDLER

/*
 * | EXP
 * ISA
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_isa)
{
  PKL_PASS_SUBPASS (PKL_AST_ISA_TYPE (PKL_PASS_NODE));
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ISA);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);
}
PKL_PHASE_END_HANDLER

/*
 * | [TYPE is not generated]
 * | EXP
 * CAST
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_cast)
{
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node node = PKL_PASS_NODE;

  pkl_ast_node exp;
  pkl_ast_node to_type;
  pkl_ast_node from_type;

  exp = PKL_AST_CAST_EXP (node);

  to_type = PKL_AST_CAST_TYPE (node);
  from_type = PKL_AST_TYPE (exp);

  if (PKL_AST_TYPE_CODE (from_type) == PKL_TYPE_ANY)
    {
      jitter_label label = pkl_asm_fresh_label (PKL_GEN_ASM);

      PKL_PASS_SUBPASS (to_type);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ISA);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BNZI, label);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_int (PVM_E_CONV, 32));
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAISE);
      pkl_asm_label (PKL_GEN_ASM, label);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
    }
  else if (PKL_AST_TYPE_CODE (from_type) == PKL_TYPE_INTEGRAL
           && PKL_AST_TYPE_CODE (to_type) == PKL_TYPE_INTEGRAL)
    {
      pkl_asm_insn (pasm, PKL_INSN_NTON,
                    from_type, to_type);
      pkl_asm_insn (pasm, PKL_INSN_NIP);
    }
  else if (PKL_AST_TYPE_CODE (from_type) == PKL_TYPE_OFFSET
           && PKL_AST_TYPE_CODE (to_type) == PKL_TYPE_OFFSET)
    {
      pkl_ast_node to_unit = PKL_AST_TYPE_O_UNIT (to_type);

      /* XXX pass `unit' as an argument to OTO.  */
      pkl_asm_insn (pasm, PKL_INSN_PUSH,
                    pvm_make_ulong (PKL_AST_INTEGER_VALUE (to_unit), 64));
      pkl_asm_insn (pasm, PKL_INSN_OTO, from_type, to_type);
    }
  else if (PKL_AST_TYPE_CODE (to_type) == PKL_TYPE_STRING)
    {
      pkl_asm_insn (pasm, PKL_INSN_CTOS);
      pkl_asm_insn (pasm, PKL_INSN_NIP);
    }
  else if (PKL_AST_TYPE_CODE (to_type) == PKL_TYPE_ARRAY
           && PKL_AST_TYPE_CODE (from_type) == PKL_TYPE_ARRAY)
    {
      /* Make sure the cast type has a bounder.  If it doesn't,
         compile and install one.  */
      if (PKL_AST_TYPE_A_BOUNDER (to_type) == PVM_NULL)
        {
          PKL_GEN_PAYLOAD->in_array_bounder = 1;
          PKL_PASS_SUBPASS (to_type);
          PKL_GEN_PAYLOAD->in_array_bounder = 0;
        }

      pkl_asm_insn (pasm, PKL_INSN_ATOA, from_type, to_type);
    }
  else
    /* XXX: handle casts to structs.  For structs, reorder fields.  */
    assert (0);

}
PKL_PHASE_END_HANDLER

/*
 * | SCONS_VALUE
 * SCONS
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_scons)
{
  pkl_ast_node scons = PKL_PASS_NODE;
  pkl_ast_node scons_type = PKL_AST_SCONS_TYPE (scons);

  /* Call the constructor function of the struct type, passing
     SCONS_VALUE as an argument.  The constructor will return a struct
     on the top of the stack.

     Since we know that the type has been specified by name, due to
     syntax, then the constructor closure is for sure defined in the
     type AST node.

     XXX: install an exception handler for constraint errors, etc.  */

  pvm_val constructor = PKL_AST_TYPE_S_CONSTRUCTOR (scons_type);

  assert (constructor != PVM_NULL);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, constructor);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_CALL);
}
PKL_PHASE_END_HANDLER

/*
 * MAP
 * | MAP_OFFSET
 * | MAP_TYPE
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_map)
{
  pkl_ast_node map = PKL_PASS_NODE;
  pkl_ast_node map_type = PKL_AST_MAP_TYPE (map);
  pkl_ast_node map_offset = PKL_AST_MAP_OFFSET (map);

  /* Push the offset of the map.  */
  /* XXX converted to a bit-offset in an ulong<64>.  */
  /* XXX here we can assume the offset is offset<ulong<64>,b> as per
     promo.  */
  PKL_PASS_SUBPASS (map_offset);

  PKL_GEN_PAYLOAD->in_mapper = 1;
  PKL_PASS_SUBPASS (map_type);
  PKL_GEN_PAYLOAD->in_mapper = 0;

  /* If the mapped value is PVM_NULL then raise an exception.  */
  {
    jitter_label label = pkl_asm_fresh_label (PKL_GEN_ASM);

    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BNN, label);
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_int (PVM_E_EOF, 32));
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAISE);
    pkl_asm_label (PKL_GEN_ASM, label);
  }

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * ARRAY_INITIALIZER
 * | ARRAY_INITIALIZER_INDEX
 * | ARRAY_INITIALIZER_EXP
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_array_initializer)
{
  /* Offset of the array initializer.  PVM_NULL since this array is
     not mapped.  */
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
}
PKL_PHASE_END_HANDLER

/*
 * | ARRAY_INITIALIZER_INDEX
 * | ARRAY_INITIALIZER_EXP
 * ARRAY_INITIALIZER
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_array_initializer)
{
  /* Nothing to do.  */
}
PKL_PHASE_END_HANDLER

/*
 *  ARRAY
 *  | ARRAY_INITIALIZER
 *  | ...
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_array)
{
  /* The offset for mka, in this case PVM_NULL, since this array is
     not mapped.  */

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
  PKL_PASS_SUBPASS (PKL_AST_TYPE (PKL_PASS_NODE));
}
PKL_PHASE_END_HANDLER

/*
 * | ARRAY_TYPE
 * | ARRAY_INITIALIZER
 * | ...
 * ARRAY
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_array)
{
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node array = PKL_PASS_NODE;

  pkl_asm_insn (pasm, PKL_INSN_PUSH,
                pvm_make_ulong (PKL_AST_ARRAY_NELEM (array), 64));

  pkl_asm_insn (pasm, PKL_INSN_PUSH,
                pvm_make_ulong (PKL_AST_ARRAY_NINITIALIZER (array), 64));

  pkl_asm_insn (pasm, PKL_INSN_MKA);
}
PKL_PHASE_END_HANDLER

/*
 * | ENTITY
 * | FROM
 * | TO
 * TRIMMER
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_trimmer)
{
  pkl_ast_node trimmer = PKL_PASS_NODE;
  pkl_ast_node trimmer_type = PKL_AST_TYPE (trimmer);

  switch (PKL_AST_TYPE_CODE (trimmer_type))
    {
    case PKL_TYPE_STRING:
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SUBSTR);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
      break;
    case PKL_TYPE_ARRAY:
      {
        pkl_ast_node array = PKL_AST_TRIMMER_ENTITY (trimmer);

        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_ATRIM,
                      PKL_AST_TYPE (array));
        break;
      }
    default:
      assert (0);
    }
}
PKL_PHASE_END_HANDLER

/*
 * | INDEXER_ENTITY
 * | INDEXER_INDEX
 * INDEXER
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_indexer)
{

  if (PKL_PASS_PARENT == NULL && PKL_GEN_PAYLOAD->in_lvalue)
    {
      /* This is a l-value in an assignment.  The array and the index
         are pushed to the stack for the ass_stmt PS handler.  Nothing
         else to do here.  Note that analf guarantees that the entity
         in this indexer is an array, not a string.  */
    }
  else
    {
      pkl_ast_node indexer = PKL_PASS_NODE;
      pkl_ast_node indexer_type = PKL_AST_TYPE (indexer);
      pkl_ast_node container = PKL_AST_INDEXER_ENTITY (indexer);
      pkl_ast_node container_type = PKL_AST_TYPE (container);

      switch (PKL_AST_TYPE_CODE (container_type))
        {
        case PKL_TYPE_ARRAY:
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_AREF);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);

          /* To cover cases where the referenced array is not mapped, but
             the value stored in it is a mapped value, we issue a
             REMAP.  */
          switch (PKL_AST_TYPE_CODE (indexer_type))
            {
            case PKL_TYPE_ARRAY:
            case PKL_TYPE_STRUCT:
              /* XXX: this is redundant IO for many (most?) cases.  */
              /* XXX: handle exceptions from the mapper function.  */
              pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REMAP);
              break;
            default:
              break;
            }
          break;
        case PKL_TYPE_STRING:
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_STRREF);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);
          break;
        default:
          assert (0);
        }
    }
}
PKL_PHASE_END_HANDLER

/*
 * STRUCT
 * | STRUCT_FIELD
 * | ...
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_struct)
{
  /* The offset of the new struct, which should be PVM_NULL, as it is
     not mapped.  */
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
}
PKL_PHASE_END_HANDLER

/*
 *  | STRUCT_FIELD
 *  | ...
 *  STRUCT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_struct)
{
  pkl_ast_node sct = PKL_PASS_NODE;
  pkl_ast_node sct_type = PKL_AST_TYPE (sct);

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                pvm_make_ulong (PKL_AST_STRUCT_NELEM (sct), 64));
  PKL_PASS_SUBPASS (sct_type);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKSCT);
}
PKL_PHASE_END_HANDLER

/*
 *  STRUCT_FIELD
 *  | [STRUCT_FIELD_NAME]
 *  | STRUCT_FIELD_EXP
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_struct_field)
{
  pkl_ast_node struct_field = PKL_PASS_NODE;
  pkl_ast_node struct_field_name
    = PKL_AST_STRUCT_FIELD_NAME (struct_field);

  /* Element's offset.  PVM_NULL means use the "natural" offset.  */
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);

  /* If the struct initializer doesn't include a name, generate a null
     value as expected by the mksct instruction.  */
  if (!struct_field_name)
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
}
PKL_PHASE_END_HANDLER

/*
 * | STRUCT
 * | IDENTIFIER
 * STRUCT_REF
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_struct_ref)
{
  if (PKL_PASS_PARENT == NULL && PKL_GEN_PAYLOAD->in_lvalue)
    {
      /* This is a -lvalue in an assignment.  The struct and the
         identifier are pushed to the stack for the ass_stmt PS
         handler.  Nothing else to do here.  */
    }
  else
    {
      pkl_ast_node struct_ref = PKL_PASS_NODE;
      pkl_ast_node struct_ref_type = PKL_AST_TYPE (struct_ref);

      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SREF);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);

      /* To cover cases where the referenced struct is not mapped, but
         the value stored in it is a mapped value, we issue a
         REMAP.  */
      switch (PKL_AST_TYPE_CODE (struct_ref_type))
        {
        case PKL_TYPE_ARRAY:
        case PKL_TYPE_STRUCT:
          /* XXX: this is redundant IO for many (most?) cases.  */
          /* XXX: handle exceptions from the mapper function.  */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_REMAP);
          break;
        default:
          break;
        }
    }
}
PKL_PHASE_END_HANDLER

/*
 * TYPE_ANY
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_type_any)
{
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKTYANY);
}
PKL_PHASE_END_HANDLER

/*
 * TYPE_INTEGRAL
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_type_integral)
{
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node integral_type = PKL_PASS_NODE;

  /* Note that the check for in_writer should appear first than the
     check for in_mapper.  */
  if (PKL_GEN_PAYLOAD->in_writer)
    {
      /* Stack: OFF VAL */
      /* XXX turn OFF to bit-offset  */
      pkl_asm_insn (pasm, PKL_INSN_SWAP); /* VAL OFF */
      pkl_asm_insn (pasm, PKL_INSN_OGETM); /* VAL OFF OFFM */
      pkl_asm_insn (pasm, PKL_INSN_NIP); /* VAL OFFM */
      pkl_asm_insn (pasm, PKL_INSN_SWAP); /* OFFM VAL */
      pkl_asm_insn (pasm, PKL_INSN_POKED, integral_type);
    }
  else if (PKL_GEN_PAYLOAD->in_mapper)
    {
      /* Stack: OFF */
      /* XXX turn OFF to bit-offset */
      pkl_asm_insn (pasm, PKL_INSN_OGETM); /* OFF OFFM */
      pkl_asm_insn (pasm, PKL_INSN_NIP); /* OFFM */
      pkl_asm_insn (pasm, PKL_INSN_PEEKD, integral_type);
    }
  else if (PKL_GEN_PAYLOAD->in_valmapper)
    {
      /* Stack: VAL NVAL OFF */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP); /* NVAL */
    }
  else
    {
      pkl_asm_insn (pasm, PKL_INSN_PUSH,
                    pvm_make_ulong (PKL_AST_TYPE_I_SIZE (integral_type),
                                    64));

      pkl_asm_insn (pasm, PKL_INSN_PUSH,
                    pvm_make_uint (PKL_AST_TYPE_I_SIGNED (integral_type),
                                   32));

      pkl_asm_insn (pasm, PKL_INSN_MKTYI);
    }
}
PKL_PHASE_END_HANDLER

/*
 * FUNC_TYPE_ARG
 * | FUNC_TYPE_ARG_TYPE
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_func_type_arg)
{
  /* XXX: why is it needed a PR handler and a subpass here???  The
     FUNC_TYPE_ARG_TYPE doesn't get traversed in post-order, wtf.  */
  PKL_PASS_SUBPASS (PKL_AST_FUNC_TYPE_ARG_TYPE (PKL_PASS_NODE));
}
PKL_PHASE_END_HANDLER

/*
 * | FUNC_TYPE_ARG
 * | ...
 * | FUNC_TYPE_RTYPE
 * TYPE_FUNCTION
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_type_function)
{
  pkl_ast_node ftype = PKL_PASS_NODE;

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                pvm_make_ulong (PKL_AST_TYPE_F_NARG (ftype), 64));
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKTYC);
}
PKL_PHASE_END_HANDLER

/*
 * TYPE_ARRAY
 * | ETYPE
 * | NELEM
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_type_array)
{
  /* Note that the check for in_writer should appear first than the
     check for in_mapper.  */
  if (PKL_GEN_PAYLOAD->in_writer)
    {
      /* Stack: OFF ARR */
      /* XXX: handle exceptions from the writer.  */
      /* Note that we don't use the offset, because it should be the
         same than the mapped offset in the array.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_WRITE);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP); /* The array.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP); /* The offset. */

      PKL_PASS_BREAK;
    }
  else if (PKL_GEN_PAYLOAD->in_mapper || PKL_GEN_PAYLOAD->in_valmapper)
    {
      pkl_ast_node array_type = PKL_PASS_NODE;
      pkl_ast_node array_type_bound = PKL_AST_TYPE_A_BOUND (array_type);

      pvm_val array_type_mapper = PKL_AST_TYPE_A_MAPPER (array_type);
      pvm_val array_type_writer = PKL_AST_TYPE_A_WRITER (array_type);

      if (PKL_GEN_PAYLOAD->in_valmapper)
        {
          pvm_val mapper_closure;

          /* Compile a valmapper function and complete it using the
             current environment.  This is used when assigning array
             values to mapped arrays.  */
                                                                     /* VAL NVAL OFF */
          RAS_FUNCTION_ARRAY_VALMAPPER (mapper_closure);

          /* Install the current environment in the valmapper closure,
             arrange the arguments (including the attributes of VAL's
             mapping, and call the valmapper to obtain the new
             value.  */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POPR, 0);    /* VAL NVAL */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSHR, 0);   /* VAL NVAL OFF */

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, mapper_closure);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);        /* VAL NVAL OFF CLS */

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SAVER, 0);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_CALL);                 /* VAL */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RESTORER, 0);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSHR, 0);             /* VAL OFF */

          /* Compile a mapper function, complete it using the current
             environment, and install it as the mapper of the new
             value.  */
                                                                     /* VAL OFF */
          PKL_GEN_PAYLOAD->in_valmapper = 0;
          PKL_GEN_PAYLOAD->in_mapper = 1;
          RAS_FUNCTION_ARRAY_MAPPER (mapper_closure);
          PKL_GEN_PAYLOAD->in_mapper = 0;
          PKL_GEN_PAYLOAD->in_valmapper = 1;

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, mapper_closure); /* VAL OFF CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* VAL OFF CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);                  /* VAL CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MSETM);                /* VAL */
        }
      else
        {
          if (array_type_mapper != PVM_NULL)
            {
              pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                            array_type_mapper); /* OFF CLS */
            }
          else
            {
              /* Compile a mapper function and complete it using the
                 current environment.  */
              pvm_val mapper_closure;

              RAS_FUNCTION_ARRAY_MAPPER (mapper_closure);

              /* Complete the mapper closure with the current
                 environment.  */
              /* OFF */
              pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, mapper_closure); /* OFF CLS */
              pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* OFF CLS */
            }

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DUP);                  /* OFF CLS CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NROT);                 /* CLS OFF CLS */

          /* Build the arguments and call the mapper to get a mapped
             array value.  Whether the mapping is bounded, and exactly
             how, is determined from the array type.  */
          if (array_type_bound
              && (PKL_AST_TYPE_CODE (PKL_AST_TYPE (array_type_bound))
                  == PKL_TYPE_INTEGRAL))
            {
              /* XXX call closure in AST node instead of subpassing.
                 The closure has been compiled in the `else'
                 below.  */
              PKL_GEN_PAYLOAD->in_mapper = 0;
              PKL_PASS_SUBPASS (array_type_bound);
              PKL_GEN_PAYLOAD->in_mapper = 1;
            }
          else
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
                                                         /* CLS OFF CLS EBOUND */

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);     /* CLS OFF EBOUND CLS */

          if (array_type_bound
              && (PKL_AST_TYPE_CODE (PKL_AST_TYPE (array_type_bound))
                  == PKL_TYPE_OFFSET))
            {
              /* XXX call closure in AST type node instead of
                 subpassing.  PKL_AST_TYPE_A_BOUND.  */
              PKL_GEN_PAYLOAD->in_mapper = 0;
              PKL_PASS_SUBPASS (array_type_bound);
              PKL_GEN_PAYLOAD->in_mapper = 1;
            }
          else
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
                                                         /* CLS OFF EBOUND CLS SBOUND */

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);     /* CLS OFF EBOUND SBOUND CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_CALL);     /* CLS VAL */

          /* Install the mapper into the value.  */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);  /* VAL CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MSETM); /* VAL */
        }

      if (array_type_writer != PVM_NULL)
        {
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                        array_type_writer); /* VAL CLS */
        }
      else
        {
          pvm_val writer_closure;

          /* Compile a writer function to a closure.  */
          RAS_FUNCTION_ARRAY_WRITER (writer_closure);

          /* Complete the writer closure with the current
             environment.  */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, writer_closure); /* VAL CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* VAL CLS */
        }

      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MSETW);                /* VAL */
      /* Yay!, we are done ;) */
      PKL_PASS_BREAK;
    }
  else if (PKL_GEN_PAYLOAD->in_array_bounder)
    {
      pkl_ast_node array_type = PKL_PASS_NODE;
      pkl_ast_node etype = PKL_AST_TYPE_A_ETYPE (array_type);
      pvm_val bounder_closure;

      if (PKL_AST_TYPE_CODE (etype) == PKL_TYPE_ARRAY)
        PKL_PASS_SUBPASS (etype);

      RAS_FUNCTION_ARRAY_BOUNDER (bounder_closure);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, bounder_closure); /* CLS */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                   /* CLS */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);                  /* _ */

      /* XXX */
      /* pvm_print_program (stdout, PVM_VAL_CLS_PROGRAM (bounder_closure)); */

      PKL_AST_TYPE_A_BOUNDER (array_type) = bounder_closure;
      PKL_PASS_BREAK;
    }
  else
    {
      /* Generating a PVM array type.  */

      pkl_ast_node etype = PKL_AST_TYPE_A_ETYPE (PKL_PASS_NODE);
      pkl_ast_node bound = PKL_AST_TYPE_A_BOUND (PKL_PASS_NODE);

      /* XXX this is replicating the logic in pkl_gen_pr_type.  */
      if (PKL_PASS_PARENT)
        {
          switch (PKL_AST_CODE (PKL_PASS_PARENT))
            {
            case PKL_AST_TYPE:
            case PKL_AST_STRUCT_TYPE_FIELD:
              /* Process these.  */
              break;
            default:
              PKL_PASS_BREAK;
              break;
            }
        }

      PKL_PASS_SUBPASS (etype);
      if (bound)
        /* XXX compile a closure with the code in `bound' and call it
           to get the value.  Install the closure in the AST node so
           subsequent references to the type have access to it.  */
        PKL_PASS_SUBPASS (bound);
      else
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);

      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKTYA);

      PKL_PASS_BREAK;
    }
}
PKL_PHASE_END_HANDLER

/*
 * TYPE_STRING
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_type_string)
{
  /* Note that the check for in_writer should appear first than the
     check for in_mapper.  */

  if (PKL_GEN_PAYLOAD->in_writer)
    {
      /* Stack: OFF STR */
      /* XXX turn OFF to bit-offset  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP); /* STR OFF */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_OGETM); /* STR OFF OFFM */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP); /* STR OFFM */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP); /* OFFM STR */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_POKES);
    }
  else if (PKL_GEN_PAYLOAD->in_mapper)
    {
      /* Stack: OFF */
      /* XXX turn OFF to bit-offset */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_OGETM); /* OFF OFFM */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP); /* OFFM */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEEKS);
    }
  else if (PKL_GEN_PAYLOAD->in_valmapper)
    {
      /* Stack: VAL NVAL OFF */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
    }
  else
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKTYS);
}
PKL_PHASE_END_HANDLER

/*
 * TYPE_STRUCT
 * | STRUCT_TYPE_FIELD
 * | ...
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_type_struct)
{
  /* Note that the check for in_writer should appear first than the
     check for in_mapper.  */

  if (PKL_GEN_PAYLOAD->in_writer)
    {
      /* Stack: OFF SCT */
      /* XXX: handle exceptions from the writer.  */

      /* Note that we don't use the offset, because it should be the
         same than the mapped offset in the struct.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_WRITE);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP); /* The struct.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP); /* The offset. */
      PKL_PASS_BREAK;
    }
  else if (PKL_GEN_PAYLOAD->in_mapper)
    {
      /* Stack: OFF */
      pkl_ast_node type_struct = PKL_PASS_NODE;
      pkl_ast_node type_struct_elems = PKL_AST_TYPE_S_ELEMS (type_struct);
      pkl_ast_node field;

      pvm_val type_struct_mapper = PKL_AST_TYPE_S_MAPPER (type_struct);
      pvm_val type_struct_writer = PKL_AST_TYPE_S_WRITER (type_struct);

      if (type_struct_mapper != PVM_NULL)
        {
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                        type_struct_mapper); /* OFF CLS */
        }
      else
        {
          /* Compile a mapper function and complete it using the
             current environment.  */
          pvm_val mapper_closure;

          RAS_FUNCTION_STRUCT_MAPPER (mapper_closure);
                                                                     /* OFF */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, mapper_closure); /* OFF CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* OFF CLS */
        }

      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DUP);                  /* OFF CLS CLS */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NROT);                 /* CLS OFF CLS */

      /* Build the arguments and call the mapper to get a struct
         value.  For structs, both EBOUND and SBOUND are always
         null.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_TOR);                 /* CLS OFF */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);      /* CLS OFF EBOUND */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);      /* CLS OFF EBOUND SBOUND */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_FROMR);               /* CLS OFF EBOUND SBOUND CLS */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_CALL);                /* CLS VAL */

      /* Install the mapper into the value.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SWAP);                /* VAL CLS */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MSETM);               /* VAL */

      if (type_struct_writer != PVM_NULL)
        {
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                        type_struct_writer); /* VAL CLS */
        }
      else
        {
          /* Compile a writer function and complete it using the
             current environment.  */
          pvm_val writer_closure;

          RAS_FUNCTION_STRUCT_WRITER (writer_closure);

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, writer_closure); /* VAL CLS */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC);                  /* VAL CLS */
        }

      /* Install the writer into the value.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MSETW);                /* VAL */

      /* And we are done.  */
      PKL_PASS_BREAK;
    }
  else if (PKL_GEN_PAYLOAD->in_constructor)
    {
      /* Stack: SCT */
      pkl_ast_node type_struct = PKL_PASS_NODE;
      pkl_ast_node type_struct_elems = PKL_AST_TYPE_S_ELEMS (type_struct);
      pkl_ast_node field;

      pvm_val type_struct_constructor = PKL_AST_TYPE_S_CONSTRUCTOR (type_struct);

      if (type_struct_constructor != PVM_NULL)
        {
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                        type_struct_constructor); /* SCT CLS */
        }
      else
        {
          /* Compile a constructor function and complete it using the
             current environment.  */
          pvm_val constructor_closure;

          RAS_FUNCTION_STRUCT_CONSTRUCTOR (constructor_closure);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, constructor_closure);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PEC); /* SCT CLS */
        }

      /* Call the constructor to get a new struct.  */
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_CALL);    /* SCT CLS CLS */

      /* And we are done.  */
      PKL_PASS_BREAK;
    }
}
PKL_PHASE_END_HANDLER

/*
 * | STRUCT_TYPE_FIELD
 * | ...
 * TYPE_STRUCT
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_type_struct)
{
  /* We are generating a PVM struct type.  */

  pkl_ast_node struct_type = PKL_PASS_NODE;
  pkl_ast_node type_name = PKL_AST_TYPE_NAME (struct_type);

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                pvm_make_ulong (PKL_AST_TYPE_S_NELEM (struct_type), 64));
  if (type_name)
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                  pvm_make_string (PKL_AST_IDENTIFIER_POINTER (type_name)));
  else
    pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MKTYSCT);
}
PKL_PHASE_END_HANDLER

/*
 * STRUCT_TYPE_FIELD
 * | [STRUCT_TYPE_FIELD_NAME]
 * | STRUCT_TYPE_FIELD_TYPE
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_pr_struct_type_field)
{
  assert (!PKL_GEN_PAYLOAD->in_mapper);

  if (PKL_GEN_PAYLOAD->in_writer)
    {
      assert (0);
    }
  else if (PKL_GEN_PAYLOAD->in_constructor)
    {
      assert (0);
    }
  else
    {
      /* We are generating a PVM struct type.  */

      /* If the struct type element doesn't include a name, generate a
         null value as expected by the mktysct instruction.  */
      if (!PKL_AST_STRUCT_TYPE_FIELD_NAME (PKL_PASS_NODE))
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, PVM_NULL);
      else
        PKL_PASS_SUBPASS (PKL_AST_STRUCT_TYPE_FIELD_NAME (PKL_PASS_NODE));
      PKL_PASS_SUBPASS (PKL_AST_STRUCT_TYPE_FIELD_TYPE (PKL_PASS_NODE));
    }

  PKL_PASS_BREAK;
}
PKL_PHASE_END_HANDLER

/*
 * Expression handlers.
 *
 * | OPERAND1
 * | [OPERAND2]
 * EXP
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_add)
{
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node node = PKL_PASS_NODE;
  pkl_ast_node type = PKL_AST_TYPE (node);

  switch (PKL_AST_TYPE_CODE (type))
    {
    case PKL_TYPE_INTEGRAL:
      pkl_asm_insn (pasm, PKL_INSN_ADD, type);
      pkl_asm_insn (pasm, PKL_INSN_NIP2);
      break;
    case PKL_TYPE_STRING:
      pkl_asm_insn (pasm, PKL_INSN_SCONC);
      pkl_asm_insn (pasm, PKL_INSN_NIP2);
      break;
    case PKL_TYPE_OFFSET:
      {
        pkl_ast_node base_type = PKL_AST_TYPE_O_BASE_TYPE (type);
        pkl_ast_node unit = PKL_AST_TYPE_O_UNIT (type);

        pkl_asm_insn (pasm, PKL_INSN_ADDO, base_type, unit);
        pkl_asm_insn (pasm, PKL_INSN_NIP2);
      }
      break;
    default:
      assert (0);
      break;
    }
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_sub)
{
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node node = PKL_PASS_NODE;
  pkl_ast_node type = PKL_AST_TYPE (node);

  switch (PKL_AST_TYPE_CODE (type))
    {
    case PKL_TYPE_INTEGRAL:
      pkl_asm_insn (pasm, PKL_INSN_SUB, type);
      pkl_asm_insn (pasm, PKL_INSN_NIP2);
      break;
    case PKL_TYPE_OFFSET:
      {
        pkl_ast_node base_type = PKL_AST_TYPE_O_BASE_TYPE (type);
        pkl_ast_node unit = PKL_AST_TYPE_O_UNIT (type);

        pkl_asm_insn (pasm, PKL_INSN_SUBO, base_type, unit);
        pkl_asm_insn (pasm, PKL_INSN_NIP2);
      }
      break;
    default:
      assert (0);
      break;
    }
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_mul)
{
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node node = PKL_PASS_NODE;
  pkl_ast_node type = PKL_AST_TYPE (node);

  switch (PKL_AST_TYPE_CODE (type))
    {
    case PKL_TYPE_INTEGRAL:
      pkl_asm_insn (pasm, PKL_INSN_MUL, type);
      pkl_asm_insn (pasm, PKL_INSN_NIP2);
      break;
    case PKL_TYPE_OFFSET:
      {
        pkl_ast_node op1 = PKL_AST_EXP_OPERAND (node, 0);
        pkl_ast_node op2 = PKL_AST_EXP_OPERAND (node, 1);
        pkl_ast_node op1_type = PKL_AST_TYPE (op1);
        pkl_ast_node op2_type = PKL_AST_TYPE (op2);
        pkl_ast_node base_type;

        if (PKL_AST_TYPE_CODE (op1_type) == PKL_TYPE_OFFSET)
          base_type = PKL_AST_TYPE_O_BASE_TYPE (op1_type);
        else
          {
            base_type = PKL_AST_TYPE_O_BASE_TYPE (op2_type);
            pkl_asm_insn (pasm, PKL_INSN_SWAP);
          }

        pkl_asm_insn (pasm, PKL_INSN_MULO, base_type);
        pkl_asm_insn (pasm, PKL_INSN_NIP2);
      }
      break;
    default:
      assert (0);
      break;
    }
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_div)
{
  pkl_ast_node node = PKL_PASS_NODE;
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node type = PKL_AST_TYPE (node);
  pkl_ast_node op2 = PKL_AST_EXP_OPERAND (node, 0);
  pkl_ast_node op2_type = PKL_AST_TYPE (op2);

  switch (PKL_AST_TYPE_CODE (type))
    {
    case PKL_TYPE_INTEGRAL:
      {
        if (PKL_AST_TYPE_CODE (op2_type) == PKL_TYPE_OFFSET)
          {
            pkl_asm_insn (pasm, PKL_INSN_DIVO,
                          PKL_AST_TYPE_O_BASE_TYPE (op2_type));
            pkl_asm_insn (pasm, PKL_INSN_NIP2);
          }
        else
          {
            pkl_asm_insn (pasm, PKL_INSN_DIV, type);
            pkl_asm_insn (pasm, PKL_INSN_NIP2);
          }
        break;
      }
    default:
      assert (0);
      break;
    }
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_mod)
{
  pkl_ast_node node = PKL_PASS_NODE;

  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node type = PKL_AST_TYPE (node);

  switch (PKL_AST_TYPE_CODE (type))
    {
    case PKL_TYPE_INTEGRAL:
      pkl_asm_insn (pasm, PKL_INSN_MOD, type);
      pkl_asm_insn (pasm, PKL_INSN_NIP2);
      break;
    case PKL_TYPE_OFFSET:
      {
        pkl_ast_node base_type = PKL_AST_TYPE_O_BASE_TYPE (type);
        pkl_ast_node unit = PKL_AST_TYPE_O_UNIT (type);

        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MODO, base_type, unit);
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);
        break;
      }
    default:
      assert (0);
      break;
    }
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_intexp)
{
  pkl_asm pasm = PKL_GEN_ASM;

  pkl_ast_node node = PKL_PASS_NODE;
  pkl_ast_node type = PKL_AST_TYPE (node);

  enum pkl_asm_insn insn;

  if (PKL_AST_EXP_CODE (node) == PKL_AST_OP_POS)
    /* POS in integers is basically a nop.  */
    PKL_PASS_DONE;

  switch (PKL_AST_EXP_CODE (node))
    {
    case PKL_AST_OP_BAND: insn = PKL_INSN_BAND; break;
    case PKL_AST_OP_BNOT: insn = PKL_INSN_BNOT; break;
    case PKL_AST_OP_NEG: insn = PKL_INSN_NEG; break;
    case PKL_AST_OP_IOR: insn = PKL_INSN_BOR; break;
    case PKL_AST_OP_XOR: insn = PKL_INSN_BXOR; break;
    case PKL_AST_OP_SL: insn = PKL_INSN_SL; break;
    case PKL_AST_OP_SR: insn = PKL_INSN_SR; break;
    default:
      assert (0);
      break;
    }

  switch (PKL_AST_TYPE_CODE (type))
    {
    case PKL_TYPE_INTEGRAL:
      pkl_asm_insn (pasm, insn, type);
      pkl_asm_insn (pasm, PKL_INSN_NIP);
      if (insn != PKL_INSN_NEG
          && insn != PKL_INSN_BNOT)
        pkl_asm_insn (pasm, PKL_INSN_NIP);
      break;
    default:
      assert (0);
      break;
    }
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_and)
{
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_AND);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_or)
{
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_OR);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_not)
{
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NOT);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
}
PKL_PHASE_END_HANDLER

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_rela)
{
  pkl_asm pasm = PKL_GEN_ASM;
  pkl_ast_node exp = PKL_PASS_NODE;
  int exp_code = PKL_AST_EXP_CODE (exp);
  pkl_ast_node op1 = PKL_AST_EXP_OPERAND (exp, 0);
  pkl_ast_node op1_type = PKL_AST_TYPE (op1);

  enum pkl_asm_insn rela_insn;

  switch (exp_code)
    {
    case PKL_AST_OP_EQ: rela_insn = PKL_INSN_EQ; break;
    case PKL_AST_OP_NE: rela_insn = PKL_INSN_NE; break;
    case PKL_AST_OP_LT: rela_insn = PKL_INSN_LT; break;
    case PKL_AST_OP_GT: rela_insn = PKL_INSN_GT; break;
    case PKL_AST_OP_LE: rela_insn = PKL_INSN_LE; break;
    case PKL_AST_OP_GE: rela_insn = PKL_INSN_GE; break;
    default:
      assert (0);
      break;
    }

  switch (PKL_AST_TYPE_CODE (op1_type))
    {
    case PKL_TYPE_INTEGRAL:
    case PKL_TYPE_STRING:
      pkl_asm_insn (pasm, rela_insn, op1_type);
      pkl_asm_insn (pasm, PKL_INSN_NIP2);
      break;
    case PKL_TYPE_OFFSET:
      {
        pkl_ast_node base_type = PKL_AST_TYPE_O_BASE_TYPE (op1_type);

        /* Equality and inequality are commutative, so we can save an
           instruction here.  */
        if (exp_code != PKL_AST_OP_EQ && exp_code != PKL_AST_OP_NE)
          pkl_asm_insn (pasm, PKL_INSN_SWAP);

        pkl_asm_insn (pasm, PKL_INSN_OGETM); /* OFF2 OFF1 OFF1M */
        pkl_asm_insn (pasm, PKL_INSN_ROT);   /* OFF1 OFF1M OFF2 */
        pkl_asm_insn (pasm, PKL_INSN_OGETM); /* OFF1 OFF1M OFF2 OFF2M */
        pkl_asm_insn (pasm, PKL_INSN_ROT);   /* OFF1 OFF2 OFF2M OFF1M */
        pkl_asm_insn (pasm, PKL_INSN_SWAP);  /* OFF1 OFF2 OFF1M OFF2M */
        pkl_asm_insn (pasm, rela_insn, base_type);
        pkl_asm_insn (pasm, PKL_INSN_NIP2);  /* OFF1 OFF2 (OFF1M?OFF2M) */
        pkl_asm_insn (pasm, PKL_INSN_NIP2);  /* (OFF1M?OFF2M) */
      }
      break;
    default:
      assert (0);
      break;
    }
}
PKL_PHASE_END_HANDLER

/*
 * | OPERAND1
 * EXP
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_attr)
{
  pkl_ast_node exp = PKL_PASS_NODE;
  pkl_ast_node operand = PKL_AST_EXP_OPERAND (exp, 0);
  pkl_ast_node operand_type = PKL_AST_TYPE (operand);
  enum pkl_ast_attr attr = PKL_AST_EXP_ATTR (exp);

  switch (attr)
    {
    case PKL_AST_ATTR_SIZE:
      /* If the value is an ANY, check the type is NOT a function
         value.  */
      if (PKL_AST_TYPE_CODE (operand_type) == PKL_TYPE_ANY)
        {
          jitter_label label = pkl_asm_fresh_label (PKL_GEN_ASM);

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_TYISC);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BZI, label);

          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                        pvm_make_int (PVM_E_CONV, 32));
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAISE);

          pkl_asm_label (PKL_GEN_ASM, label);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
        }
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SIZ);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
      /* XXX up-unit to the highest possible power of 2.  */
      break;
    case PKL_AST_ATTR_MAGNITUDE:
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_OGETM);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
      break;
    case PKL_AST_ATTR_UNIT:
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_OGETU);
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
      break;
    case PKL_AST_ATTR_SIGNED:
      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
      if (PKL_AST_TYPE_I_SIGNED (operand_type))
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_int (1, 32));
      else
        pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH, pvm_make_int (0, 32));
      break;
    case PKL_AST_ATTR_LENGTH:
      switch (PKL_AST_TYPE_CODE (operand_type))
        {
        case PKL_TYPE_STRING:
        case PKL_TYPE_ARRAY:
        case PKL_TYPE_STRUCT:
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_SEL);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
          break;
        default:
          /* This should not happen.  */
          assert (0);
        }
      break;
    case PKL_AST_ATTR_ALIGNMENT:
      /* XXX writeme */
    case PKL_AST_ATTR_OFFSET:
      switch (PKL_AST_TYPE_CODE (operand_type))
        {
        case PKL_TYPE_ARRAY:
        case PKL_TYPE_STRUCT:
          {
            jitter_label label = pkl_asm_fresh_label (PKL_GEN_ASM);

            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MGETO);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BNN, label);
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                          pvm_make_int (PVM_E_MAP, 32));
            pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAISE);
            pkl_asm_label (PKL_GEN_ASM, label);
            break;
          }
        default:
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                        pvm_make_int (PVM_E_MAP, 32));
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAISE);
          break;
        }
      break;
    case PKL_AST_ATTR_MAPPED:
      switch (PKL_AST_TYPE_CODE (operand_type))
        {
        case PKL_TYPE_ARRAY:
        case PKL_TYPE_STRUCT:
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_MGETO);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NN);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP);
          break;
        default:
          /* Other types are never mapped.  */
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_DROP);
          pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_PUSH,
                        pvm_make_int (0, 32));
          break;
        }
      break;
    default:
      pkl_ice (PKL_PASS_AST, PKL_AST_LOC (exp),
               "unhandled attribute expression code #%d in code generator",
               attr);
      PKL_PASS_ERROR;
      break;
    }
}
PKL_PHASE_END_HANDLER

/* | OPERAND1
 * | OPERAND2
 * EXP
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_bconc)
{
  pkl_ast_node exp = PKL_PASS_NODE;
  pkl_ast_node op1 = PKL_AST_EXP_OPERAND (exp, 0);
  pkl_ast_node op2 = PKL_AST_EXP_OPERAND (exp, 1);

  pkl_ast_node op1_type = PKL_AST_TYPE (op1);
  pkl_ast_node op2_type = PKL_AST_TYPE (op2);
  pkl_ast_node exp_type = PKL_AST_TYPE (exp);

  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_BCONC,
                op1_type, op2_type, exp_type);
  pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_NIP2);
}
PKL_PHASE_END_HANDLER

/*
 * | OPERAND1
 * EXP
 */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_ps_op_unmap)
{
  RAS_MACRO_OP_UNMAP;
}
PKL_PHASE_END_HANDLER

/* The handler below generates and ICE if a given node isn't handled
   by the code generator.  */

PKL_PHASE_BEGIN_HANDLER (pkl_gen_noimpl)
{
  pkl_ast_node node = PKL_PASS_NODE;

  if (PKL_AST_CODE (node) == PKL_AST_EXP)
    {
      pkl_ice (PKL_PASS_AST, PKL_AST_LOC (node),
               "unhandled node #%" PRIu64 " with code %d opcode %d in code generator",
               PKL_AST_UID (node), PKL_AST_CODE (node), PKL_AST_EXP_CODE (node));
    }
  else if (PKL_AST_CODE (node) == PKL_AST_TYPE)
    {
      pkl_ice (PKL_PASS_AST, PKL_AST_LOC (node),
               "unhandled node #%" PRIu64 " with code %d typecode %d in code generator",
               PKL_AST_UID (node), PKL_AST_CODE (node), PKL_AST_TYPE_CODE (node));
    }
  else
    pkl_ice (PKL_PASS_AST, PKL_AST_LOC (node),
             "unhandled node #%" PRIu64 " with code %d in code generator",
             PKL_AST_UID (node), PKL_AST_CODE (node));

  PKL_PASS_ERROR;
}
PKL_PHASE_END_HANDLER

struct pkl_phase pkl_phase_gen =
  {
   PKL_PHASE_PR_HANDLER (PKL_AST_DECL, pkl_gen_pr_decl),
   PKL_PHASE_PS_HANDLER (PKL_AST_DECL, pkl_gen_ps_decl),
   PKL_PHASE_PS_HANDLER (PKL_AST_VAR, pkl_gen_ps_var),
   PKL_PHASE_PR_HANDLER (PKL_AST_COMP_STMT, pkl_gen_pr_comp_stmt),
   PKL_PHASE_PS_HANDLER (PKL_AST_COMP_STMT, pkl_gen_ps_comp_stmt),
   PKL_PHASE_PS_HANDLER (PKL_AST_NULL_STMT, pkl_gen_ps_null_stmt),
   PKL_PHASE_PR_HANDLER (PKL_AST_ASS_STMT, pkl_gen_pr_ass_stmt),
   PKL_PHASE_PR_HANDLER (PKL_AST_IF_STMT, pkl_gen_pr_if_stmt),
   PKL_PHASE_PS_HANDLER (PKL_AST_BREAK_STMT, pkl_gen_ps_break_stmt),
   PKL_PHASE_PR_HANDLER (PKL_AST_LOOP_STMT, pkl_gen_pr_loop_stmt),
   PKL_PHASE_PR_HANDLER (PKL_AST_RETURN_STMT, pkl_gen_pr_return_stmt),
   PKL_PHASE_PS_HANDLER (PKL_AST_RETURN_STMT, pkl_gen_ps_return_stmt),
   PKL_PHASE_PS_HANDLER (PKL_AST_EXP_STMT, pkl_gen_ps_exp_stmt),
   PKL_PHASE_PR_HANDLER (PKL_AST_PRINT_STMT, pkl_gen_pr_print_stmt),
   PKL_PHASE_PS_HANDLER (PKL_AST_RAISE_STMT, pkl_gen_ps_raise_stmt),
   PKL_PHASE_PR_HANDLER (PKL_AST_TRY_CATCH_STMT, pkl_gen_pr_try_catch_stmt),
   PKL_PHASE_PS_HANDLER (PKL_AST_FUNCALL_ARG, pkl_gen_ps_funcall_arg),
   PKL_PHASE_PR_HANDLER (PKL_AST_FUNCALL, pkl_gen_pr_funcall),
   PKL_PHASE_PR_HANDLER (PKL_AST_FUNC, pkl_gen_pr_func),
   PKL_PHASE_PS_HANDLER (PKL_AST_FUNC, pkl_gen_ps_func),
   PKL_PHASE_PR_HANDLER (PKL_AST_FUNC_ARG, pkl_gen_pr_func_arg),
   PKL_PHASE_PR_HANDLER (PKL_AST_FUNC_TYPE_ARG, pkl_gen_pr_func_type_arg),
   PKL_PHASE_PR_HANDLER (PKL_AST_TYPE, pkl_gen_pr_type),
   PKL_PHASE_PR_HANDLER (PKL_AST_PROGRAM, pkl_gen_pr_program),
   PKL_PHASE_PS_HANDLER (PKL_AST_PROGRAM, pkl_gen_ps_program),
   PKL_PHASE_PS_HANDLER (PKL_AST_INTEGER, pkl_gen_ps_integer),
   PKL_PHASE_PS_HANDLER (PKL_AST_IDENTIFIER, pkl_gen_ps_identifier),
   PKL_PHASE_PS_HANDLER (PKL_AST_STRING, pkl_gen_ps_string),
   PKL_PHASE_PR_TYPE_HANDLER (PKL_TYPE_OFFSET, pkl_gen_pr_type_offset),
   PKL_PHASE_PS_TYPE_HANDLER (PKL_TYPE_OFFSET, pkl_gen_ps_type_offset),
   PKL_PHASE_PS_HANDLER (PKL_AST_OFFSET, pkl_gen_ps_offset),
   PKL_PHASE_PS_HANDLER (PKL_AST_CAST, pkl_gen_ps_cast),
   PKL_PHASE_PS_HANDLER (PKL_AST_ISA, pkl_gen_ps_isa),
   PKL_PHASE_PR_HANDLER (PKL_AST_MAP, pkl_gen_pr_map),
   PKL_PHASE_PS_HANDLER (PKL_AST_SCONS, pkl_gen_ps_scons),
   PKL_PHASE_PR_HANDLER (PKL_AST_ARRAY, pkl_gen_pr_array),
   PKL_PHASE_PS_HANDLER (PKL_AST_ARRAY, pkl_gen_ps_array),
   PKL_PHASE_PS_HANDLER (PKL_AST_TRIMMER, pkl_gen_ps_trimmer),
   PKL_PHASE_PS_HANDLER (PKL_AST_INDEXER, pkl_gen_ps_indexer),
   PKL_PHASE_PR_HANDLER (PKL_AST_ARRAY_INITIALIZER, pkl_gen_pr_array_initializer),
   PKL_PHASE_PS_HANDLER (PKL_AST_ARRAY_INITIALIZER, pkl_gen_ps_array_initializer),
   PKL_PHASE_PR_HANDLER (PKL_AST_STRUCT, pkl_gen_pr_struct),
   PKL_PHASE_PS_HANDLER (PKL_AST_STRUCT, pkl_gen_ps_struct),
   PKL_PHASE_PR_HANDLER (PKL_AST_STRUCT_FIELD, pkl_gen_pr_struct_field),
   PKL_PHASE_PS_HANDLER (PKL_AST_STRUCT_REF, pkl_gen_ps_struct_ref),
   PKL_PHASE_PR_HANDLER (PKL_AST_STRUCT_TYPE_FIELD, pkl_gen_pr_struct_type_field),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_ADD, pkl_gen_ps_op_add),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_SUB, pkl_gen_ps_op_sub),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_MUL, pkl_gen_ps_op_mul),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_MOD, pkl_gen_ps_op_mod),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_BAND, pkl_gen_ps_op_intexp),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_BNOT, pkl_gen_ps_op_intexp),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_NEG, pkl_gen_ps_op_intexp),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_POS, pkl_gen_ps_op_intexp),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_IOR, pkl_gen_ps_op_intexp),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_XOR, pkl_gen_ps_op_intexp),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_SL, pkl_gen_ps_op_intexp),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_SR, pkl_gen_ps_op_intexp),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_DIV, pkl_gen_ps_op_div),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_AND, pkl_gen_ps_op_and),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_OR, pkl_gen_ps_op_or),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_NOT, pkl_gen_ps_op_not),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_EQ, pkl_gen_ps_op_rela),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_NE, pkl_gen_ps_op_rela),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_LT, pkl_gen_ps_op_rela),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_LE, pkl_gen_ps_op_rela),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_GT, pkl_gen_ps_op_rela),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_GE, pkl_gen_ps_op_rela),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_ATTR, pkl_gen_ps_op_attr),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_BCONC, pkl_gen_ps_op_bconc),
   PKL_PHASE_PS_OP_HANDLER (PKL_AST_OP_UNMAP, pkl_gen_ps_op_unmap),
   PKL_PHASE_PS_TYPE_HANDLER (PKL_TYPE_ANY, pkl_gen_ps_type_any),
   PKL_PHASE_PS_TYPE_HANDLER (PKL_TYPE_INTEGRAL, pkl_gen_ps_type_integral),
   PKL_PHASE_PS_TYPE_HANDLER (PKL_TYPE_FUNCTION, pkl_gen_ps_type_function),
   PKL_PHASE_PR_TYPE_HANDLER (PKL_TYPE_ARRAY, pkl_gen_pr_type_array),
   PKL_PHASE_PS_TYPE_HANDLER (PKL_TYPE_STRING, pkl_gen_ps_type_string),
   PKL_PHASE_PR_TYPE_HANDLER (PKL_TYPE_STRUCT, pkl_gen_pr_type_struct),
   PKL_PHASE_PS_TYPE_HANDLER (PKL_TYPE_STRUCT, pkl_gen_ps_type_struct),
   PKL_PHASE_ELSE_HANDLER (pkl_gen_noimpl),
  };
