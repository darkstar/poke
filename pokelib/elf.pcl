/* elf.pcl -- ELF implementation for GNU poke.  */  /* -*- mode: c -*- */

/* Copyright (C) 2017 Jose E. Marchesi.  */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* This file contains a PCL (poke command language) description of the
 * ELF (Executable and Linking Format) object file format.  The ELF
 * format is described in the chapter 4 of the SysV ABI.
 *
 * Both ELF32 and ELF64 are supported.
 *
 * In general, we use the same field names used in the C structs
 * documented in the gABI, that are also used in the widely used ELF
 * implementations like in the GNU binutils and also in elfutils.
 * This makes life easier for system hackers who are already familiar
 * with these names.
 */

enum elf_ei_class
{
  ELFCLASSNONE 0x0	<<<Invalid class>>>,
  ELFCLASS32 0x1	<<<32-bit objects>>>,
  ELFCLASS64 0x2	<<<64-bit objects>>>
};

enum elf_e_type
{
  ET_NONE = 0x0000	<<<No file type>>>,
  ET_REL  = 0x0001	<<<Relocatable file>>>,
  ET_EXEC = 0x0002	<<<Executable file>>>,
  ET_DYN  = 0x0003	<<<Shared object file>>>,
  ET_CORE = 0x0004	<<<Core file>>>,
  ET_LOOS = 0xFE00	<<<Operating system-specific>>>,
  ET_HIOS = 0xFEFF	<<<Operating system-specific>>>,
  ET_LOPROC = 0xFF00	<<<Processor-specific>>>,
  ET_HIPROC = 0xFFFF	<<<Processor-specific>>>
};

enum elf_e_machine
{
  EM_NONE  = 0		<<<No machine>>>,
  EM_M32   = 1		<<<AT&T WE 32100>>>,
  EM_SPARC = 2		<<<SPARC>>>,
  EM_386   = 3		<<<Intel 80386>>>,
  EM_68K   = 4		<<<Motorola 68000>>>,
  EM_88K   = 5		<<<Motorola 88000>>>,
  EM_IAMCU = 6		<<<Intel MCU>>>,
  EM_860   = 7		<<<Intel 80860>>>,
  EM_MIPS  = 8		<<<MIPS I Architecture>>>,
  EM_S370  = 9		<<<IBM System/370 Processor>>>,
  EM_MIPS_RS3_LE = 10	<<<MIPS RS3000 Little-endian>>>,
  /* 11-14 are reserved.  */
  EM_PARISC = 15	<<<Hewlett-Packard PA-RISC>>>,
  /* 16 is reserved.  */
  EM_VPP500 = 17     	<<<Fujitsu VPP500>>>,
  EM_SPARC32PLUS = 18	<<<32-bit on V9 SPARC>>>
  EM_960 = 19        	<<<Intel 80960>>>,
  EM_PPC = 20        	<<<PowerPC>>>,
  EM_PPC64 = 21      	<<<64-bit PowerPC>>>,
  EM_S390 = 22		<<<IBM System/390 Processor>>>,
  EM_SPU = 23		<<<IBM SPU/SPC>>>,
  /* 24-35 are reserved.  */
  EM_V800 = 36		<<<NEC V800>>>,
  EM_FR20 = 37		<<<Fujitsu FR20>>>,
  EM_RH32 = 38		<<<TRW RH-32>>>,
  EM_RCE = 39		<<<Motorola RCE>>>,
  EM_ARM = 40		<<<ARM 32-bit architecture (AARCH32)>>>,
  EM_ALPHA = 41		<<<Digital Alpha>>>,
  EM_SH = 42		<<<Hitachi SH>>>,
  EM_SPARCV9 = 43	<<<SPARC Version 9>>>,
  EM_TRICORE = 44	<<<Siemens TriCore embedded processor>>>,
  EM_ARC = 45		<<<Argonaut RISC Core, Argonaut Technologies Inc.>>>,
  EM_H8_300 = 46	<<<Hitachi H8/300>>>,
  EM_H8_300H = 47	<<<Hitachi H8/300H>>>,
  EM_H8S = 48		<<<Hitachi H8S>>>,
  EM_H8_500 = 49	<<<Hitachi H8/500>>>,
  EM_IA_64 = 50		<<<Intel IA-64 processor architecture>>>,
  EM_MIPS_X = 51	<<<Stanford MIPS-X>>>,
  EM_COLDFIRE = 52	<<<Motorola ColdFire>>>,
  EM_68HC12 = 53	<<<Motorola M68HC12>>>,
  EM_MMA = 54		<<<Fujitsu MMA Multimedia Accelerator>>>,
  EM_PCP = 55		<<<Siemens PCP>>>,
  EM_NCPU = 56		<<<Sony nCPU embedded RISC processor>>>,
  EM_NDR1 = 57		<<<Denso NDR1 microprocessor>>>,
  EM_STARCORE = 58	<<<Motorola Star*Core processor>>>,
  EM_ME16 = 59		<<<Toyota ME16 processor>>>,
  EM_ST100 = 60		<<<STMicroelectronics ST100 processor>>>,
  EM_TINYJ = 61		<<<Advanced Logic Corp. TinyJ embedded processor family>>>,
  EM_X86_64 = 62	<<<AMD x86-64 architecture>>>,
  EM_PDSP = 63		<<<Sony DSP Processor>>>,
  EM_PDP10 = 64		<<<Digital Equipment Corp. PDP-10>>>,
  EM_PDP11 = 65		<<<Digital Equipment Corp. PDP-11>>>,
  EM_FX66 = 66		<<<Siemens FX66 microcontroller>>>,
  EM_ST9PLUS = 67	<<<STMicroelectronics ST9+ 8/16 bit microcontroller>>>,
  EM_ST7 = 68		<<<STMicroelectronics ST7 8-bit microcontroller>>>,
  EM_68HC16 = 69	<<<Motorola MC68HC16 Microcontroller>>>,
  EM_68HC11 = 70	<<<Motorola MC68HC11 Microcontroller>>>,
  EM_68HC08 = 71	<<<Motorola MC68HC08 Microcontroller>>>,
  EM_68HC05 = 72	<<<Motorola MC68HC05 Microcontroller>>>,
  EM_SVX = 73		<<<Silicon Graphics SVx>>>,
  EM_ST19 = 74		<<<STMicroelectronics ST19 8-bit microcontroller>>>,
  EM_VAX = 75		<<<Digital VAX>>>,
  EM_CRIS = 76		<<<Axis Communications 32-bit embedded processor>>>,
  EM_JAVELIN = 77	<<<Infineon Technologies 32-bit embedded processor>>>,
  EM_FIREPATH = 78	<<<Element 14 64-bit DSP Processor>>>,
  EM_ZSP = 79		<<<LSI Logic 16-bit DSP Processor>>>,
  EM_MMIX = 80		<<<Donald Knuth's educational 64-bit processor>>>,
  EM_HUANY = 81		<<<Harvard University machine-independent object files>>>,
  EM_PRISM = 82		<<<SiTera Prism>>>,
  EM_AVR = 83		<<<Atmel AVR 8-bit microcontroller>>>,
  EM_FR30 = 84		<<<Fujitsu FR30>>>,
  EM_D10V = 85		<<<Mitsubishi D10V>>>,
  EM_D30V = 86		<<<Mitsubishi D30V>>>,
  EM_V850 = 87		<<<NEC v850>>>,
  EM_M32R = 88		<<<Mitsubishi M32R>>>,
  EM_MN10300 = 89	<<<Matsushita MN10300>>>,
  EM_MN10200 = 90	<<<Matsushita MN10200>>>,
  EM_PJ = 91		<<<picoJava>>>,
  EM_OPENRISC = 92	<<<OpenRISC 32-bit embedded processor>>>,
  EM_ARC_COMPACT = 93	<<<ARC International ARCompact processor>>>,
  EM_XTENSA = 94	<<<Tensilica Xtensa Architecture>>>,
  EM_VIDEOCORE = 95	<<<Alphamosaic VideoCore processor>>>,
  EM_TMM_GPP = 96	<<<Thompson Multimedia General Purpose Processor>>>,
  EM_NS32K = 97		<<<National Semiconductor 32000 series>>>,
  EM_TPC = 98		<<<Tenor Network TPC processor>>>,
  EM_SNP1K = 99		<<<Trebia SNP 1000 processor>>>,
  EM_ST200 = 100	<<<STMicroelectronics (www.st.com) ST200 microcontroller>>>,
  EM_IP2K = 101		<<<Ubicom IP2xxx microcontroller family>>>,
  EM_MAX = 102		<<<MAX Processor>>>,
  EM_CR = 103		<<<National Semiconductor CompactRISC microprocessor>>>,
  EM_F2MC16 = 104	<<<Fujitsu F2MC16>>>,
  EM_MSP430 = 105	<<<Texas Instruments embedded microcontroller msp430>>>,
  EM_BLACKFIN = 106	<<<Analog Devices Blackfin (DSP) processor>>>,
  EM_SE_C33 = 107	<<<S1C33 Family of Seiko Epson processors>>>,
  EM_SEP = 108		<<<Sharp embedded microprocessor>>>,
  EM_ARCA = 109		<<<Arca RISC Microprocessor>>>,

  EM_UNICORE = 110	<<< Microprocessor series from PKU-Unity Ltd. and MPRC
                     	    of Peking University.  >>>,

  EM_EXCESS = 111	<<<eXcess: 16/32/64-bit configurable embedded CPU>>>,
  EM_DXP = 112		<<<Icera Semiconductor Inc. Deep Execution Processor>>>,
  EM_ALTERA_NIOS2 = 113	<<<Altera Nios II soft-core processor>>>,
  EM_CRX = 114		<<<National Semiconductor CompactRISC CRX microprocessor>>>,
  EM_XGATE = 115	<<<Motorola XGATE embedded processor>>>,
  EM_C166 = 116		<<<Infineon C16x/XC16x processor>>>,
  EM_M16C = 117		<<<Renesas M16C series microprocessors>>>,
  EM_DSPIC30F = 118	<<<Microchip Technology dsPIC30F Digital Signal Controller>>>,
  EM_CE = 119		<<<Freescale Communication Engine RISC core>>>,
  EM_M32C = 120		<<<Renesas M32C series microprocessors>>>,
  /* 121-130 are reserved.  */
  EM_TSK3000 = 131	<<<Altium TSK3000 core>>>,
  EM_RS08 = 132		<<<Freescale RS08 embedded processor>>>,
  EM_SHARC = 133	<<<Analog Devices SHARC family of 32-bit DSP processors>>>,
  EM_ECOG2 = 134	<<<Cyan Technology eCOG2 microprocessor>>>,
  EM_SCORE7 = 135	<<<Sunplus S+core7 RISC processor>>>,
  EM_DSP24 = 136	<<<New Japan Radio (NJR) 24-bit DSP Processor>>>,
  EM_VIDEOCORE3 = 137	<<<Broadcom VideoCore III processor>>>,
  EM_LATTICEMICO32 = 138 <<<RISC processor for Lattice FPGA architecture>>>,
  EM_SE_C17 = 139	<<<Seiko Epson C17 family>>>,
  EM_TI_C6000 = 140	<<<The Texas Instruments TMS320C6000 DSP family>>>,
  EM_TI_C2000 = 141	<<<The Texas Instruments TMS320C2000 DSP family>>>,
  EM_TI_C5500 = 142	<<<The Texas Instruments TMS320C55x DSP family>>>,

  EM_TI_ARP32 = 143	<<< Texas Instruments Application Specific RISC Processor,
                     	    32bit fetch.  >>>,

  EM_TI_PRU = 144	<<<Texas Instruments Programmable Realtime Unit>>>,
  /* 145-159 are reserved.  */
  EM_MMDSP_PLUS = 160	<<<STMicroelectronics 64bit VLIW Data Signal Processor>>>,
  EM_CYPRESS_M8C = 161	<<<Cypress M8C microprocessor>>>,
  EM_R32C = 162		<<<Renesas R32C series microprocessors>>>,
  EM_TRIMEDIA = 163	<<<NXP Semiconductors TriMedia architecture family>>>,
  EM_QDSP6 = 164	<<<QUALCOMM DSP6 Processor>>>,
  EM_8051 = 165		<<<Intel 8051 and variants>>>,
  EM_STXP7X = 166	<<<STMicroelectronics STxP7x family of configurable and>>>
                     	<<<extensible RISC processors>>>,
  EM_NDS32 = 167	<<<Andes Technology compact code size embedded RISC>>>
                     	<<<processor family>>>,
  EM_ECOG1 = 168	<<<Cyan Technology eCOG1X family>>>,
  EM_ECOG1X = 168	<<<Cyan Technology eCOG1X family>>>,
  EM_MAXQ30 = 169	<<<Dallas Semiconductor MAXQ30 Core Micro-controllers>>>,
  EM_XIMO16 = 170	<<<New Japan Radio (NJR) 16-bit DSP Processor>>>,
  EM_MANIK = 171	<<<M2000 Reconfigurable RISC Microprocessor>>>,
  EM_CRAYNV2 = 172	<<<Cray Inc. NV2 vector architecture>>>,
  EM_RX = 173		<<<Renesas RX family>>>,
  EM_METAG = 174	<<<Imagination Technologies META processor architecture>>>,
  EM_MCST_ELBRUS = 175	<<<MCST Elbrus general purpose hardware architecture>>>,
  EM_ECOG16 = 176	<<<Cyan Technology eCOG16 family>>>,
  EM_CR16 = 177		<<<National Semiconductor CompactRISC CR16 16-bit>>>
                     	<<<microprocessor>>>,
  EM_ETPU = 178		<<<Freescale Extended Time Processing Unit>>>,
  EM_SLE9X = 179	<<<Infineon Technologies SLE9X core>>>,
  EM_L10M = 180		<<<Intel L10M>>>,
  EM_K10M = 181		<<<Intel K10M>>>,
  /* 182 is reserved.  */
  EM_AARCH64 = 183	<<<ARM 64-bit architecture (AARCH64)>>>,
  /* 184 is reserved.  */
  EM_AVR32 = 185	<<<Atmel Corporation 32-bit microprocessor family>>>,
  EM_STM8 = 186		<<<STMicroeletronics STM8 8-bit microcontroller>>>,
  EM_TILE64 = 187	<<<Tilera TILE64 multicore architecture family>>>,
  EM_TILEPRO = 188	<<<Tilera TILEPro multicore architecture family>>>,
  EM_MICROBLAZE = 189	<<<Xilinx MicroBlaze 32-bit RISC soft processor core>>>,
  EM_CUDA = 190		<<<NVIDIA CUDA architecture>>>,
  EM_TILEGX = 191	<<<Tilera TILE-Gx multicore architecture family>>>,
  EM_CLOUDSHIELD = 192	<<<CloudShield architecture family>>>,
  EM_COREA_1ST = 193	<<<KIPO-KAIST Core-A 1st generation processor family>>>,
  EM_COREA_2ND = 194	<<<KIPO-KAIST Core-A 2nd generation processor family>>>,
  EM_ARC_COMPACT2 = 195	<<<Synopsys ARCompact V2>>>,
  EM_OPEN8 = 196	<<<Open8 8-bit RISC soft processor core>>>,
  EM_RL78 = 197		<<<Renesas RL78 family>>>,
  EM_VIDEOCORE5 = 198	<<<Broadcom VideoCore V processor>>>,
  EM_78KOR = 199	<<<Renesas 78KOR family>>>,
  EM_56800EX = 200	<<<Freescale 56800EX Digital Signal Controller (DSC)>>>,
  EM_BA1 = 201		<<<Beyond BA1 CPU architecture>>>,
  EM_BA2 = 202		<<<Beyond BA2 CPU architecture>>>,
  EM_XCORE = 203	<<<XMOS xCORE processor family>>>,
  EM_MCHP_PIC = 204	<<<Microchip 8-bit PIC(r) family>>>,
  EM_INTEL205 = 205	<<<Reserved by Intel>>>,
  EM_INTEL206 = 206	<<<Reserved by Intel>>>,
  EM_INTEL207 = 207	<<<Reserved by Intel>>>,
  EM_INTEL208 = 208	<<<Reserved by Intel>>>,
  EM_INTEL209 = 209	<<<Reserved by Intel>>>,
  EM_KM32 = 210		<<<KM211 KM32 32-bit processor>>>,
  EM_KMX32 = 211	<<<KM211 KMX32 32-bit processor>>>,
  EM_KMX16 = 212	<<<KM211 KMX16 16-bit processor>>>,
  EM_KMX8 = 213		<<<KM211 KMX8 8-bit processor>>>,
  EM_KVARC = 214	<<<KM211 KVARC processor>>>,
  EM_CDP = 215		<<<Paneve CDP architecture family>>>,
  EM_COGE = 216		<<<Cognitive Smart Memory Processor>>>,
  EM_COOL = 217		<<<Bluechip Systems CoolEngine>>>,
  EM_NORC = 218		<<<Nanoradio Optimized RISC>>>,
  EM_CSR_KALIMBA  = 219	<<<CSR Kalimba architecture family>>>,
  EM_Z80  = 220		<<<Zilog Z80>>>,
  EM_VISIUM  = 221	<<<Controls and Data Services VISIUMcore processor>>>,

  EM_FT32  = 222	<<< FTDI Chip FT32 high performance 32-bit
                     	    RISC architecture.  >>>,

  EM_MOXIE = 223	<<<Moxie processor family>>>,
  EM_AMDGPU = 224	<<<AMD GPU architecture>>>,
  /* 225 - 242 are reserved.  */
  EM_RISCV = 243	<<<RISC-V>>>
};

enum elf_e_version
{
  EV_NONE = 0		<<<Invalid version>>>,
  EV_CURRENT = 1	<<<Current version>>>
};

enum elf_sh_type
{
  SHT_NULL = 0		<<<Inactive section>>>,

  <<< Section holds information defined by the program whose
      format and meaning are determined solely by the program. >>>

  SHT_PROGBITS = 1,

  SHT_SYMTAB = 2	<<<Section holds a symbol table>>>,
  SHT_STRTAB = 3	<<<Section holds a string table>>>,

  <<< Section holds relocation entries with explicit addens. >>>

  SHT_RELA = 4,

  SHT_HASH = 5		<<<Section holds a symbol hash table>>>,
  SHT_DYNAMIC = 6	<<<Section holds the dynamic section>>>,

  <<< Section holds information that marks the file in some way. >>>

  SHT_NOTE = 7,

  <<< Section occupies no space in the file but otherwise resembles
      STH_PROGBITS. >>>

  SHT_NOBITS = 8,

  <<< Section contains relocation entries without explicit
      addends. >>>

  SHT_REL = 9,

  SHT_SHLIB = 10	<<<Section type reserved with undefined semantics>>>,
  SHT_DYNSYM = 11	<<<Section holds a symbol table>>>,

  <<< Section contains an array of pointers to initialization
      functions. >>>

  SHT_INIT_ARRAY = 14,

  <<< Section contains an array of pointers to termination
      functions. >>>

  SHT_FINI_ARRAY = 15,

  <<< Section contains an array of pointers to functions that are
      invoked before all other initialization functions. >>>

  SHT_PREINIT_ARRAY = 16,

  SHT_GROUP = 17	<<<Section defines a section group>>>,
  SHT_SYMTAB_SHNDX = 18	<<<Section is associated with a symbol table section>>>,
  SHT_LOOS = 0x60000000	<<<Operating system-specific>>>,
  SHT_HIOS = 0x6fffffff	<<<Operating system-specific>>>,
  SHT_LOPROC = 0x70000000 <<<Processor-specific>>>,
  SHT_HIPROC = 0x7fffffff <<<Processor-specific>>>,
  SHT_LOUSER = 0x80000000 <<<Reserved for application programs>>>,
  SHT_HIUSER = 0xffffffff <<<Reserved for application programs>>>
};

enum elf_sh_flags
{
  <<< Section contains data that should be writable during
      process execution.  >>>

  SHF_WRITE = 0x1,

  <<< Section occupies memory during process execution.  >>>

  SHF_ALLOC = 0x2,

  <<<Section contains executable machine instructions>>>

  SHF_EXECINSTR = 0x4,

  <<< The data in the section may be merged to eliminate
      duplication.  >>>

  SHF_MERGE = 0x10,

  <<< The data elements in the section consist of null-terminate
      character strings.  >>>

  SHF_STRINGS = 0x20,

  <<< The sh_info field of this section header holds a section
      header table index.  >>>

  SHF_INFO_LINK = 0x40,

  <<< Special ordering requiremetns for link editors.  >>>

  SHF_LINK_ORDER = 0x80,

  <<< This section equires special OS-specific processing, beyond
      standard linking rules, to avoid incorrect behavior.  >>>

  SHF_OS_NONCONFORMING = 0x100,

  SHF_GROUP = 0x200		<<<This section is a member of a section group>>>,
  SHF_TLS = 0x400		<<<This section holds thread-local storage>>>,
  SHF_COMPRESSED = 0x800     	<<<This section holds compressed data>>>,
  SHF_MASKOS = 0x0ff0_0000   	<<<Operating system-specific flags>>>,
  SHF_MASKPROC = 0xf000_0000 	<<<Processor-specific flags>>>
};

enum elf_p_type
{
  PT_NULL = 0		<<<Array element is unused>>>,
  PT_LOAD = 1		<<<Loadable segment>>>,
  PT_DYNAMIC = 2	<<<Dynamic linking information>>>,
  PT_INTERP = 3		<<<Location and size of a null-terminated>>>
			<<<path name to invoke as an interpreter>>>,
  PT_NOTE = 4		<<<Location and size of auxiliary>>>
			<<<information>>>,
  PT_SHLIB = 5		<<<Reserved.  Unspecified semantics>>>,
  PT_PHDR = 6		<<<Location and size of the program header>>>
                        <<<table itself>>>,
  PT_TLS = 7		<<<Thread-Local storage template>>>,
  PT_LOOS = 0x60000000	<<<Operating system-specific>>>,
  PT_HIOS = 0x6fffffff	<<<Operating system-specific>>>,
  PT_LOPROC = 0x70000000 <<<Processor-specific>>>,
  PT_HIPROC = 0x7fffffff <<<Processor-specific>>>
};

enum elf_p_flags
{
  PF_X = 0x1		<<<Execute>>>,
  PF_W = 0x2		<<<Write>>>,
  PF_R = 0x4		<<<Read>>>,
  PF_MASKOS = 0xff00000	<<<Unspecified>>>,
  PF_MASKPROC = 0xf000_0000 <<<Unspecified>>>
};

enum elf_ch_type
{
  ELFCOMPRESS_ZLIB = 1		<<<ZLIB algorithm>>>,
  ELFCOMPRESS_LOOS = 0x60000000	<<<Operating system-specific>>>,
  ELFCOMPRESS_HIOS = 0x6fffffff	<<<Operating system-specific>>>,
  ELFCOMPRESS_LOPROC = 0x70000000 <<<Processor-specific>>>,
  ELFCOMPRESS_HIPROC = 0x7fffffff <<<Processor-specific>>>
};

/*
	#define ELF32_R_SYM(i)	((i) >>> 8)
	#define ELF32_R_TYPE(i)   ((unsigned char)(i))
	#define ELF32_R_INFO(s,t) (((s) <<< 8)+(unsigned char)(t))
   
               sym     |type
        |----|----|----|----|

	#define ELF64_R_SYM(i)    ((i) >>> 32)
	#define ELF64_R_TYPE(i)   ((i) & 0xffffffffL)
	#define ELF64_R_INFO(s,t) (((s) <<< 32)+((t) & 0xffffffffL))

                sym         |        type 
        |----|----|----|----|----|----|----|----|

 */

struct elf_rel <<<ELF relocation>>>
{
  elf_addr r_offset	<<<Relocation location>>>;

  info_start = .;
  elf_xword r_info	<<<Relocation info: symbol + type>>>;

  . -= info_start;
  elf_r_sym r_sym;	<<<Relocation symbol>>>
  elf_r_type r_type;	<<<Relocation type>>>
};

struct elf_rela <<<ELF relocation with addend>>>
{
  elf_addr r_offset	<<<Relocation location>>>;

  info_start = .;
  elf_xword r_info	<<<Relocation info: symbol + type>>>;

  . = info_start;
  elf_r_sym r_sym;	<<<Relocation symbol>>>
  elf_r_type r_type;	<<<Relocation type>>>

  assert (sizeof (elf_r_sym) + sizeof (elf_r_type) == sizeof (elf_xword));

  elf_sxword r_addend	<<<
                           Constant addend used to compute
                           the value to be stored into the
                           relocatable field.
                        >>>;
};

struct elf_ident <<<ELF identification>>>
{
  byte ei_mag[4];

  enum elf_ei_class ei_class : 8 <<<File class>>>;
  byte ei_data            <<<Data encoding>>>;
  byte ei_version         <<<File version>>>;
  byte ei_osabi           <<<Operating system/ABI identification>>>;
  byte ei_abiversion      <<<ABI version>>>;
  byte ei_pad             <<<Start of padding bytes>>>;
  . = 16;
  byte ei_nident          <<<Size of e_ident, in bytes>>>;
};

struct elf_ehdr <<<ELF header>>>
{
  <<< Magic number and machine-independent data for
      decoding the file. >>>

  struct elf_ident e_ident;

  enum elf_e_type e_type : 16	    <<<File type>>>;
  enum elf_e_machine e_machine : 16 <<<Required architecture>>>;
  enum elf_e_version e_version : 32 <<<Object file version>>>;

  <<< Virtual address of entry point.  If the file has no
      associated entry point, holds zero.  >>>

  elf_xword e_entry;

  <<< Program header table's file offset in bytes.  If the file
      has no program header table, holds zero.  >>>

  elf_xword e_phoff;

  <<< Section header table's file offset in bytes.  If the file
      has no section header table, holds zero.  >>>

  elf_xword e_shoff;

  elf_word  e_flags;    /* XXX: this is machine-specific.  */
  elf_half  e_ehsize    <<<ELF header size in bytes>>>;

  <<< Size in bytes of one entry in the file's program header
      table.  >>>

  elf_half  e_phentsize;

  <<< Number of entries in the program header table.  If the file
      has no program header table, holds zero.  >>>

  elf_half  e_phnum;

  <<< Size in bytes of one entry in the file's section header
      table.  >>>

  elf_half  e_shentsize;

  <<< Number of entries in the section header table.  If the file
      has no section header table, holds zero.  >>>

  elf_half  e_shnum;

  <<< Section header table index of the entry associated with
      the section name string table, or SHN_UNDEF.  >>>

  elf_half  e_shstrndx;
};

struct elf_phdr <<<ELF segment>>>
{
  enum elf_p_type p_type : 32	<<<Segment type>>>;
  enum elf_p_flags p_flags : 32	<<<Section flags>>>;
  elf_off p_offset;
  elf_addr p_vaddr;
  elf_addr p_paddr;
  elf_xword p_filesz;
  elf_xword p_memsz;
  elf_xword p_align;
};

struct elf_shdr <<<ELF section header>>>
{
   <<< Index of the section's name into the section header
       string table section. >>>

   elf_word  sh_name;
    
   enum elf_sh_type  sh_type : 32 <<<Section type>>>;
   enum elf_sh_flags sh_flags : sizeof (elf_xword) * 8
     				  <<<Section flags>>>;

   <<< If the section will appear in the memory image of a process,
       this member gives the address at which the section's first
       byte should reside.  Otherwise the member contains 0.  >>>

   elf_addr sh_addr;

   <<< Byte offset from the beginning of the file to the first byte
       in the section.  For SHT_NOBITS sections, this is the
       conceptual placement on the file.  >>>

   elf_off sh_offset;
   
   elf_xword sh_size    <<<Section size in bytes>>>;
   elf_word  sh_link    <<<Section header table index link>>>;

   <<< Extra inforamtion, whose interpretation depends on the
       section type.  >>>

   elf_word  sh_info;

   <<< Alignment constraint for the section. >>>
   elf_xword sh_addralign;

   <<< If the section holds a table of fixed-size entries, this
       holds the size of each entry in bits.  Holds 0 if the section
       does not hold a table of fixed-size entries.  >>>

   elf_xword sh_entsize;
};

/* structs for the contents of certain ELF sections.  */

struct elf_chdr
<<<
   ELF compressed section header.
   Used in sections with SHF_COMPRESSED
>>>
{
  enum elf_ch_type ch_type : 32	<<< Compression algorithm. >>>;
  elf_xword ch_size		<<< Size in bytes of the uncompressed data. >>>;
  elf_xword ch_addralign	<<< Required alignment of the uncompressed data. >>>;
};

/* Finally, the ELF object file itself.  */

struct elf <<<ELF object file>>>
{
  /* The ELF header is always present, and it is always located at the
  beginning of the object file.  */

  struct elf_ehdr ehdr <<<ELF header>>>;

  /* Both the section header table and the program header table are
     optional.  */

  if (ehdr.e_shnum > 0)
    {
      . = ehdr.e_shoff;
      struct elf_shdr shdr[ehdr.e_shnum] <<<ELF section header table>>>;
    }

  if (ehdr.e_phnum > 0)
    {
      . = ehdr.e_phoff;
      struct elf_phdr phdr[ehdr.e_phnum] <<<ELF program header table>>>;
    }

  /* The sections and segments are defined in terms of the contents of
     the two tables defined above.  Note that sections and segments
     usually overlap. */

  for (i = 0; i < ehdr.e_shnum; i++)
    {
      . = shdr[i].sh_offset;
      byte section<i>[shdr[i].sh_size] <<<ELF section>>>;
    }

  for (i = 0; i < ehdr.e_phnum; i++)
    {
      . = phdr[i].p_offset;
      byte segment<i>[pdhr[i].p_size] <<<ELF segment>>>;
    }
};


/* Integrity for struct elf:

     - Only one SHT_DYNAMIC section.
     - SHT_GROUP sections should only appear in objects with
       ehdr.e_type == ET_REL (relocatable objects).
     - ET_REL requires a section header table.
     - ET_EXEC requires a program header table.
     - Only one PT_INTERP segment in a file.
     - Only one PT_PHDR segment in a file.

   Integrity for elf_ident:

     - ei_mag[0] == 0x7f && ei_mag[1] == 'E'
       && ei_mag[2] == 'L'  && ei_mag[3] == 'F'

   Integrity for elf_ehdr:

     - sizeof (e_ident) == e_ident.ei_nident
       && sizeof (struct elf_header) == e_ehsize);

*/
