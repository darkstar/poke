/* elf.pcl -- ELF implementation for GNU poke.  */  /* -*- mode: c -*- */

/* Copyright (C) 2017 Jose E. Marchesi.  */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* This file contains a PCL (poke command language) description of the
 * ELF (Executable and Linking Format) object file format.  The ELF
 * format is described in the chapter 4 of the SysV ABI.
 *
 * Both ELF32 and ELF64 are supported.
 *
 * In general, we use the same field names used in the C structs
 * documented in the gABI, that are also used in the widely used ELF
 * implementations like in the GNU binutils and also in elfutils.
 * This makes life easier for system hackers who are already familiar
 * with these names.
 */

/* First of all, define some types.  */

typedef unsigned int elf_word;
typedef int elf_sword;
typedef unsigned short elf_half;

typedef unsigned int elf32_addr;
typedef unsigned int elf32_off;
typedef unsigned int elf32_sword;

typedef unsigned long elf64_addr;
typedef unsigned long elf64_off;
typedef unsigned long elf64_xword;
typedef int elf64_sword;
typedef long elf64_sxword;

/* Now enumerations.  */

enum byte elf_ei_class
{
  /** Invalid class.  */
  ELFCLASSNONE = 0x0,
  /** 32-bit objects.  */
  ELFCLASS32 = 0x1,
  /** 64-bit objects.  */
  ELFCLASS64 = 0x2
};

enum byte elf_ei_data
{
  /** Invalid data encoding.  */
  ELFDATANONE = 0,
  /** 2's complement values, with the least significant byte occupying
      the lowest address.  */
  ELFDATA2LSB = 1,
  /** 2's complement values, with the most significant byte occupying
      the lowest address.  */
  ELFDATA2MSB = 2
};

enum elf_half elf_e_type
{
  /** No file type.  */
  ET_NONE = 0x0000,
  /** Relocatable file.  */
  ET_REL  = 0x0001,
  /** Executable file.  */
  ET_EXEC = 0x0002,
  /** Shared object file.  */
  ET_DYN  = 0x0003,
  /** Core file.  */
  ET_CORE = 0x0004,
  /** Begin of operating system-specific range.  */
  ET_LOOS = 0xFE00,
  /** End of operating system-specific range.  */
  ET_HIOS = 0xFEFF,
  /** Begin of processor-specific range.  */
  ET_LOPROC = 0xFF00,
  /** End of processor-specific range.  */
  ET_HIPROC = 0xFFFF
};

enum elf_half elf_e_machine
{
  /** No machine.  */
  EM_NONE  = 0,
  /** AT&T WE 32100 */
  EM_M32   = 1,
  /** SPARC */
  EM_SPARC = 2,
  /** Intel 80386 */
  EM_386   = 3,
  /** Motorola 68000 */
  EM_68K   = 4,
  /** Motorola 88000 */
  EM_88K   = 5,
  /** Intel MCU */
  EM_IAMCU = 6,
  /** Intel 80860 */
  EM_860   = 7,
  /** MIPS I Architecture */
  EM_MIPS  = 8,
  /** IBM System/370 Processor */
  EM_S370  = 9,
  /** MIPS RS3000 Little-endian */
  EM_MIPS_RS3_LE = 10 
  /* 11-14 are reserved. */
  /** Hewlett-Packard PA-RISC */
  EM_PARISC = 15,
  /* 16 is reserved.  */
  /** Fujitsu VPP500 */
  EM_VPP500 = 1,
  /** 32-bit on V9 SPARC */
  EM_SPARC32PLUS = 18,
  /** Intel 80960 */
  EM_960 = 19,
  /** PowerPC */
  EM_PPC = 20,
  /** 64-bit PowerPC */
  EM_PPC64 = 21,
  /** IBM System/390 Processor */
  EM_S390 = 22,
  /** IBM SPU/SPC */
  EM_SPU = 23,
  /* 24-35 are reserved.  */
  /** NEC V800 */
  EM_V800 = 36,
  /** Fujitsu FR20 */
  EM_FR20 = 37,
  /** TRW RH-32 */
  EM_RH32 = 38,
  /** Motorola RCE */
  EM_RCE = 39,
  /** ARM 32-bit architecture (AARCH32) */
  EM_ARM = 40,
  /** Digital Alpha */
  EM_ALPHA = 41,
  /** Hitachi SH */
  EM_SH = 42,
  /** SPARC Version 9 */
  EM_SPARCV9 = 43,
  /** Siemens TriCore embedded processor */
  EM_TRICORE = 44,
  /** Argonaut RISC Core, Argonaut Technologies Inc. */
  EM_ARC = 45,
  /** Hitachi H8/300 */
  EM_H8_300 = 46,
  /** Hitachi H8/300H */
  EM_H8_300H = 47,
  /** Hitachi H8S */
  EM_H8S = 48,
  /** Hitachi H8/500 */
  EM_H8_500 = 49,
  /** Intel IA-64 processor architecture */
  EM_IA_64 = 50,
  /** Stanford MIPS-X */
  EM_MIPS_X = 51,
  /** Motorola ColdFire */
  EM_COLDFIRE = 52,
  /** Motorola M68HC12 */
  EM_68HC12 = 53,
  /** Fujitsu MMA Multimedia Accelerator */
  EM_MMA = 54,
  /** Siemens PCP */
  EM_PCP = 55,
  /** Sony nCPU embedded RISC processor */
  EM_NCPU = 56,
  /** Denso NDR1 microprocessor */
  EM_NDR1 = 57,
  /** Motorola Star*Core processor */
  EM_STARCORE = 58,
  /** Toyota ME16 processor */
  EM_ME16 = 59,
  /** STMicroelectronics ST100 processor */
  EM_ST100 = 60,
  /** Advanced Logic Corp. TinyJ embedded processor family */
  EM_TINYJ = 61,
  /** AMD x86-64 architecture */
  EM_X86_64 = 62,
  /** Sony DSP Processor */
  EM_PDSP = 63,
  /** Digital Equipment Corp. PDP-10 */
  EM_PDP10 = 64,
  /** Digital Equipment Corp. PDP-11 */
  EM_PDP11 = 65,
  /** Siemens FX66 microcontroller */
  EM_FX66 = 66,
  /** STMicroelectronics ST9+ 8/16 bit microcontroller */
  EM_ST9PLUS = 67,
  /** STMicroelectronics ST7 8-bit microcontroller */
  EM_ST7 = 68,
  /** Motorola MC68HC16 Microcontroller */
  EM_68HC16 = 69,
  /** Motorola MC68HC11 Microcontroller */
  EM_68HC11 = 70,
  /** Motorola MC68HC08 Microcontroller */
  EM_68HC08 = 71,
  /** Motorola MC68HC05 Microcontroller */
  EM_68HC05 = 72,
  /** Silicon Graphics SVx */
  EM_SVX = 73,
  /** STMicroelectronics ST19 8-bit microcontroller */
  EM_ST19 = 74,
  /** Digital VAX */
  EM_VAX = 75,
  /** Axis Communications 32-bit embedded processor */
  EM_CRIS = 76,
  /** Infineon Technologies 32-bit embedded processor */
  EM_JAVELIN = 77,
  /** Element 14 64-bit DSP Processor */
  EM_FIREPATH = 78,
  /** LSI Logic 16-bit DSP Processor */
  EM_ZSP = 79,
  /** Donald Knuth's educational 64-bit processor */
  EM_MMIX = 80,
  /** Harvard University machine-independent object files */
  EM_HUANY = 81,
  /** SiTera Prism */
  EM_PRISM = 82,
  /** Atmel AVR 8-bit microcontroller */
  EM_AVR = 83,
  /** Fujitsu FR30 */
  EM_FR30 = 84,
  /** Mitsubishi D10V */
  EM_D10V = 85,
  /** Mitsubishi D30V */
  EM_D30V = 86,
  /** NEC v850 */
  EM_V850 = 87,
  /** Mitsubishi M32R */
  EM_M32R = 88,
  /** Matsushita MN10300 */
  EM_MN10300 = 89,
  /** Matsushita MN10200 */
  EM_MN10200 = 90,
  /** picoJava */
  EM_PJ = 91,
  /** OpenRISC 32-bit embedded processor */
  EM_OPENRISC = 92,
  /** ARC International ARCompact processor */
  EM_ARC_COMPACT = 93,
  /** Tensilica Xtensa Architecture */
  EM_XTENSA = 94,
  /** Alphamosaic VideoCore processor */
  EM_VIDEOCORE = 95,
  /** Thompson Multimedia General Purpose Processor */
  EM_TMM_GPP = 96,
  /** National Semiconductor 32000 series */
  EM_NS32K = 97,
  /** Tenor Network TPC processor */
  EM_TPC = 98,
  /** Trebia SNP 1000 processor */
  EM_SNP1K = 99,
  /** STMicroelectronics (www.st.com) ST200 microcontroller */
  EM_ST200 = 100,
  /** Ubicom IP2xxx microcontroller family */
  EM_IP2K = 101,
  /** MAX Processor */
  EM_MAX = 102,
  /** National Semiconductor CompactRISC microprocessor */
  EM_CR = 103,
  /** Fujitsu F2MC16 */
  EM_F2MC16 = 104,
  /** Texas Instruments embedded microcontroller msp430 */
  EM_MSP430 = 105,
  /** Analog Devices Blackfin (DSP) processor */
  EM_BLACKFIN = 106,
  /** S1C33 Family of Seiko Epson processors */
  EM_SE_C33 = 107,
  /** Sharp embedded microprocessor */
  EM_SEP = 108,
  /** Arca RISC Microprocessor */
  EM_ARCA = 109,
  /**  Microprocessor series from PKU-Unity.  */
  EM_UNICORE = 110,
  /** eXcess: 16/32/64-bit configurable embedded CPU */
  EM_EXCESS = 111,
  /** Icera Semiconductor Inc. Deep Execution Processor */
  EM_DXP = 112,
  /** Altera Nios II soft-core processor */
  EM_ALTERA_NIOS2 = 113,
  /** National Semiconductor CompactRISC CRX microprocessor */
  EM_CRX = 114,
  /** Motorola XGATE embedded processor */
  EM_XGATE = 115,
  /** Infineon C16x/XC16x processor */
  EM_C166 = 116,
  /** Renesas M16C series microprocessors */
  EM_M16C = 117,
  /** Microchip Technology dsPIC30F Digital Signal Controller */
  EM_DSPIC30F = 118,
  /** Freescale Communication Engine RISC core */
  EM_CE = 119,
  /** Renesas M32C series microprocessors */
  EM_M32C = 120,
  /* 121-130 are reserved.  */
  /** Altium TSK3000 co,re */
  EM_TSK3000 = 131,
  /** Freescale RS08 embedded processor */
  EM_RS08 = 132,
  /** Analog Devices SHARC family of 32-bit DSP processors */
  EM_SHARC = 133,
  /** Cyan Technology eCOG2 microprocessor */
  EM_ECOG2 = 134,
  /** Sunplus S+core7 RISC processor */
  EM_SCORE7 = 135,
  /** New Japan Radio (NJR) 24-bit DSP Processor */
  EM_DSP24 = 136,
  /** Broadcom VideoCore III processor */
  EM_VIDEOCORE3 = 137	,,
  /** RISC processor for Lattice FPGA architecture.  */
  EM_LATTICEMICO32 = 138,
  /** Seiko Epson C17 family */
  EM_SE_C17 = 139,
  /** The Texas Instruments TMS320C6000 DSP family */
  EM_TI_C6000 = 140,
  /** The Texas Instruments TMS320C2000 DSP family */
  EM_TI_C2000 = 141,
  /** The Texas Instruments TMS320C55x DSP family */
  EM_TI_C5500 = 142,
  /** Texas Instruments Application Specific RISC Processor, 32bit
      fetch.  */
  EM_TI_ARP32 = 143,
  /** Texas Instruments Programmable Realtime Unit */
  EM_TI_PRU = 144,
  /* 145-159 are reserved.  */
  /** STMicroelectronics 64bit VLIW Data Signal Processor */
  EM_MMDSP_PLUS = 160,
  /** Cypress M8C microprocessor */
  EM_CYPRESS_M8C = 161,
  /** Renesas R32C series microprocessors */
  EM_R32C = 162,
  /** NXP Semiconductors TriMedia architecture family */
  EM_TRIMEDIA = 163,
  /** QUALCOMM DSP6 Processor */
  EM_QDSP6 = 164,
  /** Intel 8051 and variants */
  EM_8051 = 165,
  /** STMicroelectronics STxP7x family of configurable and extensible
      RISC processors.  */
  EM_STXP7X = 166,
  /** Andes Technology compact code size embedded RISC processor
      family.  */
    EM_NDS32 = 167,                        
  /** Cyan Technology eCOG1X family */
  EM_ECOG1 = 168,
  /** Cyan Technology eCOG1X family */
  EM_ECOG1X = 168,
  /** Dallas Semiconductor MAXQ30 Core Micro-controllers */
  EM_MAXQ30 = 169,
  /** New Japan Radio (NJR) 16-bit DSP Processor */
  EM_XIMO16 = 170,
  /** M2000 Reconfigurable RISC Microprocessor */
  EM_MANIK = 171,
  /** Cray Inc. NV2 vector architecture */
  EM_CRAYNV2 = 172,
  /** Renesas RX family */
  EM_RX = 173,
  /** Imagination Technologies META processor architecture */
  EM_METAG = 174,
  /** MCST Elbrus general purpose hardware architecture */
  EM_MCST_ELBRUS = 175,
  /** Cyan Technology eCOG16 family */
  EM_ECOG16 = 176,
  /** National Semiconductor CompactRISC CR16 16-bit
      microprocessor.  */
  EM_CR16 = 177,
  /** Freescale Extended Time Processing Unit */
  EM_ETPU = 178
  /** Infineon Technologies SLE9X core */
  EM_SLE9X = 179,
  /** Intel L10M */
  EM_L10M = 180,
  /** Intel K10M */
  EM_K10M = 181,
  /* 182 is reserved.  */
  /** ARM 64-bit architecture (AARCH64) */
  EM_AARCH64 = 183,
  /* 184 is reserved.  */
  /** Atmel Corporation 32-bit microprocessor family */
  EM_AVR32 = 185,
  /** STMicroeletronics STM8 8-bit microcontroller */
  EM_STM8 = 186,
  /** Tilera TILE64 multicore architecture family */
  EM_TILE64 = 187,
  /** Tilera TILEPro multicore architecture family */
  EM_TILEPRO = 188,
  /** Xilinx MicroBlaze 32-bit RISC soft processor core */
  EM_MICROBLAZE = 189,
  /** NVIDIA CUDA architecture */
  EM_CUDA = 190,
  /** Tilera TILE-Gx multicore architecture family */
  EM_TILEGX = 191,
  /** CloudShield architecture family */
  EM_CLOUDSHIELD = 192,
  /** KIPO-KAIST Core-A 1st generation processor family */
  EM_COREA_1ST = 193,
  /** KIPO-KAIST Core-A 2nd generation processor family */
  EM_COREA_2ND = 194,
  /** Synopsys ARCompact V2 */
  EM_ARC_COMPACT2 = 195,
  /** Open8 8-bit RISC soft processor core */
  EM_OPEN8 = 196,
  /** Renesas RL78 family */
  EM_RL78 = 197,
  /** Broadcom VideoCore V processor */
  EM_VIDEOCORE5 = 198,
  /** Renesas 78KOR family */
  EM_78KOR = 199,
  /** Freescale 56800EX Digital Signal Controller (DSC) */
  EM_56800EX = 200,
  /** Beyond BA1 CPU architecture */
  EM_BA1 = 201,
  /** Beyond BA2 CPU architecture */
  EM_BA2 = 202,
  /** XMOS xCORE processor family */
  EM_XCORE = 203,
  /** Microchip 8-bit PIC(r) family */
  EM_MCHP_PIC = 204,
  /** Reserved by Intel */
  EM_INTEL205 = 205,
  /** Reserved by Intel */
  EM_INTEL206 = 206,
  /** Reserved by Intel */
  EM_INTEL207 = 207,
  /** Reserved by Intel */
  EM_INTEL208 = 208,
  /** Reserved by Intel */
  EM_INTEL209 = 209,
  /** KM211 KM32 32-bit processor */
  EM_KM32 = 210,
  /** KM211 KMX32 32-bit processor */
  EM_KMX32 = 211,
  /** KM211 KMX16 16-bit processor */
  EM_KMX16 = 212,
  /** KM211 KMX8 8-bit processor */
  EM_KMX8 = 213,
  /** KM211 KVARC processor */
  EM_KVARC = 214,
  /** Paneve CDP architecture family */
  EM_CDP = 215,
  /** Cognitive Smart Memory Processor */
  EM_COGE = 216,
  /** Bluechip Systems CoolEngine */
  EM_COOL = 217,
  /** Nanoradio Optimized RISC */
  EM_NORC = 218,
  /** CSR Kalimba architecture family */
  EM_CSR_KALIMBA  = 219,
  /** Zilog Z80 */
  EM_Z80  = 220,
  /** Controls and Data Services VISIUMcore processor */
  EM_VISIUM  = 221,
  /**  FTDI Chip FT32 high performance 32-bit RISC architecture.  */
  EM_FT32  = 222,
  /** Moxie processor family */
  EM_MOXIE = 223,
  /** AMD GPU architecture */
  EM_AMDGPU = 224,
  /* 225 - 242 are reserved.  */
  /** RISC-V */
  EM_RISCV = 243
};

enum elf_word elf_e_version
{
  /** Invalid version.  */
  EV_NONE = 0,
  /** Current version.  */
  EV_CURRENT = 1
};

enum elf_word elf_sh_type
{
  /** Inactive section.  */
  SHT_NULL = 0,

  /** Section holds information defined by the program whose format and
      meaning are determined solely by the program.  */
  SHT_PROGBITS = 1,

  /** Section holds a symbol table.  */
  SHT_SYMTAB = 2,

  /** Section holds a string table.  */
  SHT_STRTAB = 3,

  /** Section holds relocation entries with explicit addends.  */
  SHT_RELA = 4,

  /** Section holds a symbol hash table.  */
  SHT_HASH = 5,

  /** Section holds the dynamic section.  */
  SHT_DYNAMIC = 6,

  /** Section holds information that marks the file in some way.  */
  SHT_NOTE = 7,

  /** Section occupies no space in the file but otherwise resembles
      SHT_PROGBITS.  */
  SHT_NOBITS = 8,

  /** Section contains relocation entries without explicit
      addends.  */
  SHT_REL = 9,

  /** Section type reserved with undefined semantics.  */
  SHT_SHLIB = 10,

  /** Section holds a symbol table.  */
  SHT_DYNSYM = 11,

  /* Note that entries 12 and 13 are unused.  */
    
  /** Section contains an array of pointers to initialization
      functions.  */
  SHT_INIT_ARRAY = 14,

  /** Section contains an array of pointers to termination
      functions.  */
  SHT_FINI_ARRAY = 15,

  /** Section contains an array of pointers to functions that are
      invoked before all other initialization functions.  */
  SHT_PREINIT_ARRAY = 16,

  /** Section defines a section group.  */
  SHT_GROUP = 17,

  /** Section is associated with a symbol table section.  */
  SHT_SYMTAB_SHNDX = 18,

  /** Begin of operating system-specific range. */
  SHT_LOOS = 0x60000000,

  /** End of operating system-specific range.  */
  SHT_HIOS = 0x6fffffff,

  /** Begin of processor-specific range.  */
  SHT_LOPROC = 0x70000000,

  /** End of processor-specific range.  */
  SHT_HIPROC = 0x7fffffff,

  /** Begin of range resreved for application programs.  */
  SHT_LOUSER = 0x80000000,

  /** End of range reserved for application programs.  */
  SHT_HIUSER = 0xffffffff
};

bitmask elf_xword elf_sh_flags
{
  /** Section contains data that should be writable during process
      execution.  */
  SHF_WRITE = 0x1,

  /** Section occupies memory during process execution.  */
  SHF_ALLOC = 0x2,

  /** Section contains executable machine instructions.  */
  SHF_EXECINSTR = 0x4,

  /** The data in the section may be merged to eliminate
      duplication.  */
  SHF_MERGE = 0x10,

  /** The data elements in the section consist of null-terminate
      character strings.  */
  SHF_STRINGS = 0x20,

  /** The sh_info field of this section header holds a section header
      table index.  */
  SHF_INFO_LINK = 0x40,

  /** Special ordering requiremetns for link editors.  */
  SHF_LINK_ORDER = 0x80,

  /** This section equires special OS-specific processing, beyond
      standard linking rules, to avoid incorrect behavior.  */
  SHF_OS_NONCONFORMING = 0x100,

  /** This section is a member of a section group.  */
  SHF_GROUP = 0x200,

  /** This section holds thread-local storage.  */
  SHF_TLS = 0x400,

  /** This section holds compressed data.  */
  SHF_COMPRESSED = 0x800,

  /** Operating system-specific flags.  */
  SHF_MASKOS = 0x0ff00000,

  /** Processor-specific flags.  */
  SHF_MASKPROC = 0xf0000000
};

enum elf_word elf_p_type
{
  /** Array element is unused.  */
  PT_NULL = 0,

  /** Loadable segment.  */
  PT_LOAD = 1,

  /** Dynamic linking information.  */
  PT_DYNAMIC = 2,

  /** Location and size of a null-terminated path name to invoke as an
      interpreter.  */
  PT_INTERP = 3,

  /** Location and size of auxiliary information.  */
  PT_NOTE = 4,

  /** Reserved.  Unspecified semantics.  */
  PT_SHLIB = 5,

  /** Location and size of the program header table itself.  */
  PT_PHDR = 6,

  /** Thread-local storage template.  */
  PT_TLS = 7,

  /** Begin of operating system-specific range.  */
  PT_LOOS = 0x60000000,

  /** End of operating system-specific range.  */
  PT_HIOS = 0x6fffffff,

  /** Begin of processor-specific range.  */
  PT_LOPROC = 0x70000000,

  /** End of processor-specific range.  */
  PT_HIPROC = 0x7fffffff
};

bitmask elf_word elf_p_flags
{
  /** Segment is executable.  */
  PF_X = 0x1,

  /** Segment is writeable.  */
  PF_W = 0x2,

  /** Segment is readable.  */
  PF_R = 0x4,

  /** OS-specific flags mask.  */
  PF_MASKOS = 0xff00000,

  /** Processor-specific flags mask.  */
  PF_MASKPROC = 0xf0000000
};

enum elf_word elf_ch_type
{
  /** Section is compressed with ZLIB.  */
  ELFCOMPRESS_ZLIB = 1,

  /** Begin of operating system-specific compression range.  */
  ELFCOMPRESS_LOOS = 0x60000000,

  /** End of operating system-specific compression range.  */
  ELFCOMPRESS_HIOS = 0x6fffffff,

  /** Begin of processor-specific compression range.  */
  ELFCOMPRESS_LOPROC = 0x70000000,

  /** End of processo-specific compression range.  */
  ELFCOMPRESS_HIPROC = 0x7fffffff
};

enum int elf_sym_binding
{
  /** Local symbols are not visible outside the object file containing
      their definition.  Local symbols of the same name exist in multiple
      files without interfering with each other.  */
  STB_LOCAL = 0,
  /** Global symbols are visible to all object files being combined.
      One file's definition of a global symbol will satisfy another
      file's undefined reference to the same global symbol.  */
  STB_GLOBAL = 1,
  /** Weak symbols resemble global symbols, but their definitions have
      lower precedence.  */
  STB_WEAK = 2,
  /** Operating system-specific semantics.  */
  STB_LOOS = 10,
  /** Operating system-specific semantics.  */
  STB_HIOS = 12,
  /** Processor-specific semantics.  */
  STB_LOPROC = 13,
  /** Processor-specific semantics.  */
  STB_HIPROC = 15
};

enum int elf_st_type
{
  /** The symbol's type is not specified.  */
  STT_NOTYPE = 0,
  /** The symbol is associated with a data object, such as a
      variable, an array, and so on.  */
  STT_OBJECT = 1,
  /** The symbol is associated with a function or other executable
      code.  */
  STT_FUNC = 2,
  /** The symbol is associated with a section.  Symbol table entries
      of this type exist primarily for relocation and normally have
      STB_LOCAL binding.  */
  STT_SECTION = 3,
  /** Conventionally, the symbol's name gives the name of the source
      file associated with the object file.  A file symbol has
      STB_LOCAL binding, its section index is SHN_ABS and it precedes
      the other STB_LOCAL symbols for the file, if it is present.  */
  STT_FILE = 4,
  /** This symbol labels an uninitialized common block.  */
  STT_COMMON = 5,
  /** The symbol specifies a Thread-Local Storage entity.  When
      defined, it gives the assigned offset for the symbol, not the
      actual address.  */
  STT_TLS = 6,
  /** Operating system-specific semantics.  */
  STT_LOOS = 10,
  /** Operating system-specific semantics.  */
  STT_HIOS = 12,
  /** Processor-specific semantics.  */
  STT_LOPROC = 13,
  /** Processor-specific semantics.  */
  STT_HIPROC = 15
};

enum int elf_sym_visibility
{
  /** The visibility of this symbol is specified by the symbol's
      binding type.  That is, global and weak symbols are visible
      outside of their defining component (executable file or shared
      object).  Local symbols are hidden.  Global and weak symbols are
      also preemptable, taht is, they may be preempted by definitions
      of the same name in another component.  */
  STV_DEFAULT = 0,
  /** The visibility of this symbol is defined by processor
      supplements, to further constrain hidden symbols.  */
  STV_INTERNAL = 1,
  /** This symbol is not visible to other components.  */
  STV_HIDDEN = 2,
  /** This symbol is visible in other components but not preemptable,
      meaning that any reference to such a symbol from within the
      defining component must be resolved to the definition in that
      component, even if there is a definition in another component
      that would preempt by the default rules.  */
  STV_PROTECTED = 3
};

/** ELF relocation.  */
struct elf_rel (enum elf_ei_class class)
{
  switch (class)
    {
    case ELFCLASS32:
      /** Relocation location.  */
      elf32_addr r_offset;
      /** Relocation info: symbol + type.  */
      elf_word r_info;
      . = @r_info;
      /** Relocation symbol.  */
      int r_sym : 24;
      /** Relocation type.  */
      int r_type : 8;

      break;

    case ELFCLASS64:
      /** Relocation location.  */
      elf64_addr r_offset;
      /** Relocation info: symbol + type.  */
      elf64_xword r_info;
      . = @r_info;
      /** Relocation symbol.  */
      int r_sym : 32;
      int r_type : 32;

      break;

    case ELFCLASSNONE:
      break;
    }

  assert (sizeof (r_sym) + sizeof (r_type) == sizeof (r_info));
};

/** ELF relocation with addend.  */
struct elf_rela (enum elf_ei_class class)
{
  switch (class)
    {
    case ELFCLASS32:
      /** Relocation info: symbol + type.  */
      elf_word r_info;
      . = @r_info;
      /** Relocation symbol.  */
      int r_sym : 24;
      /** Relocation type.  */
      int r_type : 8;
      
      break;

    case ELFCLASS64:
      /** Relocation location.  */
      elf64_addr r_offset;
      /** Relocation info: symbol + type.  */
      elf64_xword r_info;
      . = @r_info;
      /** Relocation symbol.  */
      int r_sym : 32;
      int r_type : 32;

      break;

    case ELFCLASSNONE:
      break;
    }

  /** Constant addend used to compute the value to be stored into the
      relocatable field.  */
  elf_sword r_addend;

  assert (sizeof (r_sym) + sizeof (r_type) == sizeof (r_info));
};

/** ELF identification.  */
struct elf_ident
{
  byte ei_mag[4] = {0x7f, 'E', 'L', 'F'};

  /** File class.  */
  enum elf_ei_class ei_class;
  /** Data encoding.  */
  byte ei_data;
  /** File version.  */
  byte ei_version;
  /** Operating system/ABI identification.  */
  byte ei_osabi;
  /** ABI version.  */
  byte ei_abiversion;
  /** Start of padding bytes.  */
  byte ei_pad;
  . = 16;
  /* Size of e_ident, in bytes.  */
  byte ei_nident;
};


/** ELF header.  */
struct elf_ehdr
{
  /** Magic number and machine-independent data for decoding the
      file.  */
  struct elf_ident e_ident;

  /* Set the endianness for the data stored in the ELF file using the
     data encoding information in the header.  This applies to every
     field defined from this point on.  */
  switch (e_ident.ei_data)
    {
    case ELFDATANONE:
      /* This should NOT happend.  */
      assert (1);
      break;
    case ELFDATA2LSB:
      .endian = lsb;
      .nencoding = neg2c;
      break;
    case ELFDATA2MSB:
      .endian = msb;
      .nencoding = neg2c;
      break;
    }
  
  /** File type.  */
  enum elf_e_type e_type;

  /* Relocatable files require a section header table.  */
  /* Executable files require a program header table.  */
  assert (e_type == ET_REL => e_shnum > 0
          && e_type == ET_EXEC => e_phnum > 0);

  /** Required architecture.  */
  enum elf_e_machine e_machine;

  /** Object file version.  */
  enum elf_e_version e_version;

  /** Virtual address of entry point.  If the file has no associated
      entry point, holds zero.  */
  elf_xword e_entry;

  /** Program header table's file offset in bytes.  If the file has no
      program header table, holds zero.  */
  elf_xword e_phoff;

  /** Section header table's file offset in bytes.  If the file has no
      section header table, holds zero.  */
  elf_xword e_shoff;

  /** XXX: this is machine-specific.  */
  elf_word  e_flags;

  /** ELF header size in bytes.  */
  elf_half  e_ehsize; /* XXX  = sizeof (struct elf_ehdr);*/

  /** Size in bytes of one entry in the file's program header
      table.  */
  elf_half  e_phentsize; /* XXX = sizeof (struct elf_phdr); */

  /** Number of entries in the program header table.  If the file has
      no program header table, holds zero.  */
  elf_half  e_phnum;

  /** Size in bytes of one entry in the file's section header
      table.  */
  elf_half  e_shentsize; /* XXX  = sizeof (struct elf_shdr); */

  /** Number of entries in the section header table.  If the file has
      no section header table, holds zero.  */
  elf_half  e_shnum;

  /** Section header table index of the entry associated with the
      section name string table, or SHN_UNDEF.  */
  elf_half  e_shstrndx;
};

/** ELF program header.  */
struct elf_phdr (struct elf_ehdr ehdr)
{
  /** Segment type.  */
  enum elf_p_type p_type;

  /* SHT_GROUP sections should only appear in relocatable
     objects.  */
  
  assert (p_type == SHT_GROUP => ehdr.e_type == ET_REL);

  /** This member gives flags relevant to the segment.  */
  bitmask elf_p_flags p_flags;

  /** Offset into the beginning of the file at which the first byte of
      the segment resides.  */
  elf_off p_offset;

  /** Virtual address at which the first byte of the segment resides
      in memory.  */
  elf_addr p_vaddr;

  /** On systems for which physical addressing is relevant, this
      member is reserved for the segment's physical address.  Becase
      System V ignores physical addressing for application programs,
      this member has unspecified contents for executable files and
      shared objects.  */
  elf_addr p_paddr;

  /** This member gives the number of bytes in the file image of the
      segment; it may be zero.  */
  elf_xword p_filesz;

  /** This member gives the number of bytes in the memory image of the
      segment; it may be zero.  */
  elf_xword p_memsz;

  /** This member gives the value to which the segments are aligned in
      memory and in the file.  VAlues 0 and 1 mean no alignment is
      required.  Otherwise, p_align should be a positive, integral
      power of 2, and p_vaddr should equal p_offset, modulo
      p_align.  */
  elf_xword p_align;
};

/** ELF section header.  */
struct elf_shdr (struct elf_ehdr ehdr)
{
  /** Index of the section's name into the section header string table
      section.  */
  elf_word sh_name
    [[read=elf_str_table (elf, sh_name)]];
    
  /** Section type.  */
  enum elf_sh_type sh_type;

  /** Section flags.  */
  bitmask elf_sh_flags sh_flags;

  /** If the section will appear in the memory image of a process,
      this member gives the address at which the section's first byte
      should reside.  Otherwise the member contains 0.  */
  elf_addr sh_addr;

  /** Byte offset from the beginning of the file to the first byte in
      the section.  For SHT_NOBITS sections, this is the conceptual
      placement on the file.  */
  elf_off sh_offset;

  /** Section size in bytes.  */
  elf_xword sh_size;

  /** Section header table index link.  */
  elf_word sh_link;

  /** Extra information, whose interpretation depends on the section
      type.  */
  elf_word  sh_info;

  /**  Alignment constraint for the section.  */
  elf_xword sh_addralign;

  /** If the section holds a table of fixed-size entries, this holds
      the size of each entry in bits.  Holds 0 if the section does not
      hold a table of fixed-size entries.  */
  elf_xword sh_entsize;

  assert (sh_size % sh_entsize == 0);
};

/* structs for the contents of certain ELF sections.  */

/** ELF compressed section header.
    Used in sections with SHF_COMPRESSED.  */
struct elf_chdr
{
  /** Compression algorithm.  */
  enum elf_ch_type ch_type;

  /** Size in bytes of the uncompressed data.  */
  elf_xword ch_size;

  /** Required alignment of the uncompressed data.  */
  elf_xword ch_addralign;
};

/** ELF symbol table entry.  */
struct elf_sym (enum elf_ei_class class)
{
  switch (class)
    {
    case ELFCLASS32:
      /** Index into the object file's symbol string table,
          which holds the character representations of the
          symbol names.  */
      elf32_word st_name;
      /** Value of the associated symbol.  */
      elf32_addr st_value;
      /** Size associated with this symbol.  */
      elf32_word st_size;
      unsigned char st_info;

      . = @st_info;
      enum elf_sym_binding st_bind : 28;
      enum elf_sym_type st_type : 4;

      assert (sizeof (st_info) ==
              sizeof (st_bind) + sizeof (st_type));

      /** Other information about the symbol.  */
      unsigned char st_other;

      . = @st_other;
      /** Symbol's visibility.  */
      enum elf_sym_visibility st_visibility : 3;
      . += 5;

      /* Section header table index of the section related to this
         symbol.  */
      elf32_half st_shndx;
      break;

    case ELFCLASS64:
      /** Index into the object file's symbol string table,
          which holds the character representations of the
          symbol names.  */
      elf64_word st_name;
      /** Symbol's type and binding attributes.  */
      unsigned char st_info;

      . = @st_info;
      enum elf_sym_binding st_bind : 60;
      enum elf_sym_type st_type : 4;

      assert (sizeof (st_info) ==
              sizeof (st_bind) + sizeof (st_type));

      /** Other information about the symbol.  */
      unsigned char st_other;

      . = @st_other;
      /** Symbol's visibility.  */
      enum elf_sym_visibility st_visibility : 3;
      . += 5;

      /* Section header table index of the section related to this
         symbol.  */
      elf64_half st_shndx;
      /** Value of the associated symbol.  */
      elf64_addr st_value;
      /** Size associated with this symbol.  */
      elf64_xword st_size;
      break;
      
    case ELFCLASSNONE:
      break;
    };

  /* Constraints.  */

  /* A symbol with STB_LOCAL binding may not have STV_PROTECTED
     visibility.  */
  assert (st_bind == STV_LOCAL => st_visibility != STV_PROTECTED);

  /* XXX: a STT_FILE symbol has STB_LOCAL binding, its section index
     is SHN_ABS and it precedes the other STB_LOCAL symbols for the
     file.  */
};

struct elf_section (enum elf_ei_class class,
                    struct elf_shdr shdr)
{
  switch (shdr.sh_type)
    {
    case SHT_NULL:
      break;

    case SHT_PROGBITS:
      char progbits[sh_size];
      break;

    case SHT_SYMTAB:
      struct elf_sym symtab (class) [sh_size / sh_entsize];
      break;

    case SHT_REL:
      struct elf_rel rel (class) [sh_size / sh_entsize];
      break;

    case SHT_RELA:
      struct elf_rela rela (class) [sh_size / sh_entsize];
      break;

    default:
      break;
    };
};

/* Finally, the ELF object file itself.  */

/** ELF object file.  */
struct elf
{
  /** ELF header.   */
  struct elf_ehdr ehdr;

  assert (sizeof (ehdr.e_ident) == ehdr.e_ident.ei_nident
          && sizeof (ehdr) == ehdr.e_ehsize);

  /* Both the section header table and the program header table are
     optional.  */

  if (ehdr.e_shnum > 0)
    {
      . = ehdr.e_shoff;
      /** ELF section header table.  */      
      struct elf_shdr shdr[ehdr.e_shnum] (ehdr);
    };

  if (ehdr.e_phnum > 0)
    {
      . = ehdr.e_phoff;
      /** ELF program header table.
     
          Some entries describe process segments; others give
          supplementary information and do not contribute to the
          process image.  */
      struct elf_phdr phdr[ehdr.e_phnum] (ehdr);
    };

  /* The sections and segments themselves are defined in terms of the
     contents of the two tables defined above.  Note that sections and
     segments usually overlap. */

  let int i;

  for (i = 0; i < ehdr.e_shnum; i++)
    {
      . = shdr[i].sh_offset;
      struct elf_section section (ehdr.e_ident.ei_class,
                                  shdr[i]);
    }

  for (i = 0; i < ehdr.e_phnum; i++)
    {
      . = phdr[i].p_offset;
      struct elf_segment segment (ehdr, phdr[i]);
    }
};

/* Integrity for struct elf:

     - Only one SHT_DYNAMIC section.
     - Only one PT_INTERP segment in a file.
     - Only one PT_PHDR segment in a file.
*/

/* Functions for:

   - Getting a section (array) given a name.

*/
 
